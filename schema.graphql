input AcceptFriendRequestInput {
  # The authenticated user will accept the friend request sent by the user with an ID equal to targetID.
  targetID: ID!
}

type AcceptFriendRequestPayload {
  # The user whose friend request was just accepted.
  user: User
}

# Error associated with mutation AcceptOrganizationInvite.
type AcceptOrganizationInviteError {
  # Error code.
  code: AcceptOrganizationInviteErrorCode!
}

# Client error code.
enum AcceptOrganizationInviteErrorCode {
  # Internal error.
  INTERNAL_ERROR
  # Invalid Argument.
  INVALID_ARGUMENT
  # Invitation not found.
  NOT_FOUND
  # The requesting user does not permission to accept invite.
  PERMISSION_DENIED
  # The user doesn't meet the requirements to have this role. For example, when trying to assign the
  # "BILLING_MANAGER" role, but the user doesn't have 2FA enabled or completed Extension Monetization Onboarding.
  MEMBER_INELIGIBLE
  # Organization Member already exists.
  ALREADY_EXISTS
  # User is exceeds the the limit of organization they can be a member for.
  EXCEEDS_MEMBERSHIP_LIMIT
}

# Input to the AcceptOrganiztaionInvite mutation.
input AcceptOrganizationInviteInput {
  # First name to the user accepting the invite.
  firstName: String!
  # Last name of the user accepting the invite.
  lastName: String!
  # ID of the invite to accept.
  organizationInviteID: ID!
  # Job title the user has in the inviting organization.
  title: String!
}

# Output from the AcceptOrganizationInvite mutation.
type AcceptOrganizationInvitePayload {
  # The possible error returned from service.
  error: AcceptOrganizationInviteError
}

# Enumerates possible errors when accepting a program agreement.
enum AcceptProgramAgreementError {
  # Must have auth credentials to agree to a program agreement.
  UNAUTHENTICATED
  # User does not have permission to agree to the program agreement for the targeted user.
  FORBIDDEN
  # User does not have an invitation matching the program agreement signed.
  NOT_FOUND
  # Version of the agreement provided in the input is not valid.
  INVALID_AGREEMENT_VERSION
  # An internal error has occurred.
  INTERNAL_ERROR
}

# AcceptProgramAgreementInput is the input required when accepting a program agreement.
input AcceptProgramAgreementInput {
  # TargetUserID is the ID of the user whose program agreement will be accepted.
  targetUserID: ID!
  # Agreement type being accepted for payout onboarding.
  type: PayoutOnboardingCategory!
  # Version of agreement (e.g. "v1").
  version: String!
}

# AcceptProgramAgreementPayload is the payload returned after accepting a program agreement.
type AcceptProgramAgreementPayload {
  # Describes error that occured while accepting a program agreement.
  error: AcceptProgramAgreementError
  # New workflow state.
  workflow: PayoutOnboardingWorkflow
}

# Errors from acceptSquadStreamInvitation mutation.
type AcceptSquadStreamInvitationError {
  # Error from request to accept invitation.
  code: AcceptSquadStreamInvitationErrorCode!
}

# Possible errors from this mutation.
enum AcceptSquadStreamInvitationErrorCode {
  # Invitation to be accepted does not exist.
  INVITATION_NOT_FOUND
  # Squad associated with the invitation does not exist.
  SQUAD_NOT_FOUND
  # User does not have permissions to accept invitation.
  UNAUTHORIZED
  # Invitation not in pending state cannot be accepted.
  INVITATION_CANNOT_BE_ACCEPTED
  # The recipient does not have access to squad streams.
  USER_CANNOT_ACCESS_SQUADS
}

# Inputs to the acceptSquadStreamInvitation mutation.
input AcceptSquadStreamInvitationInput {
  # ID of the invitation to be accepted.
  invitationID: ID!
}

# Outputs from the acceptSquadStreamInvitation mutation.
type AcceptSquadStreamInvitationPayload {
  # Error from mutation if exists.
  error: AcceptSquadStreamInvitationError
  # The accepted invitation.
  invitation: SquadStreamInvitation
}

# The information about all of a user's connected accounts.
type AccountConnectionSet {
  # Connection information about a user's Blizzard account.
  blizzard: UserBlizzardConnectionLink
  # Connection infromation about a user's Facebook account.
  facebook: UserFacebookConnectionLink
  # Whether or not the user has a linked amazon account.
  hasConnectedAmazon: Boolean
  # Connection information about a user's Riot account.
  riot: UserRiotConnectionLink
  # Connection information about a user's Steam account.
  steam: UserSteamConnectionLink
  # Connection information about a user's Twitter account.
  twitter: UserTwitterConnectionLink
  # Connection information about a user's Youtube account.
  youtube: UserYoutubeConnectionLink
}

# An error returned from the acknowledgePredictionResult mutation.
type AcknowledgePredictionResultError {
  # Code describing the error.
  code: AcknowledgePredictionResultErrorCode!
}

# Possible error codes from the acknowledgePredictionResult mutation.
enum AcknowledgePredictionResultErrorCode {
  # The authorized user is forbidden from acknowledging this Prediction result.
  FORBIDDEN
  # The specified Prediction ID was not found.
  NOT_FOUND
  # The specified Prediction ID has not been resolved yet.
  NOT_RESOLVED
  # An unknown error occurred.
  UNKNOWN
}

# Acknowledge the results of a Prediction.
input AcknowledgePredictionResultInput {
  # The Prediction ID.
  id: ID!
}

# Payload for acknowledging the results of a Prediction.
type AcknowledgePredictionResultPayload {
  # If present, there was an error with the request.
  error: AcknowledgePredictionResultError
  # The acknowledgged Prediction.
  prediction: Prediction
}

# AcknowledgeSubscriptionStateInput updates the state of the given subscription to aknowledged.
input AcknowledgeSubscriptionStateInput {
  # ID of the subscription being updated.
  subscriptionID: ID!
}

# AcknowledgeSubscriptionStatePayload returns the state of the subscription.
type AcknowledgeSubscriptionStatePayload {
  # The current state of the subscription. One of "active", "will_not_renew", or "canceled".
  state: UnacknowledgedSubscriptionEventState
}

# Required input to acknowledge an unban request on a channel.
input AcknowledgeUnbanRequestInput {
  # ID of the unban request to be acknowledged.
  id: ID!
}

# Result of acknowledging an unban request.
type AcknowledgeUnbanRequestPayload {
  # Used for errors arising from acknowledging the unban request.
  error: UnbanRequestError
  # The acknowledged unban request.
  unbanRequest: UnbanRequest
}

# The input to be provided to the activateExtension mutation.
input ActivateExtensionInput {
  # The anchor the extension is getting activated into.
  anchor: ExtensionAnchor!
  # The composite ID of an extension installation <extensionID:version:channelID>.
  extensionInstallationID: ID!
  # The slot the extension is getting activated into.
  slot: String!
}

# The result of an activateExtension mutation.
type ActivateExtensionPayload {
  # The resulting list of installed extensions after the activation.
  installedExtensions: [ExtensionInstallation!]!
}

# ActivationState contains possible activation states found in the ActivationConfig.
enum ActivationState {
  # The extension is activated into a slot on the channel.
  ACTIVE
  # The extension has not been activated into a slot or required permsissions/config
  # is not set up yet.
  INACTIVE
  # The user rejected the permissions required for the extension to be activated.
  REJECTED_PERMISSIONS
}

# An action (and metadata about the action) which a user or session is performing.
interface Activity {
  # The type of activity.
  type: ActivityType
}

# ActivityInput represents what the user is doing right now.
#
# If type is WATCHING, userID must be supplied.
#
# If type is PLAYING, gameID must be supplied.
input ActivityInput {
  gameID: String
  type: ActivityType
  userID: String
}

# The categories of activities which users can engage in.
enum ActivityType {
  PLAYING
  STREAMING
  WATCHING
}

# Amazon Digital Ad Service Properties.
type ADASProperties {
  # The media partner that should be used for the ad break.
  partner: String @deprecated(reason: "No longer needed.")
  # The id for selecting the amazon ad campaign or program.
  programID: ID @deprecated(reason: "No longer needed.")
}

# The context returned for the current ad request.
type AdContext {
  # The decline status for this ad request.
  declineState: AdContextDeclineState!
  # The id of the ad session this context applies to.
  id: ID!
  # The RAd service token used to validate subsequent ad event mutations.
  radToken: String!
}

# The decline state for the context.
type AdContextDeclineState {
  # The reason the ad request was declined if it was declined.
  reason: String
  # Whether or not the client will request an ad.
  shouldDecline: Boolean!
}

# Advertising creative.
type AdCreative {
  # The AdCreative's unique identifier.
  id: ID!
  # Integrated loudness value for this AdCreative.
  integratedLoudness: Float @deprecated
}

# AddAutohostChannelsInput append channelIDs to a user's list to autohost.
input AddAutohostChannelsInput {
  # ChannelIDs that will be added to the list to autohost.
  channelIDs: [ID!]!
  # UserID to update autohost list for.
  userID: ID!
}

# AddAutohostChannelsPayload returns the user whose autohostChannels field had been updated.
type AddAutohostChannelsPayload {
  # User whose autohostChannels field had been updated.
  user: User
}

input AddBrowserPushSubscriptionInput {
  # An authentication secret. It must be a non-blank string.
  auth: String!
  # A custom URL pointing to a push server, which can be used to send a push message to the
  # particular service worker instance that subscribed to the push service. It must be a
  # non-blank string.
  endpoint: String!
  # An Elliptic curve Diffieâ€“Hellman public key on the P-256 curve. It must be a non-blank string.
  p256DH: String!
}

type AddBrowserPushSubscriptionPayload {
  # The opaque ID of the push subscription. The entire push subscription is not returned because
  # there is no product use for it. Also, there is no existing query or mutation that can use this ID,
  # but it could be used for future functionality.
  browserPushSubscriptionID: ID
}

# Possible errors that this resolver returns.
enum AddChannelBlockedTermError {
  # User does not have permission to add blocked term in channel.
  NO_PERMISSIONS
  # Duration provided was invalid.
  DURATION_INVALID
}

# AddChannelBlockedTermInput takes in the channel, phrases, and if the term should be editable by mods.
input AddChannelBlockedTermInput {
  # channelID is the channelID owner of terms.
  channelID: ID!
  # isModEditable is if the term is viewable or editable by mods.
  isModEditable: Boolean!
  # phrase defines the string that is to be blocked.
  phrase: String!
  # phrases is the strings that are blocked. Deprecated - please use the phrase field instead.
  phrases: [String!] = []
}

# The returned data from the mutation.
type AddChannelBlockedTermPayload {
  # The newly added term.
  term: ChannelBlockedTerm
  # Whether or not the term was previously in the permitted terms list and has now been removed.
  wasRemovedFromPermittedList: Boolean
  # Mutation error caused by the user input.
  error: AddChannelBlockedTermError
  # The time term was added.
  addedAt: Time
    @deprecated(
      reason: "Use the term field for information about the newly added term"
    )
  # The phrases that were added.
  phrases: [String!]!
    @deprecated(
      reason: "Use the term field for information about the newly added term"
    )
}

# Possible errors that this resolver returns.
enum AddChannelPermittedTermError {
  # User does not have permission to add Permitted term in channel.
  NO_PERMISSIONS
  # Duration provided was invalid.
  DURATION_INVALID
}

# AddChannelPermittedTermInput takes in the channel, phrases, and if the term should be editable by mods.
input AddChannelPermittedTermInput {
  # channelID is the owner of the permitted terms.
  channelID: ID!
  # phrase defines the string that is to be permitted.
  phrase: String!
  # phrases are the strings that are permitted in a channel.  Deprecated - please use the phrase field instead.
  phrases: [String!] = []
}

# The returned payload from the mutation.
type AddChannelPermittedTermPayload {
  # The newly added term.
  term: ChannelPermittedTerm
  # Whether or not the term was previously in the blocked terms list and has now been removed.
  wasRemovedFromBlockedList: Boolean
  # Mutation error caused by the user input.
  error: AddChannelPermittedTermError
  # The time term was added.
  addedAt: Time
    @deprecated(
      reason: "Use the term field for information about the newly added term"
    )
  # The phrases that were added.
  phrases: [String!]!
    @deprecated(
      reason: "Use the term field for information about the newly added term"
    )
}

# AddCollectionItemInput accepts a collectionID and item ID and parameters to add the item to a collection.
input AddCollectionItemInput {
  # The id of the collection.
  collectionID: ID!
  # The id of the item of which will be added to the collection.
  itemID: ID!
  # The type of item ie. video.
  itemType: String!
}

# The response from adding an item to a collection.
type AddCollectionItemPayload {
  # The newly updated collection.
  collection: Collection
}

# Add a Phase to a Competition.
input AddCompetitionPhaseInput {
  # Unique Competition ID.
  competitionID: ID!
}

# Data that was mutated after the Phase was created.
type AddCompetitionPhasePayload {
  # The competition is returned with any side effects adding a phase has caused.
  competition: Competition
  # Used for competition mutation errors.
  error: CompetitionError
}

# Add a User as a player to a Competition.
input AddCompetitionPlayerInput {
  # Unique Competition ID.
  competitionID: ID!
  # The player's Discord username.
  discordUsername: String
  # The player's in-game username.
  inGameUsername: String
  # The state the player in. Defaults to INVITED if not specified.
  state: CompetitionPlayerState
  # Twitch user id of the player.
  userID: ID!
}

# Data that was mutated after the player was created.
type AddCompetitionPlayerPayload {
  # The new state of competition after adding a competition player to the competition.
  competition: Competition
  # Used for competition mutation errors.
  error: CompetitionError
}

# Inputs adding a competition team to a competition.
input AddCompetitionTeamInput {
  # ID of the competition team captain.
  captainID: ID
  # ID of the competition.
  competitionID: ID!
  # The user ids of the team members.
  members: [ID!]
  # The name of the team.
  name: String!
}

# AddCompetitionTeamPayload is the success response adding a competition team to the competition.
type AddCompetitionTeamPayload {
  # The new state of competition after adding a competition team to the competition.
  competition: Competition
  # Used for competition mutation errors.
  error: CompetitionError
}

# AddDeviceTokenInput accepts a token and other parameters to add a device token to a given user.
input AddDeviceTokenInput {
  # App build number of the current device.
  appBuild: String
  # Unique identifier of the current device.
  # Note: deprecated field -- the deviceID now comess of the X-Device-Id header...
  deviceID: ID
  # Arbitrary name associated with the device.
  deviceName: String
  # The ID of the new token.
  deviceToken: ID!
  # Notification capabilities of the current device.
  notificationCapabilitiesTypes: [String!]
  # Onsite notification capabilities of the current device.
  onsiteCapabilitiesTypes: [String!]
  # The platform the token is associated with, i.e. 'android' or 'ios'.
  platform: String!
  # ID for the user associated with the new device token.
  # Note: deprecated field -- the userID now comes off the authenticated user.
  userID: ID
}

# The response from adding a push notification token to a user.
type AddDeviceTokenPayload {
  # The ID of the new token.
  deviceToken: ID!
}

# AddDropToCampaignInput has fields required to create a drop within a campaign.
input AddDropToCampaignInput {
  # The campaign this drop belongs to.
  campaignID: ID!
  # The type of rule defining what needs to happen to trigger this drop.
  dropRuleType: DropRuleType!
  # The date at which this drop can no longer occur. Default to campaign endDate if not provided.
  endAt: Time
  # The friendly name of this drop.
  name: String!
  # The date at which this drop can start to occur. Default to campaign startDate if not provided.
  startAt: Time
}

# AddDropToCampaignPayload returns the result of the creation.
type AddDropToCampaignPayload {
  # Returns the newly created drop.
  drop: DropType
  # A mapped error returned by the drops management service.
  error: DropsError
}

# AddEditorError contains details about a client error that occurred.
type AddEditorError {
  # The type of error that occurred when adding an editor.
  code: AddEditorErrorCode!
}

# AddEditorErrorCode defines a client error that occurred while adding an editor.
enum AddEditorErrorCode {
  # The channel does not exist.
  CHANNEL_NOT_FOUND
  # The user who is to become an editor is already an editor.
  TARGET_USER_ALREADY_EDITOR
  # The user who is to become an editor does not exist.
  TARGET_USER_NOT_FOUND
}

# AddEditorInput contains the parameters to add an editor.
input AddEditorInput {
  # The channel for which the target user will become an editor.
  channelID: ID!
  # The ID of the user who will become an editor.
  # Either targetUserID or targetUserLogin must be provided.
  targetUserID: ID
  # The login of the user who will become an editor.
  # Either targetUserID or targetUserLogin must be provided.
  targetUserLogin: String
}

# AddEditorPayload is the response after attemping to add an editor.
type AddEditorPayload {
  # The channel for which the target user will become an editor.
  channel: User
  # The client error that has occurred.
  # Null if the operation is successful.
  error: AddEditorError
  # The user who became an editor.
  targetUser: User
}

# Error from a failed recent play mutation.
type AddRadioRecentlyPlayedError {
  # Mutation error code.
  code: AddRadioRecentlyPlayedErrorCode!
}

# Recently played error codes.
enum AddRadioRecentlyPlayedErrorCode {
  # The ID provided was malformed.
  INVALID_ID
  # Permission denied to add/update a recently played item.
  PERMISSION_DENIED
}

# AddRadioRecentlyPlayedInput contains the parameters to register a play start.
input AddRadioRecentlyPlayedInput {
  # The type of content the ID maps to.
  contentType: RadioRecentlyPlayedType!
  # The ID of the recently played item.
  id: ID!
}

# Response from registering a recent play.
type AddRadioRecentlyPlayedPayload {
  # Error code.
  error: AddRadioRecentlyPlayedError
  # The added/updated recently played item.
  recent: RadioRecentlyPlayed
}

input AddReactionInput {
  emoteID: ID!
  entityID: ID!
}

type AddReactionPayload {
  content: ReactableContent!
}

# Data required to add recommendation feedback.
input AddRecommendationFeedbackInput {
  # Reason for the feedback (ie. Not interested, offensive, etc).
  category: RecommendationFeedbackCategory!
  # The id of the item (channelID, gameID, etc).
  itemID: ID!
  # One of CHANNEL, GAME, SHELF, VOD.
  itemType: RecommendationFeedbackType!
  # The page this event was fired from.
  sourceItemPage: String!
  # The unique id given to this request.
  sourceItemRequestID: ID!
  # The tracking id of the shelf / shelf card.
  sourceItemTrackingID: ID!
}

# Returns the created feedback item back to the client.
type AddRecommendationFeedbackPayload {
  # Feedback item.
  recommendationFeedback: RecommendationFeedback
}

# Error that may be returned by the AddStreamAuthorizedUser mutation.
type AddStreamAuthorizedUserError {
  # Type of mutation error.
  code: AddStreamAuthorizedUserErrorCode!
}

# AddStreamAuthorizedUserErrorCode is the client error type that occurred during the AddStreamAuthorizedUser mutation.
enum AddStreamAuthorizedUserErrorCode {
  # Unable to assign the Targeted user to stream on behalf of the broadcaster.
  TARGET_USER_UNRETURNABLE
  # The broadcaster is not found.
  CHANNEL_NOT_FOUND
  # Maximum limit for adding authorized user is reached.
  MAX_ACCOUNT_LIMIT
  # Permission denied to add an authorized user.
  PERMISSION_DENIED
  # Invalid argument to add an authorized user.
  INVALID_ARGUMENT
}

# AddStreamAuthorizedUserInput contains the channelID for the broadcaster and the authorized userID.
input AddStreamAuthorizedUserInput {
  # authorizedUserID for an authorized user who is allow to stream on behalf of broadcaster.
  authorizedUserID: ID!
  # channelID of the broadcaster.
  channelID: ID!
}

# AddStreamAuthorizedUserPayload contains the VideoStreamSettings with updated authorized users.
type AddStreamAuthorizedUserPayload {
  # The updated channel of broadcaster.
  channel: Channel
  # Error code.
  error: AddStreamAuthorizedUserError
}

# AdPlatform describes the type of device.
enum AdPlatform {
  # Ios iphone app.
  IOS_PHONE
  # Ios tablet app.
  IOS_TABLET
  # Android phone app.
  ANDROID_PHONE
  # Android tablet app.
  ANDROID_TABLET
}

# A vote an ad poll and associated information.
type AdPollVote {
  # Id of the choice that was voted for.
  choiceID: ID!
  # id of the vote in the poll.
  id: ID!
  # Id of the poll this voter voted in.
  pollID: ID!
  # Id of the voter in the poll.
  userID: ID!
}

# Ad Properties is an object that defines ad properties for a channel.
type AdProperties {
  # Deprecated.
  adServer: String @deprecated(reason: "Should use adServerDefault instead")
  # Which adserver to send requests to.
  adServerDefault: String
  # Amazon Digital Ad Service (ADAS) specific Properties for this channel.
  # Properties should only be nested if it is ADAS specific.
  adasProperties: ADASProperties
  # Which ids are costreamers for this channel.
  costreamers: [User]
  # Contains ad density information for channel ads management.
  density: Density
  # Contains properties used by channel's disable prerolls feature.
  disablePrerollsAbility: DisablePrerollsAbility
  # Get the ad experiment treatment group for a specified experiment bucket.
  experimentTreatment(bucket: String!): String
  # How often ad breaks can be run on this channel.
  frequency: Int
  # If postrolls are disabled on this channel.
  hasPostrollsDisabled: Boolean
  # If prerolls are disabled on this channel.
  hasPrerollsDisabled: Boolean
  # If Turbo benefit is disabled on this channel.
  hasTurboDisabled: Boolean
  # If vod ads are enabled on this channel.
  hasVodAdsEnabled: Boolean
  # If multiplayer ads are enabled for subscribers on this channel.
  isMultiplayerAdsForSubsEnabled: Boolean
  # Maximum length for an ad break on this channel.
  maxAdBreakLength: Int
  # Current multiplayer ad offers on the channel.
  multiplayerAdOffers: [MultiplayerAdOffer!]
  # The stream has the required age gate enabled if greater than 0.
  requiredAge: Int
  # Tracking pixels that channel pages should fire at certain intervals.
  trackingPixels(consent: GDPRConsent): [TrackingPixel!]
  # Setting for vod archive midrolls on this channel. Can be 'broadcaster', 'inserted', or 'off'.
  vodArchiveMidrolls: String
  # Ad break length for VOD archive midrolls on this channel.
  vodArchiveMidrollsBreakLength: Int
  # Frequency for VOD archive midrolls on this channel.
  vodArchiveMidrollsFrequency: Int
}

# Defines reminder config for when a reminder will be displayed.
type AdReminderConfig {
  # If channel has reminder enabled for when an ad is about to be displayed.
  isEnabled: Boolean!
  # Specified desired seconds before an ad reminder is displayed.
  seconds: Int!
  # Maximum allowed desired seconds before an ad reminder is displayed.
  maxSeconds: Int!
}

# The context of the Client when the ad request is about to be made.
input AdRequestClientContext {
  # If the client is in audio only mode.
  isAudioOnly: Boolean!
  # If the client is in mini theater mode.
  isMiniTheater: Boolean!
  # If the client is in Picture in Picture mode.
  isPIP: Boolean!
  # If the client is broadcasting to an external device (i.e. Chromecast, Airplay).
  isUsingExternalPlayback: Boolean!
  # App that the client is using.
  clientApp: String
  # Version of the app.
  appVersion: String
}

# The type of content playing when the ad was requested.
enum AdRequestContentType {
  # Live streams.
  LIVE
  # VOD playback.
  VOD
}

# The context of an upcoming ad request.
input AdRequestContext {
  # The ID generated for the ad Session.
  adSessionID: ID!
  # The context of the client at the time the ad is requested.
  clientContext: AdRequestClientContext!
  # The commercial break ID of a channel wide midroll.
  commercialID: ID
  # The duration of the ad break in seconds.
  duration: Int!
  # If the requested ad is a viewer level midroll.
  isVLM: Boolean
  # The context of the player at the time the ad is requested.
  playerContext: AdRequestPlayerContext!
  # The type of ad request being made.
  rollType: AdrollType!
  # The game played on the channel.
  game: String
  # The twitch correlator.
  twitchCorrelator: String
  # Format of the Ad being requested.
  adFormat: String
}

# The context of the Player when the ad request is about to be made.
input AdRequestPlayerContext {
  # The type of content being watched.
  contentType: AdRequestContentType!
  # If the session was initiated by playing automatically.
  isAutoPlay: Boolean!
  # The signature for the access token for the current video session.
  nauthSig: String!
  # The access token for the current video session.
  nauthToken: String!
  # The ID for the current video session.
  videoSessionID: ID
  # PlayerSizeMode of the incoming request.
  playerSizeMode: String
  # RaidId of the incoming request.
  raidID: ID
}

# The type of ad break being requested.
enum AdrollType {
  # Ad that runs prior to seeing a stream/vod.
  PREROLL
  # Ad that runs in the middle of a stream/vod.
  MIDROLL
  # Ad that runs after a stream/vod.
  POSTROLL
}

# Defines time settings and boundaries in seconds for ad schedule.
type AdScheduleConfig {
  # User specified settings in seconds.
  desiredSeconds: Int!
  # Minimum allowed settings in seconds.
  minSeconds: Int!
  # Maximum allowed settings in seconds.
  maxSeconds: Int!
}

# AdSession is the response object from an Ad Request.
type AdSession {
  # id is the id of the ad.
  id: ID!
  # lengthSeconds is the length of the ad being requested in seconds.
  lengthSeconds: Int!
  # retryAfterSeconds is the amount of time in seconds remaining for a user to run another ad.
  retryAfterSeconds: Int!
}

# Defines ads management attributes for channel.
type AdSlot {
  # Duration of Ads that will run.
  durationSeconds: Int!
  # Time when Ad will run.
  runAtTime: Time!
}

# Defines snooze configuration for ad management.
type AdSnoozeConfig {
  # Amount of snoozes the channel currently has.
  currentAmount: Int!
  # Maximum number of snoozes the channel can have at one time.
  maxAmount: Int!
  # Time when channel obtains an additional snooze.
  refreshAt: Time!
  # How long the snooze will push back the ad.
  durationSeconds: Int!
}

# Status of a user's invitation to the Affiliate program.
enum AffiliateInvitationStatus {
  # Invitation cannot be sent, pending a user action.
  INCOMPLETE_WORKFLOW
  # Invitation is scheduled to be sent.
  PENDING_INVITE
  # Invitation has been sent.
  SENT
}

# Grouping of referral sources with name and count -- e.g. ("UK", 1437).
type AggregatedReferrals {
  # Count of the referrals from the named source (1437).
  count: Int!
  # Name of the referral source ("UK").
  name: String!
}

# Error from the mutation.
type AllocateKeysForBountyError {
  # Error code from the mutation.
  code: AllocateKeysForBountyErrorCode!
}

# Possible errors from the mutation.
enum AllocateKeysForBountyErrorCode {
  # The provided input is invalid.
  INVALID_ARGUMENT
  # The bounty or required key metadata was not found.
  NOT_FOUND
  # Unknown error being returned from service.
  UNKNOWN_ERROR
}

# Input required to allocate keys for the bounty.
input AllocateKeysForBountyInput {
  # Unique Identifier for the bounty.
  bountyID: ID!
  # UserID that is allocating keys for the bounty.
  userID: ID!
}

# Payload from the mutation.
type AllocateKeysForBountyPayload {
  # The bounty with allocated keys.
  bounty: Bounty
  # The possible error returned from the service.
  error: AllocateKeysForBountyError
}

input AllowRejectedChatMessageInput {
  id: ID!
}

type AllowRejectedChatMessagePayload {
  message: RejectedChatMessage
}

# Input to the allowRejectedCheer mutation.
input AllowRejectedCheerInput {
  # Client-generated unique ID used to prevent a cheer from being re-sent (thus spending double bits).
  # The server will reject any request with an ID that has already been used.
  id: ID!
  # ID of the user whose message is automodded.
  targetUserID: ID!
}

# Payload from the allowRejectedCheer mutation.
type AllowRejectedCheerPayload {
  # Client-generated unique ID used to prevent a cheer from being re-sent (thus spending double bits).
  # The server will reject any request with an ID that has already been used.
  id: ID!
}

# Units defines how many price units is equivalent to 1 unit of currency.
enum AndroidCurrencyUnits {
  # Default units is ISO-4217 format (e.g. 100 JPY units is 100 JPY, 100 USD units is 1.00 USD).
  NORMAL_UNITS
  # Micro units (1,000,000 micro-units = 1 unit of currency).
  MICRO_UNITS
}

# AndroidPaymentTrackingDataInput contains fields to pass in tracking data.
input AndroidPaymentTrackingDataInput {
  # The user's device ID.
  deviceID: ID
  # The locale of the user.
  locale: String
}

# AndroidReceiptDataInput contains the necessary fields to pass in Android purchase receipt data.
input AndroidReceiptDataInput {
  # The currency the user was charged in.
  currency: String!
  # The amount user was charged.
  price: String!
  # The raw receipt of the purchase.
  rawReceipt: String!
  # The receipt signature for the purchase.
  signedReceipt: String!
  # The unit the user was charged in.
  units: AndroidCurrencyUnits!
}

# The available animated emote generation presets.
enum AnimatedEmotePreset {
  # Shake makes the source image shake.
  SHAKE
  # Roll makes the source image roll across.
  ROLL
  # Spin makes the source image spin around in place.
  SPIN
  # Rave makes the source image change colors.
  RAVE
  # Slide in makes the source image slide in from the left.
  SLIDE_IN
  # Slide out makes the source image slide out to the right.
  SLIDE_OUT
}

# An animated image asset.
type AnimatedImageAsset {
  # Image ID generated by Mako for image.
  id: ID!
  # Size of the image.
  size: EmoteImageSize!
}

# A mapping of extension type to list of activation configs.
input ApplyExtensionActivationsInput {
  # A list of activations to apply to the given channelID.
  activations: [ExtensionActivationInput!]!
  # The ID of the channel the activations are being performed on.
  channelID: ID!
}

# A list of all installed extensions on the channel after an applyExtensionActivations mutation.
type ApplyExtensionActivationsPayload {
  # The list of all installed extensions on the channel after an applyExtensionActivations mutation
  # with their new activation state.
  installedExtensions: [ExtensionInstallation!]!
}

# Required input to approve an unban request on a channel.
input ApproveUnbanRequestInput {
  # ID of the unban request to be resolved.
  id: ID!
  # Optional message from the resolver to be shown to the unban requester.
  resolverMessage: String
}

# Result of approving an unban request.
type ApproveUnbanRequestPayload {
  # Used for errors arising from resolving unban request.
  error: UnbanRequestError
  # The resolved unban request.
  unbanRequest: UnbanRequest
}

# ArchiveChanletInput archives a chanlet by chanlet ID.
input ArchiveChanletInput {
  # The ID of the chanlet being archived.
  chanletID: ID!
}

# ArchiveChanletPayload returns the Chanlet that was archived.
type ArchiveChanletPayload {
  # The chanlet archived.
  chanlet: Channel!
}

# Archive community goal error.
type ArchiveCommunityPointsCommunityGoalError {
  # The error code.
  code: ArchiveCommunityPointsCommunityGoalErrorCode!
}

# Archive community goal error code.
enum ArchiveCommunityPointsCommunityGoalErrorCode {
  # The goal was not found.
  NOT_FOUND
  # The current user is not allowed to archive community goals for this channel.
  FORBIDDEN
  # An unknown error occurred.
  UNKNOWN
}

# Archive community goal input.
input ArchiveCommunityPointsCommunityGoalInput {
  # The channel.
  channelID: ID!
  # The community goal.
  goalID: ID!
}

# Archive community goal payload.
type ArchiveCommunityPointsCommunityGoalPayload {
  # The error, if any.
  error: ArchiveCommunityPointsCommunityGoalError
  # The community goal that was archived.
  goal: CommunityPointsCommunityGoal
}

# Inputs for archiving a poll.
input ArchivePollInChannelInput {
  # The id of the channel that contains the poll to archive.
  channelID: ID!
}

# Outputs from the archive poll mutation.
type ArchivePollInChannelPayload {
  # The archived poll.
  poll: Poll
}

# Inputs for archiving a poll.
input ArchivePollInput {
  # The id of the poll to archive.
  pollID: ID!
}

# Outputs from the create poll mutation.
type ArchivePollPayload {
  # The created poll.
  poll: Poll
}

# Possible errors from the mutation.
enum ArkoseEndpointVersion {
  # Version 1 endpoint.
  V1
  # Version 2 endpoint.
  V2
}

# Error returned after attempting to assign an emote to a bits tier.
type AssignEmoteToBitsTierError {
  # The error code associated with this error.
  code: AssignEmoteToBitsTierErrorCode!
}

# Possible error codes for AssignEmoteToBitsTierError.
enum AssignEmoteToBitsTierErrorCode {
  # The specified emote does not exist.
  EMOTE_NOT_FOUND
  # The user is not allowed to assign this emote.
  PERMISSION_DENIED
  # The bits tier has no available empty emote slots.
  EMOTE_LIMIT_REACHED
  # The emote is not in a valid state to be assigned.
  INVALID_EMOTE_STATE
  # An active or pending emote is already using this emote's code.
  EMOTE_CODE_ALREADY_EXISTS
  # Emotes are not allowed in the specified bits tier.
  EMOTES_NOT_ALLOWED_IN_TIER
  # Unknown error.
  UNKNOWN
}

# The input for assign emote to bits tier.
input AssignEmoteToBitsTierInput {
  # ID of the channel that owns the bits tier.
  channelID: ID!
  # ID of the emote to be assigned.
  emoteID: ID!
  # Threshold of the bits tier to assign the emote to.
  tierThreshold: Int!
}

# Result of assign emote to bits tier.
type AssignEmoteToBitsTierPayload {
  # The updated emote if successful.
  emote: Emote
  # Error returned after attempting to assign an emote to a bits tier.
  error: AssignEmoteToBitsTierError
}

# Error returned after attempting to assign an emote to a subscription product.
type AssignEmoteToSubscriptionProductError {
  # The error code associated with this error.
  code: AssignEmoteToSubscriptionProductErrorCode!
}

# Possible error codes for AssignEmoteToSubscriptionProductError.
enum AssignEmoteToSubscriptionProductErrorCode {
  # The specified emote does not exist.
  EMOTE_NOT_FOUND
  # The user is not allowed to assign this emote.
  PERMISSION_DENIED
  # The product has no available empty emote slots.
  EMOTE_LIMIT_REACHED
  # The emote is not in a valid state to be assigned.
  INVALID_EMOTE_STATE
  # An active or pending emote is already using this emote's code.
  EMOTE_CODE_ALREADY_EXISTS
  # Unknown error.
  UNKNOWN
}

# The input for assign emote to subscription product.
input AssignEmoteToSubscriptionProductInput {
  # ID of the emote to be assigned.
  emoteID: ID!
  # ID of the subscription product to assign the emote to.
  productID: ID!
}

# Result of assign emote to subscription product.
type AssignEmoteToSubscriptionProductPayload {
  # The updated emote if successful.
  emote: Emote
  # Error returned after attempting to assign an emote to a subscription product.
  error: AssignEmoteToSubscriptionProductError
}

# AssignExtensionBillingManagerError is the error associated with AssignExtensionBillingManager.
type AssignExtensionBillingManagerError {
  # The associated error code.
  code: AssignExtensionBillingManagerErrorCode!
}

# Enums for the difference error codes which can be returned.
enum AssignExtensionBillingManagerErrorCode {
  # Extension does not belong to the same organization as the assigned billing manager member.
  FAILED_PRECONDITION
  # The user doesn't meet the requirements to be the assigned billing manager.
  # For example, doesn't have a valid role or did not complete Extension Monetization (TIMs).
  MEMBER_INELIGIBLE
  # User does not have permission to perform action.
  PERMISSION_DENIED
}

# Inputs to the SetExtensionBillingManager mutation.
input AssignExtensionBillingManagerInput {
  # The ID of the extensions.
  extensionID: ID!
  # The twitch ID of the organization member.
  userID: ID!
}

# Payload retuned from the mutation.
type AssignExtensionBillingManagerPayload {
  # The possible error returned from the service.
  error: AssignExtensionBillingManagerError
  # The updated extension.
  extensionClient: ExtensionClient
}

# Information regarding an Amazon Associates store.
type AssociatesStore {
  ID: ID!
  # Whether the owner of this store is enabled to recieve payments.
  isPayoutEnabled: Boolean
  # The store ID tag.
  storeID: String
}

# Authenticated Twitch session.
type AuthenticatedSession {
  # ID of the client the user authenticated from.
  clientID: ID!
  # Creation date of the session.
  createdAt: Time
  # Date of invalidation of the session.
  # Can be null if the session hasn't been deleted.
  deletedAt: Time
  # Geolocation during authentication, determined by IP.
  location: String
  # User agent used during authentication.
  userAgent: String
  # Twitch User ID.
  userID: ID!
}

# A list of configured autohost channels
#
# A relay connection type that does not yet support pagination.
type AutohostChannelConnection {
  # The channels.
  nodes: [User!]
}

# A list of channels that are autohosting the channel
#
# A relay connection type that does not yet support pagination.
type AutohostedByChannelConnection {
  # The channels.
  nodes: [User!]
}

# A user's autohosting settings.
type AutohostSettings {
  # True if this channels prefers autohost over vodcast.
  deprioritizeVodcast: Boolean!
  # True if this channel has the autohost feature turned on.
  enabled: Boolean!
  # Determines what other channels can raid this channel.
  incomingRaidsPolicy: AutohostSettingsIncomingRaidsPolicy!
    @deprecated(reason: "Use User.raidSettings.incomingRaidsPolicy instead.")
  # The strategy to use when choosing channels to autohost.
  strategy: AutohostSettingsStrategy!
  # True if this user autohosts their team members.
  teamHost: Boolean!
}

# DEPRECATED: to be replaced by IncomingRaidsPolicy.
# Determines what other channels can raid this channel.
enum AutohostSettingsIncomingRaidsPolicy {
  # This user cannot be radied by anyone.
  NONE
  # This user can be raided by other people in their network.
  NETWORK
  # This user can be raded by anyone.
  ALL
}

# The strategy to use when choosing channels to autohost.
enum AutohostSettingsStrategy {
  # Picks channels in the order defined by the user.
  ORDERED
  # Picks channels at random.
  RANDOM
}

# An automod fragment type, which is text that is flagged by AutoModeration.
# It contains a list of topics which contain reasons why AutoModeration flagged the text.
type AutoMod {
  # The topics that were flagged by AutoModeration.
  topics: [AutoModTopic!]!
}

# A message rejected by automod.
type AutoModCaughtMessage {
  # Reason why the message was flagged and/or rejected.
  category: AutoModCaughtMessageCategory!
  # id contains the UUID of the AutoModCaughtMessage.
  id: ID!
  # The contents of the message itself, including its content, sender, sentAt timestamp, etc.
  modLogsMessage: ModLogsMessage!
  # Time when a moderator allowed or denied a flagged message.
  resolvedAt: Time
  # The user (mod) who approve/denied the flagged message.
  resolver: User
  # The approval status of the caught message.
  status: AutoModCaughtMessageStatus!
}

# Reason why a message is flagged and/or rejected.
enum AutoModCaughtMessageCategory {
  # Message contained words that were aggressive.
  AGGRESSIVE
  # Message contained identity details.
  IDENTITY
  # Message contained words that were vulgar.
  PROFANITY
  # Message contained words that were sexual.
  SEXUAL
}

# Describes a flagged message's posting status.
enum AutoModCaughtMessageStatus {
  # The message has not received a decision from a mod.
  PENDING
  # Deprecated. The message was approved by a channel moderator or the broadcaster.
  APPROVED
  # The message was allowed to be sent to chat by a channel moderator or the broadcaster.
  ALLOWED
  # The message was denied by a channel moderator or the broadcaster.
  DENIED
  # The message status is invalid (something unexpected).
  INVALID
  # The message expired before being acted upon by a channel moderator or the broadcaster.
  EXPIRED
}

# Defines all AutoMod level settings for a channel, either may be not be set.
type AutoModConfiguration {
  # This field represents the detailed AutoMod category settings.
  detailedLevels: DetailedAutoModConfiguration
  # This field will be a value between 0 and 4, inclusive.
  overallLevel: Int
}

# AutomodContent is the automod response for the text evaulated.
type AutoModContent {
  # failureReasons are pieces of the reasons why the text is inappropriate analyzed by automod.
  failureReasons: [AutoModFailureReason!]
  # text is the original raw string evaluated by automod.
  text: String!
  # canPass is the result whether the text passed automod enforcement.
  canPass: Boolean!
  # id is the ID generated for the test message (used for tracking).
  id: ID!
  # error is the error when querying automod content.
  error: AutoModContentError
}

# Error associated with query AutoModContent.
type AutoModContentError {
  # Error code.
  code: AutoModContentErrorCode!
}

# Client error code.
enum AutoModContentErrorCode {
  # Internal error.
  INTERNAL_ERROR
  # Invalid Argument.
  INVALID_ARGUMENT
  # Resource Exhausted(rate limited).
  RESOURCE_EXHAUSTED
}

# AutoModContentInput is the input of query AutoModContent.
input AutoModContentInput {
  # channel ID is where the text enforcement will be tested.
  channelID: ID!
  # text is the original raw string that needs evaluation by automod.
  text: String!
  # overallLevel is the override overall level that will be passed in (0-4).
  overallLevel: Int
  # autoModSettings is the override automod settings that will be passed in.
  autoModSettings: DetailedAutoModLevelsInput
}

# AutoModFailureReason is the failure reason from AutoMod.
type AutoModFailureReason {
  # normalizedText is the normalized text processed by automod, if you need to get
  # the violation words, use startPosition and endPosition to get the substring from raw text.
  normalizedText: String!
  # startPosition is the start position of the inappropriate substring.
  startPosition: Int!
  # endPosition is the end position of the inappropriate substring.
  endPosition: Int!
  # topics is the topic and its level of the inappropriate substring.
  topics: DetailedAutoModConfiguration!
}

type AutoModProperties {
  # These are integers between 0 and 6, inclusive.
  aggressiveLevel: Int!
  identityLevel: Int!
  profanityLevel: Int!
  sexualLevel: Int!
}

# An auto moderation topic with value.
type AutoModTopic {
  # The topic type, defined by Zuma.
  type: String!
  # The weight assigned to the topic.
  weight: Int!
}

# Contains all auto refill profiles, will have auto refill metadata in the future.
type AutoRefill {
  # Lists actions to execute during an auto refill setup session.
  actions(paymentProvider: PaymentProvider!): [CheckoutAction!]!
  # The list of auto refill profiles.
  profiles: [AutoRefillProfile!]!
  # A list of active xsolla payment methods that a user has available. This field
  # is intended to be replaced by the User.PaymentMethods query.
  xsollaPaymentMethods: [PaymentMethod!]
}

# Auto Refill profile information.
type AutoRefillProfile {
  # The charge instrument information for starting a purchase.
  chargeInstrument: ChargeInstrument
  # Unique ID assigned to this profile.
  id: ID!
  # Indicates if this profile is active.
  isEnabled: Boolean!
  # The offerID that maps to the ability to purchase the intended product.
  offerID: ID
  # The threshold amount a balance must go below to trigger a reload.
  threshold: Int!
}

# The possible computed states for a user or session.
enum Availability {
  AWAY
  BUSY
  IDLE
  OFFLINE
  ONLINE
}

enum AvailabilityInput {
  ONLINE
  IDLE
  OFFLINE
}

# AVC profiles for streams.
enum AVCProfile {
  # Low level.
  BASELINE
  # Regular level.
  MAIN
  # High level.
  HIGH
}

# BackupIngestSession is session metadata related to broadcaster's backup session.
type BackupIngestSession {
  # The session where the current session was stitched from.
  stitchedFrom: [BackupStreamSession!]
  # The session where the current session was stitched to.
  stitchedTo: [BackupStreamSession!]
}

# BackupStreamSession identifies the backup stream session.
type BackupStreamSession {
  # Type of live stream.
  broadcastFormat: BroadcastFormat!
  # The ID of backup session.
  id: ID!
  # Time when the backup stream was stitched as primary session.
  stitchedTimeAt: Time!
}

# Communicates a user's status in chat.
type Badge {
  # Identifies an action to trigger when this badge is clicked.
  clickAction: BadgeClickAction
    @deprecated(reason: "Should use onClickAction instead")
  # The URL to redirect to if the badge's onClickAction is VISIT_URL.
  clickURL: String
  # A localized, human-friendly description of the badge.
  # Defaults to English if no translation exists for the requested locale.
  description: String!
  # The badge's unique identifier.
  id: ID!
  # A URL to the badge's image.
  imageURL(size: BadgeImageSize = NORMAL): String!
  # Identifies an action to trigger when this badge is clicked.
  onClickAction: BadgeClickAction
  # Information about the user's relationship to this badge.
  self: BadgeSelfEdge
  # The identifier of the set which this badge belongs (e.g. "subscriber").
  setID: ID!
  # A localized, human-friendly title for the badge.
  # Defaults to English if no translation exists for the requested locale.
  title: String!
  # The badge's associated broadcaster.
  # Returns null if this is a global badge.
  user: User
  # The badge's version (e.g. "1mo").
  version: String!
}

# Enumerates possible badge click actions.
enum BadgeClickAction {
  # Go to the user's subscription page.
  SUBSCRIBE
  # Go to the Twitch Turbo purchasing page.
  GET_TURBO
  # Go to the Bits purchasing page.
  GET_BITS
  # Redirect the user to the badge click URL.
  VISIT_URL
}

# Deprecated: Domains that badges belong to.
enum BadgeDomain {
  # Badges that were granted via Twitch crates.
  CRATE
}

# Enumerates valid badge image sizes.
enum BadgeImageSize {
  # The base badge image size: 18x18.
  NORMAL
  # Double the normal badge image size: 36x36.
  DOUBLE
  # Quadruple the normal badge image size: 72x72.
  QUADRUPLE
}

# Further details about this object, subject to the user's permissions.
type BadgeSelfEdge {
  # Whether the given badge should be visible publicly in the badge owner's chat card badge carousel.
  isVisibleInChatCard: Boolean!
}

# A filter for controlling which Bits Badge Tier Emotes to return.
enum BadgeTierEmotesFilter {
  # Returns all bits badge tier emotes for this channel.
  ALL
  # Returns all locked bits badge tier emotes for this user in this channel.
  LOCKED
  # Returns a few of the locked bits badge tier emotes for this user in this channel.
  # Which emotes and the exact number are determined by the back-end.
  LOCKED_PREVIEW
  # Returns all unlocked bits badge tier emotes for this user in this channel.
  UNLOCKED
  # Returns highest currently unlocked bits badge tier emote and next to be unlocked by user.
  HIGHEST_UNLOCKED_AND_NEXT
}

# Balance for a Twitch User Account in a FIAT currency. Can be used to purchase
# product on the Twitch Platform.
type Balance {
  # Amount in the smallest unit of subcurrency.
  amount: Int!
  # ISO-4217 currency code of a user's balance.
  currency: Currency!
  # When the credit amount will expire. Can be non-expirable (null).
  expiresAt: Time
  # Number of digits after the decimal separator.
  exponent: Int!
}

type BanUserFromChatRoomError {
  code: BanUserFromChatRoomErrorCode!
  # On DURATION_INVALID, maximum number of seconds a user can be timed out for.
  maxTimeoutDurationSeconds: Int
  # On DURATION_INVALID, minimum number of seconds a user can be timed out for.
  minTimeoutDurationSeconds: Int
}

enum BanUserFromChatRoomErrorCode {
  # User does not have permission to ban in channel.
  FORBIDDEN
  # Target does not exist.
  TARGET_NOT_FOUND
  # User tried to ban themselves.
  TARGET_IS_SELF
  # User tried to ban anonymous user.
  TARGET_IS_ANONYMOUS
  # User tried to ban a moderator without permission.
  TARGET_IS_MOD
  # DEPRECATED: no longer returned.
  TARGET_IS_VIP
  # User tried to ban broadcaster.
  TARGET_IS_BROADCASTER
  # User tried to ban staff.
  TARGET_IS_STAFF
  # User tried to ban admin.
  TARGET_IS_ADMIN
  # User tried to ban global mod.
  TARGET_IS_GLOBAL_MOD
  # User tried to ban already banned user.
  TARGET_ALREADY_BANNED
  # Duration provided was too short or too long.
  DURATION_INVALID
}

input BanUserFromChatRoomInput {
  bannedUserLogin: String!
  channelID: ID!
  # This argument accepts a string specifying a duration.
  # It takes a succession of a number (positive integer) and a time unit, one of:
  # s[econd[s]], m[inute[s]], h[our[s]], d[ay[s]], w[eek[s]], mo[nth[s]].
  # Number/unit pairs can be contiguous or separated by spaces.
  # Valid examples: "3d4h" "11 minutes" "2month", "1s", "12 second"
  # If not provided, target is banned permanently.
  expiresIn: String
  # The reason that the user has been banned or timed out.
  reason: String
}

type BanUserFromChatRoomPayload {
  # The new ban status of this user regarding the specified channel.
  ban: ChatRoomBanStatus
  # Mutation error caused by the user input.
  error: BanUserFromChatRoomError
}

input BanVideoCommenterInput {
  # The id of the channel from where to ban commenter from.
  channelID: ID!
  # The id of the commenter to ban.
  commenterID: ID!
}

type BanVideoCommenterPayload {
  user: User
}

# The required input for an BeginUseBitsInExtension mutation.
input BeginUseBitsInExtensionInput {
  # Channel on which to use the bits.
  channelID: ID!
  # Extension client ID to spend bits in.
  extensionClientID: ID!
  # The SKU of the item being bought.
  sku: String!
}

# The result of a BeginUseBitsInExtension mutation.
type BeginUseBitsInExtensionPayload {
  # The user's balance.
  balance: Int
  # How many bits are required for this.
  bitsRequired: Int
  # Does the front end need to prompt the user.
  isPromptRequired: Boolean
  # The new transaction ID for this spend.
  transactionID: ID
}

# BillingAuthInfo holds data to facilitate the Fraud analysis.
input BillingAuthInfo {
  # Fraud Session ID.
  recurlyFraudSessionID: ID
  # Token generated after completing a 3-D Secure device fingerprinting or
  # authentication challenge.
  threeDSecureActionResultTokenID: ID
}

# BitsAdOffer is an offer to earn bits by watching an ad or interacting with an engagement.
type BitsAdOffer implements BitsOffer {
  # bits is the minimum number of bits received from watching an ad.
  # Some ads may reward more, but this is the number displayed to the user before choosing to watch an ad for bits.
  bits: Int!
  id: ID!
  # type is `BitsOfferType.AD`.
  type: BitsOfferType!
}

# Bits Badges with their associated settings.
type BitsBadgeTier {
  # The badge for this tier.
  badge: Badge
  # Whether the broadcaster can upload emoticons for this tier.
  canUploadEmoticons: Boolean!
  # The emoticon configurations for emoticons that are currently in the process of being uploaded for this tier.
  emoticonUploadConfigurations: [EmoteUploadConfiguration]!
  # The emoticons that are associated with this tier.
  emoticons: [Emote]!
  # Whether the badge is enabled for this threshold.
  isEnabled: Boolean!
  # Time when this badge tier was last updated.
  lastUpdated: Time
  # The amount of bits a user must cheer to achieve this tier.
  threshold: Int!
  # The number of users who have unlocked this badge tier.
  unlockedUsersCount: Int!
}

# BadgeTier Emoticon data to modify.
input BitsBadgeTierEmoticonSetting {
  # The text representation that will allow a user to invoke the emoticon in chat.
  # Usually consists of: a creator's emoticon prefix + a codeSuffix.
  code: String!
  # The creator-defined suffix that differentiates this emoticon from other emoticons in the channel.
  # Usually begins with either a capital letter or a number.
  codeSuffix: String!
  # I'm going to make these new fields nullable and transition them to non-nullable after deprecate the existing flow
  # Image ID for the 28x28 emote asset.
  imageID1x: String
  # Image ID for the 56x56 emote asset.
  imageID2x: String
  # Image ID for the 112x112 emote asset.
  imageID4x: String
}

# BadgeTier metadata to modify.
input BitsBadgeTierInput {
  # Whether to reset the images to the default images.
  deleteImage: Boolean
  # Wether to reset the badge title to the default title.
  deleteTitle: Boolean
  # A list of emoticons to modify.
  emoticonSettings: [BitsBadgeTierEmoticonSetting!]
  # Base64 encoded binary data of the 18x18px badge ("1x") image asset.
  imageData1x: String
  # Base64 encoded binary data of the 36x36px badge ("2x") image asset.
  imageData2x: String
  # Base64 encoded binary data of the 72x72px badge ("4x") image asset.
  imageData4x: String
  # Whether the badge is enabled for this threshold.
  isEnabled: Boolean
  # The threshold to modify.
  threshold: Int!
  # Badge title as string.
  title: String
}

# A notification about achieving a new bits badge tier. Used to send a special message.
type BitsBadgeTierNotification {
  # Whether or not the notification can be shared with chat.
  canShare: Boolean!
  # UUID for notification.
  id: ID!
  # Represents the badge tier threshold reached by the user on a channel (e.g. 100, 1000, etc).
  threshold: Int!
  # The list of bits badge tier emoticons that were obtained as part of achieving this notification's bits badge tier.
  unlockedEmoticons: [Emote]!
}

# Represents the state of the notification.
enum BitsBadgeTierNotificationState {
  # User dismissed the notification.
  SKIPPED
  # User shared the notification with chat.
  SHARED
  # Notification should be shown to user.
  SHOW
}

# BitsBundleOffer is an offer to purchase a number of bits for a certain price.
type BitsBundleOffer implements BitsOffer {
  # amount is the numerical cost of this offer (ex: 20.00).
  amount: Float!
  # asin is the Amazon Standard Identification Number for this offer.
  asin: ID!
  # bits is the number of bits this offer provides.
  bits: Int!
  # Currency code that the price and amount are displayed in (USD, CAD, etc.).
  currencyCode: String!
  # discount is the bulk discount this offer provides compared to the base offer [0.0-1.0).
  discount: Float!
  id: ID!
  # includesVAT is a boolean flag to indicate that the Value Added Tax (VAT)
  # is included in the price of a Bits product. This is important for Bits prices
  # in EU.
  includesVAT: Boolean!
  # isPromo is a flag that signifies if the offer is a promotional offer. This is for clients that
  # need to display promotional offers differently.
  isPromo: Boolean!
  # price is the formatted currency cost of this offer to be displayed to the user.
  price: String!
    @deprecated(
      reason: "Use the 'amount' field and localize it yourself in conjunction with the 'currencyCode' field"
    )
  # promotion contains information about this bits offer if it is a promotional
  # offer. Is null if the offer is not promotional.
  promotion: BitsPromotion
  # type is `BitsOfferType.BUNDLE`.
  type: BitsOfferType!
  # url is the purchase URL to use for this offer.
  # The url contains a `{channelID}
` token which should be replaced by the
  # `User.id` of the channel bits are being purchased from.
  url: String!
}

# BitsChallengeConditionPoolRecipientWeightedShare represents the weighted share of the total bits pool
# that a recipient user is entitled to upon condition satisfaction.
input BitsChallengeConditionPoolRecipientWeightedShare {
  # TUID of the bits recipient.
  recipientUserID: ID!
  # The weight of the recipient's share from the total bits pool. The sum of all the recipients' weights
  # dictates the proportion that a particular recipient receives from the pool
  # (shareWeight/totalShareWeight * totalBitsAmountInPool).
  weight: Int!
}

# An event that captures a single bits transaction.
type BitsEvent {
  # Amount of bits used.
  amount: Int!
  # Channel bits were used on.
  channel: User
  # Event ID.
  id: ID!
  # What type of event the bits were used on.
  type: BitsEventType!
  # Time the bits were used at.
  usedAt: Time!
}

# A paginated list of bits events, and its metadata.
type BitsEventConnection {
  # The list of bits events on this page.
  edges: [BitsEventEdge!]!
  # Information about this page of bits.
  pageInfo: PageInfo!
  # The total number of bits events in the overall collection.
  totalCount: Int!
}

# Filter and sorting options for querying all bits events for a Twitch user.
input BitsEventConnectionCriteriaInput {
  # Sort bits events by... defaults to date.
  sortBy: BitsEventSort = DATE
  # Sort bits events direction, defaults to descending.
  sortDirection: BitsEventSortDirection = DESC
  # Only show bits events of a certain type, defaults to returning all types.
  type: BitsEventType
  # Only show bits events after this date.
  usedAfter: Time
  # Only show bits events before this date.
  usedBefore: Time
}

# An element in a paginated list of bits events, and its metadata.
type BitsEventEdge {
  # Offset acting as a cursor.
  cursor: Cursor!
  # The element node.
  node: BitsEvent!
}

# Possible sort orders for lists of bits events.
enum BitsEventSort {
  # Sort the bits events by amount.
  AMOUNT
  # Sort the bits events by date.
  DATE
}

# Possible sort directions for lists of bits events.
enum BitsEventSortDirection {
  # Sort in descending order.
  DESC
  # Sort in ascending order.
  ASC
}

# Bits event type.
enum BitsEventType {
  # Event for giving bits to broadcaster.
  GIVE_BITS_TO_BROADCASTER
  # Event for using bits on extension.
  USE_BITS_ON_EXTENSION
  # Event for using bits on poll.
  USE_BITS_ON_POLL
  # Unknown event type.
  UNKNOWN
}

# A list of hashtags to use in chat while using bits.
type BitsHashtagConnection {
  # The list of BitsHashtagEdges.
  edges: [BitsHashtagEdge!]
}

# BitsHashtagEdge contains.
type BitsHashtagEdge {
  # The cursor of the record. This will be the BitsHashtagEdge ID.
  cursor: Cursor!
  # The node of the edge contains all information about the hashtag.
  node: BitsHashtagEntry!
}

# BitsHashtagEntry contains information about a hashtag, sucn as the description and image URL for display.
type BitsHashtagEntry {
  # description text.
  description: String
  # The ID, which would be the hashtag value.
  id: ID!
  # An image to display in autocomplete.
  imageURL: String
}

# The Bits Key Code that can be claimed to add bits to a user's account.
type BitsKeyCode implements Claimable {
  # A description of what is claimable for the bits key code.
  description: String!
  # The ID of the bits key code.
  id: ID!
  # The field that gives us claim information for the logged in user.
  self: SelfClaimEdge
  # The type is `ClaimableType.BITS_KEY_CODE`.
  type: ClaimableType!
}

# User edge relating the key's status to the user.
type BitsKeyCodeSelfClaimEdge implements SelfClaimEdge {
  # If the user is eligible to claim the key code.
  canClaim: Boolean!
  # Nullable field for the country where the user redeemed the claimable.
  countryOfResidence: String
  # The user ID that is claiming the code.
  id: ID!
  # Nullable status code for if the user cannot claim the key code.
  statusCode: String
}

# BitsLeaderboard contains the leaderboard for a specified channel.
type BitsLeaderboard {
  # entries is the list of users in the leaderboard ordered by the number of bits cheered.
  entries: BitsLeaderboardConnection!
    @deprecated(
      reason: "the ID field is not unique between leaderboards on leaderboard entries. Use leaderboard item."
    )
  # id is the id of this leaderboard.
  id: ID!
  # items is the list of users in the leaderboard ordered by the number of bits cheered.
  items: BitsLeaderboardItemConnection!
  # SecondsRemaining is the number of seconds left before the leaderboard expires (or zero for all-time).
  secondsRemaining: Int!
}

# Bits leaderboard connection is used to show the various leaderboard entries.
type BitsLeaderboardConnection {
  edges: [BitsLeaderboardEdge]!
}

# BitsLeaderboardEdge describes an edge in a bits leaderboard.
type BitsLeaderboardEdge {
  # The cursor for this leaderboard edge.
  cursor: String!
  # The leaderboard entry at this edge.
  node: BitsLeaderboardEntry
}

# Leaderboard entry at a specific node in a leaderboard connection.
type BitsLeaderboardEntry {
  # id the id of this leaderboard entry.
  id: ID!
  # rank the ordinal rank of this leaderboard entry.
  rank: Int!
  # score the number of bits cheered by this leaderboard entry.
  score: Int!
}

# Leaderboard item at a specific node in a leaderboard connection.
type BitsLeaderboardItem {
  # entryKey the key of this leaderboard item.
  entryKey: String!
  # id the id of this leaderboard item.
  id: ID!
  # rank the ordinal rank of this leaderboard item.
  rank: Int!
  # score the number of bits cheered by this leaderboard entry.
  score: Int!
}

# Bits leaderboard connection is used to show the various leaderboard items.
type BitsLeaderboardItemConnection {
  # edges ...
  edges: [BitsLeaderboardItemEdge]
  # pageInfo ...
  pageInfo: PageInfo!
  # totalCount ...
  totalCount: Int
}

# BitsLeaderboardItemEdge describes an edge in a bits leaderboard.
type BitsLeaderboardItemEdge {
  # The cursor for this leaderboard edge.
  cursor: Cursor!
  # The leaderboard entry at this edge.
  node: BitsLeaderboardItem
}

# BitsLeaderboardSettings are channel-specific settings related to Bits Leaderboards.
type BitsLeaderboardSettings {
  # isEnabled indicates if the Bits leaderboard is pinned in this channel.
  isEnabled: Boolean!
  # timePeriodType indicates whether the leaderboard type is of WEEKLY, ALL-TIME, etc.
  timePeriodType: LeaderboardTimePeriodType
}

# BitsOffer is a way to obtain more bits.
interface BitsOffer {
  # bits is the number of bits this offer grants.
  bits: Int!
  id: ID!
  # type is the kind of offer object.
  type: BitsOfferType!
}

# BitsOfferType is the kind of offer.
enum BitsOfferType {
  # AD is an advertisement or other engagement that can be watched to earn bits.
  AD
  # BUNDLE is a standard package of bits that can be purchased for a price.
  BUNDLE
}

# The type used when checking which payment methods a user can use.
type BitsPaymentMethods {
  # A list of the valid bits payment methods for a user.
  paymentMethods: [BitsPaymentMethodType!]
}

# Enum of payment method types.
enum BitsPaymentMethodType {
  # Paypal.
  PAYPAL
  # Amazon Pay.
  AMAZON_PAY
  # Xsolla.
  XSOLLA
}

# A product for bits that contains all information about a product, except for the pricing.
type BitsProduct {
  # The amount of bits the product is for.
  amount: Int!
  # The product ID.
  id: ID!
  # The maximum quantity a user can purchase at once.
  maxQuantity: Int!
  # The offer id associated with this product's id (if available).
  offerID: ID
  # A field that contains promotional information about the product.
  promo: BitsProductPromotion
  # The relation of the product to the user.
  self: BitsProductSelfEdge
  # The product type, which right now is only "purchase".
  type: BitsProductType!
}

# The type used when checking bits product eligibility for a user.
type BitsProductEligibility {
  # A boolean that is true when the user is eligible for the product.
  canPurchase: Boolean!
  # If the user is ineligible for the product, then this code is set
  # as the reason why the user is ineligible for the product.
  reasonCode: String
}

# Promotional information about bits products.
type BitsProductPromotion {
  # The unique ID of the bits product promo.
  id: ID!
  # The localized title of the promo product.
  title: String!
  # The type of promotion the product is associated with. This type is not enumerable since it is very dynamic.
  type: String!
}

# An enumerable that identifies the checkout provider the customer is using.
enum BitsProductProvider {
  # Amazon checkout.
  AMAZON
  # Android IAP.
  ANDROID
  # iOS IAP.
  IOS
  # Paypal checkout.
  PAYPAL
  # Xsolla checkout.
  XSOLLA
}

# Contains the Bits product's preview price and tax info for a Bits purchase, and error if a preview cannot be created.
type BitsProductPurchaseInfo {
  # Lists any additional actions for a bits checkout session.
  actions: [CheckoutAction!]!
  # The error is present if purchase info failed to be retrieved.
  error: BitsProductPurchaseInfoError
  # Gets the preview price and tax info for the Bits purchase.
  previewPriceInfo: PriceInfo
}

# Error information shown when priceInfo could not be retrieved for Bits Product.
type BitsProductPurchaseInfoError {
  # The descriptive error code.
  code: BitsProductPurchaseInfoErrorCode!
}

# Possible errors when retrieving bits product purchase info.
enum BitsProductPurchaseInfoErrorCode {
  # An unexpected internal server error occurred.
  INTERNAL_SERVER_ERROR
  # The user is unauthorized to view purchase info.
  USER_UNAUTHORIZED
  # The Pricing ID is not found (404).
  PRICING_ID_NOT_FOUND
  # Cannot determine User Residence. Either billing address and IP doesn't match or
  # user doesn't have country of resident declared (409).
  UNKNOWN_USER_RESIDENCE
  # The billing info could not be found for the user and provider (410).
  BILLING_INFO_NOT_FOUND
  # User is not eligible to purchase bits in this region (422).
  PURCHASE_INELIGIBLE
}

# The relation of a Bits product to a user.
type BitsProductSelfEdge {
  # Holds configuration necessary to start bits purchase checkout flow for this product for current user.
  checkoutConfiguration: CheckoutConfiguration
  # Is the user eligible to claim the product at the given quantity.
  eligibility(quantity: Int!): BitsProductEligibility!
  # Gets the preview price and tax info for the Bits purchase, or error if that failed.
  purchaseInfo(
    quantity: Int!
    paymentSession: PaymentSession
  ): BitsProductPurchaseInfo!
}

# An enumerable that identifies bits product types.
enum BitsProductType {
  # A product that has to be purchased.
  PURCHASED_PRODUCT
  # An unknown product type.
  UNKNOWN
}

type BitsPromotion {
  # id indicates the particular promo that this offer is associated with.
  id: ID!
  # PromoType indicates the type of promo that the offer represents i.e First time purchase, single purchase, etc...
  type: String!
}

# Settings tied to a bits user.
type BitsUserSettings {
  # Settings specific to the first cheer tutorial.
  firstCheerTutorial: FirstCheerTutorial
}

# An enumerable that dictates user's Bits usage state.
enum BitsUserState {
  # The user has never used or acquired Bits.
  NEW_USER
  # The user has acquired Bits (purchased, watched ads, etc.) but has never used it.
  ACQUIRED
  # The user has never used or acquired Bits, but clicked "Skip" button to skip the first user experience.
  SKIPPED
  # The user has cheered before.
  CHEERED
  # The user state is unknown.
  UNKNOWN
}

# Information regarding a Blizzard account that is linked to Twitch.
type BlizzardUser {
  # The BattleTag that is stored for the user.
  battleTag: String!
  # The Blizzard ID that is stored for the user.
  id: ID!
  # The region the Blizzard account is from.
  region: String!
}

# Location from where the current user blocked target user.
# NOTE: it is onlyl used from the block_user mutation, this enum should have been
# named BlockUserContext and be placed in the same mutation file.
enum BlockContext {
  WHISPER
  CHAT
}

input BlockUserInput {
  # Reason the user is being blocked.
  reason: String
  # Feature from which the user is being blocked.
  sourceContext: BlockContext
  # ID of user to block.
  targetUserID: ID!
}

type BlockUserPayload {
  # User that was blocked.
  targetUser: User!
}

# A BoostSettings is a set of preferences set by a creator regarding Community Boosts for their channel.
type BoostSettings {
  # If Boosts earned through community challenges are enabled on this channel.
  isEarnedEnabled: Boolean
  # If the channel is eligible to recieve boosts.
  isEligible: Boolean!
  # If Boosts are enabled on this channel.
  isEnabled: Boolean
  # If Boosts paid for by the community are enabled on this channel.
  isPaidEnabled: Boolean
}

# A bounty is a task that a user can complete for a payout.
type Bounty {
  # The campaign that this bounty belongs to.
  campaign: BountyCampaign!
  # The chat Call to Action that will be display during the bounty.
  chatCTA: BountyChatCTA
  # When the bounty was claimed by the user.
  claimTime: Time
    @deprecated(
      reason: "Replacing with 'claimedAt' for consistency with 'At' suffix"
    )
  # When the bounty was claimed by the user.
  claimedAt: Time
  # When the bounty expires.
  endAt: Time
    @deprecated(
      reason: "Replacing with 'expiresAt' as that is a more descriptive property name for the value."
    )
  # When the the user stops tracking.
  endTime: Time
    @deprecated(
      reason: "Replacing with 'trackingStoppedAt' as that is a more descriptive property name for the value."
    )
  # When the bounty expires.
  expiresAt: Time
  # The bounty's unique identifier.
  id: ID!
  # The product keys for the bounty.
  keys: [BountyProductKey!]
  # When the bounty was last modified.
  lastModifiedAt: Time
  # The number of concurrent users (CCU) required to hit the maximum payout for the bounty.
  maximumPayoutCCU: Int
  # The maximum payout for completing this bounty in USD cents.
  maximumPayoutCents: Int!
  # The number of concurrent users (CCU) required to earn a payout for the bounty.
  minimumPayoutCCU: Int
  # The node includes all bounty moderation metadata.
  moderationMetadata: BountyModerationMetadata
  # The moderation status of the bounty.
  moderationStatus: BountyModerationStatus
    @deprecated(reason: "Replacing with 'status' within moderationMetadata.")
  # The actual payout for completing this bounty in USD cents.
  payoutCents: Int
  # The platform on which the user will play the game for this bounty (ie. PC).
  platform: String
  # The region that the broadcaster has selected for this bounty (as defined by BountyCampaignKeyDescriptor).
  region: String
  # Restrictions for this bounty.
  restriction: BountyRestriction
  # When the bounty was claimed by the user.
  startAt: Time
    @deprecated(
      reason: "Replacing with 'claimTime' as that is a more descriptive property name for the value."
    )
  # When the bounty was started by the user.
  startTime: Time
    @deprecated(
      reason: "Replacing with 'trackingStartedAt' as that is a more descriptive property name for the value."
    )
  # The status of the bounty.
  status: BountyStatus!
  # When the user starts tracking the bounty.
  trackingStartedAt: Time
  # When the user stops tracking the bounty.
  trackingStoppedAt: Time
  # The videos for this bounty.
  videos: [BountyVideo!]
}

# Bounty board settings configure how a user can interact with the Bounty Boards feature.
type BountyBoardSettings {
  # This determines whether or not a user has a bounty board notification.
  hasNotification: Boolean!
  # This determines whether the user has the Bounty Boards feature enabled.
  isEnabled: Boolean! @deprecated(reason: "Use 'status' instead.")
  # The user's status on Bounty Board.
  status: BountyBoardUserStatus!
}

# Represents the user's status on Bounty Board.
enum BountyBoardUserStatus {
  # The user has been invited to join the Bounty Board program but cannot participate in bounties yet.
  INVITED
  # The user has been accepted into the Bounty Board program and can participate in bounties.
  ACCEPTED
  # The user has been banned from the Bounty Board program.
  BANNED
  # The user is not part of the Bounty Board program.
  NONE
}

# A campaign defines the requirements and parameters for a set of bounties.
type BountyCampaign {
  # The list of games that if isAllowAllGames is false, the bounty must use.
  allowedGames: [Game!]
  # The platforms on which users can play this campaign's game (ie. PC, PS4, Switch).
  availablePlatforms: [String!]
  # The length of this campaign's bounties (in days).
  bountyLengthDays: Int!
  # Override Box Art URL only for campaign shown on Bounty Board Dashboard, unrelated to game.
  boxArtURL: String
  # Details about the campaign that only the sponsoring brand should see.
  brandDetails: BountyCampaignBrandDetails
  # Override Cover URL only for campaign shown on Bounty Board Dashboard, unrelated to game.
  coverURL: String
  # Details for this campaign.
  details: String!
  # Override Display name only for campaign shown on Bounty Board Dashboard, unrelated to game.
  displayName: String
  # When the campaign expires.
  endAt: Time!
    @deprecated(
      reason: "Replacing with 'endTime' as that is a more descriptive property name for the value."
    )
  # When the campaign expires.
  endTime: Time!
  # The game identifier that is related to this campaign.
  game: Game
    @deprecated(
      reason: "Replacing with 'allowedGames' as this provides a set of available games instead of a single game"
    )
  # The campaign's unique identifier.
  id: ID!
  # If the campaing is a promotional campaign.
  isPromotionEligible: Boolean
  # The information about keys for the campaigns.
  keyDescriptors: [BountyCampaignKeyDescriptor!]
  # Why the campaign was rejected.
  rejectionReason: String
    @deprecated(reason: "Use 'rejectionReason' in 'brandDetails' instead.")
  # If a campaign allows any game to be played.
  shouldAllowAllGames: Boolean
  # The sponsor that is funding this campaign (ie. Amazon Game Studios).
  sponsor: String!
  # When the campaign starts.
  startAt: Time!
    @deprecated(
      reason: "Replacing with 'startTime' as that is a more descriptive property name for the value."
    )
  # When the campaign starts.
  startTime: Time!
  # The status of the campaign.
  status: BountyCampaignStatus
    @deprecated(reason: "Use 'status' in 'brandDetails' instead.")
  # How many seconds a bounty for this campaign must be streamed to complete the bounty.
  streamLengthSeconds: Int
  # The click target of the campaign if it is a promotional campaign.
  targetPromotionalVideoClicks: Int
  # The URL for the terms and conditions page.
  termsAndConditionsURL: String
  # The title of the campaign (ie. Stream Breakaway for 1 hour).
  title: String!
  # The tracking URLs for this campaign.
  trackingPixels: [TrackingPixel!]
  # The type of the campaign (ie. PAY_TO_STREAM).
  type: BountyCampaignType!
  # The URL of the video for this campaign.
  videoURL: String @deprecated(reason: "Use 'videos' instead.")
  # The video URLS for the campaign.
  videos: [BountyCampaignVideo!]
}

# Details about a bounty campaign that only the sponsoring brand should see.
type BountyCampaignBrandDetails {
  # The list of users (if any) blacklisted for the campaign.
  # Limited to 40 users - use totalBlockedBroadcasters for the total count.
  blacklistedBroadcasters: [User!]
  # The multiplier for the broadcaster payout rate.
  broadcasterMultiplier: Float
  # Reporting data for the campaign.
  campaignReporting: BountyCampaignReporting
  # The chat Calls to Action for the campaign.
  chatCTAs: [BountyChatCTA!]
  # The total number of broadcasters who have claimed the bounty.
  claimedBountyCount: Int
    @deprecated(
      reason: "Use 'claimedBountyCount' in 'campaignReporting' instead."
    )
  # How much of the budget has been claimed (in cents).
  claimedBudgetCents: Int
    @deprecated(
      reason: "Use 'claimedBudgetCents' in 'campaignReporting' instead."
    )
  # The total number of broadcasters who have completed the bounty.
  completedBountyCount: Int
    @deprecated(
      reason: "Use 'completedBountyCount' in 'campaignReporting' instead."
    )
  # The total number of broadcasters who have expanded the bounty.
  expandedBountyCount: Int
    @deprecated(
      reason: "Use 'expandedBountyCount' in 'campaignReporting' instead."
    )
  # If all broadcasters are targeted for the campaign.
  includesAllBroadcasters: Boolean
  # If all countries are targeted for the campaign.
  includesAllCountries: Boolean!
  # If all games are targeted for the campaign.
  includesAllGames: Boolean!
  # If variety broadcasters are targeted for the campaign.
  includesVarietyBroadcasters: Boolean!
  # Detailed performance metrics for this campaign.
  performanceMetrics: [BountyCampaignPerformanceMetric!]
    @deprecated(
      reason: "Use 'performanceMetrics' in 'campaignReporting' instead."
    )
  # Why the campaign was rejected.
  rejectionReason: String
  # How much of the budget has been spent (completed bounties) (in cents).
  spentBudgetCents: Int
  # The status of the campaign.
  status: BountyCampaignStatus
  # Targeted countries for the campaign (represented by ISO 3166-1 alpha-2).
  targetedCountries: [String!]
  # Targeted Games for the campaign.
  targetedGames: [Game!]
  # The total length of the blacklistedBroadcasters list.
  totalBlockedBroadcasters: Int
  # The total budget for the campaign (in cents).
  totalBudgetCents: Int
  # The number of broadcasters who have viewed the bounty.
  viewedBountyCount: Int
    @deprecated(
      reason: "Use 'viewedBountyCount' in 'campaignReporting' instead."
    )
}

# The chat Call to Action (CTA) that will be created as part of this campaign.
input BountyCampaignChatCTAInput {
  # The country that the chat CTA is targeted for (represented by ISO 3166-1 alpha-2).
  countryCode: String!
  # The title for the chat CTA.
  title: String!
  # The URL for the chat CTA.
  url: String!
}

# A list of bounty campaigns related to the subject.
type BountyCampaignConnection {
  # The campaigns.
  edges: [BountyCampaignEdge]
  # Information about pagination in this connection.
  pageInfo: PageInfo!
}

# Information about the relationship to the bounty campaign and the subject.
# Also includes the campaign itself.
type BountyCampaignEdge {
  # Uniquely identifies this campaign's position in a connection.
  cursor: Cursor!
  # The campaign.
  node: BountyCampaign
}

# A descriptor for a product key.
type BountyCampaignKeyDescriptor {
  # The platform for the key.
  platform: String!
  # The region for the key.
  region: String!
}

# Metric containing details about how a campaign performed over a time period.
type BountyCampaignPerformanceMetric {
  # The number of click-throughs from the Chat CTAs of the campaign.
  chatCTAClickThroughCount: Int
  # The total number of bounties that were completed.
  completedBountyCount: Int!
  # The end time of this metric.
  endTime: Time!
  # The total number of minutes watched.
  minutesWatched: Int!
  # The start time of this metric.
  startTime: Time!
  # The number of viewers that watched at least thirty seconds of the campaign's content.
  thirtySecondViewerCount: Int!
  # The total number of viewers that watched the campaign's content.
  totalViewerCount: Int!
  # The number of viewers that watched at least two minutes of the campaign's content.
  twoMinuteViewerCount: Int!
}

# Details about a bounty campaign reporting that only the sponsoring brand should see.
type BountyCampaignReporting {
  # The total number of clicks from chat CTAs from every bounty.
  chatCTAsClicks: Int
  # The total number of impressions from chat CTAs from every bounty.
  chatCTAsImpressions: Int
  # The total number of broadcasters who have claimed the bounty.
  claimedBountyCount: Int
  # How much of the budget has been claimed (live bounties) (in cents).
  claimedBudgetCents: Int
  # The total number of broadcasters who have completed the bounty.
  completedBountyCount: Int
  # The total number of broadcasters who have expanded the bounty.
  expandedBountyCount: Int
  # Detailed performance metrics for this campaign.
  performanceMetrics: [BountyCampaignPerformanceMetric!]
  # How much of the budget has been spent (completed bounties) (in cents).
  spentBudgetCents: Int
  # The number of broadcasters who have viewed the bounty.
  viewedBountyCount: Int
}

# The status of a bounty campaign.
enum BountyCampaignStatus {
  # The campaign is pending approval.
  PENDING
  # The campaign has been approved.
  APPROVED
  # The campaign has been rejected.
  REJECTED
  # The campaign is live.
  LIVE
  # The campaign is done.
  COMPLETED
}

# Represents the type of the campaign.
enum BountyCampaignType {
  # A user is paid to stream themselves playing a game.
  PAY_TO_STREAM
  # A user is paid to stream a game trailer.
  GAME_TRAILER
  # A user is paid to stream a non-game trailer (ie. a movie trailer).
  MISC_TRAILER
  # Invalid campaign type.
  UNKNOWN
}

# Possible upload types for bounty campaigns.
enum BountyCampaignUploadType {
  # Upload type related to the box art image.
  BOX_ART
  # Upload type related to the cover image.
  COVER
}

# A video for a bounty board campaign.
type BountyCampaignVideo {
  # The country that the video is targeted for (represented by ISO 3166-1 alpha-2).
  country: String!
  # The title of the video.
  title: String!
  # The URL of the video.
  url: String!
}

# The video that will be created as part of this campaign.
input BountyCampaignVideoInput {
  # The country that the video is targeted for (represented by ISO 3166-1 alpha-2).
  country: String!
  # The title of the video.
  title: String!
  # The URL of the video.
  url: String!
}

# A chat Call to Action (CTA) that will be trigger in the broadcaster chat while doing the bounty.
type BountyChatCTA {
  # The country targeted for the chat CTA (represented by ISO 3166-1 alpha-2).
  countryCode: String!
  # The time (in seconds) between each appearance of the chat CTA.
  frequencySeconds: Int!
  # The initial delay (in seconds) before the first chat CTA.
  initialDelaySeconds: Int!
  # The title of the chat CTA.
  title: String!
  # The URL of the chat CTA.
  url: String!
}

# A list of bounty related to the subject.
type BountyConnection {
  # The bounties.
  edges: [BountyEdge!]
  # Information about pagination in this connection.
  pageInfo: PageInfo!
}

# Information about the relationship to the bounty and the subject.
# Also includes the bounty itself.
type BountyEdge {
  # Uniquely identifies this bounty's position in a connection.
  cursor: Cursor!
  # The bounty.
  node: Bounty
}

# Represents all the currently possible key product types.
enum BountyKeyProductType {
  # The key is a coupon code.
  COUPON
  # The key is for downloadable content or a game expansion.
  DLC
  # The key is a game code.
  GAME
  # The key is for a gift card.
  GIFTCARD
  # The key is a code for a giveaway.
  GIVEAWAY
  # The key is for in game content - character skins, customization, etc.
  IGC
  # The key is for something else.
  OTHER
}

# The reason why bounty failed moderation.
enum BountyModerationFailReason {
  # Moderation failed because broadcast does not meet minimal stream length requirement.
  MINIMUM_TIME_NOT_MET
  # Moderation failed because broadcast is not with required content.
  INCORRECT_CONTENT
  # Moderation failed because broadcaster did badmouthing during stream.
  BADMOUTHING
  # Moderation failed because other content layered over/under required content.
  OTHER_CONTENT_VISIBLE
  # Moderation failed because broadcaster had exessive idle time during sponsored stream.
  IDLE
  # Moderation failed because missing sponsored stream VOD.
  NO_VOD
  # Other reason caused moderation failed.
  OTHER
}

# Bounty Moderation metadata includes moderation metadata for a specific bounty.
type BountyModerationMetadata {
  # The moderation fail reason of the bounty.
  reason: BountyModerationFailReason
  # The moderation status of the bounty.
  status: BountyModerationStatus
  # When the bounty was last moderated.
  updatedAt: Time
}

# The moderation status of the bounty.
enum BountyModerationStatus {
  # The bounty has passed the moderation check.
  PASS
  # The bounty is waiting for moderation check.
  PENDING_REVIEW
  # The bounty has failed the moderation check.
  FAIL
}

# A key that can be redeemed for a product.
type BountyProductKey {
  # The code that is used to redeem the product.
  code: String!
  # The platform where the code is redeemed.
  platform: String
  # The product type of the key - GAME, DLC, GIVEAWAY, GIFTCARD, etc.
  productType: BountyKeyProductType
  # The region where the code can be redeemed. The format and granularity of this field varies
  # depending on the product key vendor.
  region: String
}

# Defines the restrictions that are placed on a bounty.
type BountyRestriction {
  # The days of the week that a bounty can be completed on. The values are from 0
  # to 6, representing day of the week from Monday to Sunday.
  days: [Int!]
  # The end of the time period that a bounty can be completed in. This is in 24-hour clock notation, so 2100 means 9 PM UTC.
  endTime: Int
  # The start of the time period that a bounty can be completed in. This is in
  # 24-hour clock notation, so 1000 means 10 AM UTC.
  startTime: Int
}

# Represents all the possible bounty statuses.
enum BountyStatus {
  # The bounty can be claimed by the user.
  AVAILABLE
  # The bounty has been claimed by the user and is in progress.
  LIVE
  # The bounty was completed successfully.
  COMPLETED
  # The bounty was cancelled before it was completed.
  CANCELLED
}

# A video that the broadcaster must play on stream to complete the bounty.
type BountyVideo {
  # The title of the video.
  title: String!
  # The URL of the video.
  url: String!
}

# Brand portal settings configure how a company can interact with the brand portal.
type BrandPortalSettings {
  # This determines whether or not a company can access all games in brand portal.
  canAccessAllGames: Boolean!
  # This determines whether or not a company can access the Brand Portal.
  isEnabled: Boolean!
}

# A historical representation of a live stream.
type Broadcast {
  # The game which was last streamed during the broadcast.
  game: Game
  # The broadcast's unique identifier.
  id: ID
  # When the broadcast started.
  startedAt: Time
  # The title of the broadcast.
  title: String
}

# An indicator of the viewer reach for a pool of a broadcasters.
type BroadcasterViewerReach {
  # Range of the number of broadcasters in the pool.
  broadcasterPool: Range!
  # Range of minutes watched for this bounty campaign.
  minutesWatched: Range!
  # Range of total viewers across the broadcaster pool.
  viewerPool: Range!
}

# BroadcastFormat is type of ingest live sessions.
enum BroadcastFormat {
  # Default live stream. Primary session for the backup session will be shown as live.
  LIVE
  # Stream with intentional delays requested by the broadcaster.
  DELAY
  # Primary session which backup session was stitched back to.
  BACKUP_000
  # First backup session.
  BACKUP_001
  # Second backup session.
  BACKUP_002
  # Third backup session.
  BACKUP_003
}

# Settings for a User's broadcast that persist between streams.
type BroadcastSettings {
  # The game that the user has set as their current game. This will influence what
  # the game field on a Streams object is when the User starts streaming.
  game: Game
  # The broadcast setting's unique identifier.
  # This happens to be the same as the User's ID, but should not be assumed to have any meaning.
  id: ID!
  # A flag indicating if the user's broadcast is intended for mature audiences only.
  isMature: Boolean!
  # The primary language that the user has configured for their broadcasts. The
  # default value is "", when the user has not indicated a primary language.
  language: Language!
  # The text that will be in the notification that sends when the user starts broadcasting.
  # The default value is "<user> went live!", when the user has not set a custom value.
  liveUpNotification: String
    @deprecated(reason: "Use liveUpNotificationInfo instead.")
  # The information about the live up notification of a user.
  liveUpNotificationInfo: LiveUpNotificationInfo
  # The title of the user's broadcast. The default value is "", when the user has not indicated a title.
  title: String!
}

# Describes from which source the video originated.
# NOTE: Should have been named VideoBroadcastType.
enum BroadcastType {
  # If the video is of a past broadcast, it's an ARCHIVE.
  ARCHIVE
  # When the video is a subsection of a past broadcast, it's a HIGHLIGHT.
  HIGHLIGHT
  # (Legacy) When the video is directly uploaded to Twitch via the upload tool, it's an UPLOAD.
  UPLOAD
  # When the video is directly uploaded to Twitch via the video manager, it's an PREMIERE_UPLOAD.
  PREMIERE_UPLOAD
  # When a video has been premiered on Twitch and is saved, it's a PAST_PREMIERE.
  PAST_PREMIERE
}

# Associated metrics for the "Build a Community" quest.
type BuildACommunity {
  # Image URL for the quest's badge.
  badgeURL: String
  # Time that this quest was completed.
  completedAt: Time
  # Number of followers needed to complete the quest.
  followers: QuestGoalInt
  # Number of Unique Chatters needed to complete the quest.
  uniqueChatters: QuestGoalInt
}

# Required input to bulk approve a list of unban requests on a channel.
input BulkApproveUnbanRequestInput {
  # IDs of the unban requests to be approved.
  ids: [ID!]!
}

# Result of bulk approving unban requests.
type BulkApproveUnbanRequestPayload {
  # Used for errors arising from bulk approving unban requests.
  error: UnbanRequestError
  # The approved unban requests.
  unbanRequests: [UnbanRequest!]
}

# Required input to deny a list of unban requests on a channel.
input BulkDenyUnbanRequestInput {
  # IDs of the unban requests to be denied.
  ids: [ID!]!
}

# Result of bulk denying unban requests.
type BulkDenyUnbanRequestPayload {
  # Used for errors arising from bulk denying unban requests.
  error: UnbanRequestError
  # The denied unban requests.
  unbanRequests: [UnbanRequest!]
}

# A visible campaign on a given user's channel.
type Campaign {
  # The domain that campaign belongs to.
  domain: String!
  # The time the campaign ends being active.
  endDate: Time!
  # Unique identifier for the campaign.
  id: ID!
  # The objectives users can progress in within this campaign.
  objectives: [CampaignObjective!]!
  # The time the campaign becomes active.
  startDate: Time!
}

# This type holds the information about the grouping of objectives. Each group has
# a list of cheermotes that progress objectives in this particular group.
type CampaignCheergroup {
  # A list of upper cased cheermotes that can advance objectives belonging to this group.
  cheerCodes: [String!]!
  # An a parent group this cheer group belongs to (e.g. "North America").
  division: String
  # A url to the image representing this group (e.g. team icon in esports context).
  imageUrl: String!
  # A name representing this group (e.g. team name in esports context).
  name: String!
}

# CampaignDiscoveryEventType contains the different types of discovery events that campaign objectives can track.
enum CampaignDiscoveryEventType {
  # An event describing a user's interaction with the command center.
  ENGAGE_COMMAND_CENTER
  # An event describing a user's interaction with a stream.
  ENGAGE_STREAM
}

# This type holds information about a campaign objective, which belongs to a campaign.
# An objective can hold multiple milestones which users can hit and get rewards.
# An objective can hold a cheer group.
type CampaignObjective {
  # Cheergroup this objective might belong to.
  cheergroup: CampaignCheergroup
  # Short description about the objective.
  description: String!
  # Unique identifier for the objective.
  id: ID!
  # If the objective belongs to an active parent campaign.
  isActive: Boolean!
  # Milestones users can hit by advancing this objective.
  milestones: [Milestone!]
  # User's participation towards the objective.
  participation: Int!
  # Global progress for the objective.
  progress: Int!
  # The type of objective this is for. It can be either INDIVIDUAL or GLOBAL (TEAM is deprecated).
  tag: String!
  # Short title for the objective.
  title: String!
}

# All Campaign properties that are running for a given user.
type CampaignProperties {
  # All the current active campaigns for a given user.
  activeCampaigns: [String!]
  # All the current domains a user is participating in.
  domains: [String!]
  # Determines whether or not a user has a pass they can sell on their channel.
  hasPass: Boolean!
  # Objectives users can progress within all the active campaigns for the first domain.
  objectives: [CampaignObjective!]
  # Triggers users can activate to get / give rewards within this campaign.
  triggers: [CampaignTrigger!]
}

# Metadata for the reward that only impacts how the rewards are rendered on the front end apps.
type CampaignRewardMetadata {
  # Whether the reward is initially unavailable upon redeeming.
  isPending: Boolean! @deprecated
  # Reward subtype usually specific to the game the campaign belongs to (e.g. skin, spray, etc).
  subType: String @deprecated
}

# This type holds information about a campaign trigger, which belongs to a campaign.
# A trigger has a list of rewards that can be earned by various one time events.
type CampaignTrigger {
  # Short description about the trigger.
  description: String!
  # Unique identifier for the trigger.
  id: ID!
  # Whether the trigger is currently active.
  isActive: Boolean!
  # List of rewards attached to this trigger.
  rewards: [TournamentReward!]
  # Short title for the trigger.
  title: String!
  # Maximum amount of trigger quantity required for the trigger (e.g. # of bits in cheer).
  triggerAmountMax: Int!
  # Minimum amount of trigger quantity required for the trigger (e.g. # of bits in cheer).
  triggerAmountMin: Int!
  # String defining the trigger type (e.g. CHEER).
  triggerType: TriggerType!
}

# The type of the campaign.
enum CampaignType {
  # The default campaign type that allows all drop types but manual_triggers.
  DEFAULT
  # The manual trigger campaign type only allows for manual trigger type drops.
  MANUAL_TRIGGER_BASED
}

# Error code for an error that occurs while canceling the active boosts.
type CancelActiveBoostOrdersError {
  # Error code for error that occurred while canceling the active boosts.
  code: CancelActiveBoostOrdersErrorCode!
}

# Error types recognized.
enum CancelActiveBoostOrdersErrorCode {
  # Invalid parameter in the request.
  INVALID_PARAMETER
  # Internal error being returned from service.
  INTERNAL_ERROR
}

# The required input for a cancelActiveBoostOrdersInput mutation.
input CancelActiveBoostOrdersInput {
  # The Id of the channel for which we want to cancel boosts.
  channelID: ID!
}

# Data that was mutated after canceling the active boosts.
type CancelActiveBoostOrdersPayload {
  # The possible error returned from the service.
  error: CancelActiveBoostOrdersError
}

# Error code for an error that occurs while canceling the bounty.
type CancelBountyError {
  # Error code for error that occurred while canceling the bounty.
  code: CancelBountyErrorCode!
}

# Error types recognized.
enum CancelBountyErrorCode {
  # Invalid parameter in the request.
  INVALID_PARAMETER
  # Bounty isn't live, thus cannot be canceled.
  BOUNTY_NOT_LIVE
  # Unknown error being returned from service.
  UNKNOWN_ERROR
}

# CancelBountyInput includes the bounty a user is trying to cancel.
input CancelBountyInput {
  # Unique Identifier for the bounty.
  bountyID: ID!
  # Reason that the user canceled the bounty.
  reason: String
  # UserID of the user that will cancel the bounty.
  userID: ID!
}

# Data that was mutated after canceling the bounty.
type CancelBountyPayload {
  # The canceled bounty with the updated status.
  bounty: Bounty
  # The possible error returned from the service.
  error: CancelBountyError
  # The user that now has the canceled bounty.
  user: User
}

input CancelFriendRequestInput {
  # The authenticated user will cancel the friend request sent to the user with an ID equal to targetID.
  targetID: ID!
}

type CancelFriendRequestPayload {
  # The user whose friend request was just cancelled.
  user: User
}

# Describes the conditions around a user's cancellation of their purchase (e.g. refund policy).
enum CancellationPolicyType {
  # The product is not refundable.
  NON_REFUNDABLE
  # The product is refundable.
  REFUNDABLE
}

# CancelPayoutOnboardingWorkflowInput returns the required input when starting a new workflow for payout onboarding.
input CancelPayoutOnboardingWorkflowInput {
  # TargetUserID is the ID of the user whose workflow will be started.
  targetUserID: ID!
}

# CancelPayoutOnboardingWorkflowPayload is the payload returned after canceling a payout onboarding workflow.
type CancelPayoutOnboardingWorkflowPayload {
  # A new workflow status.
  workflow: PayoutOnboardingWorkflow
}

# An error returned from the cancelPredictionEvent mutation.
type CancelPredictionEventError {
  # Code describing the error.
  code: CancelPredictionEventErrorCode!
}

# Possible error codes from the cancelPredictionEvent mutation.
enum CancelPredictionEventErrorCode {
  # The current user is forbidden from cancelling this Prediction Event.
  FORBIDDEN
  # This Prediction Event has already either been resolved or canceled, and as such this action cannot be taken.
  EVENT_ENDED
  # An unknown error occurred.
  UNKNOWN
}

# Input for canceling a Prediction Event (and refunding all users who have contributed).
input CancelPredictionEventInput {
  # The unique identifier of the Prediction Event to cancel.
  id: ID!
}

# Payload for canceling a Prediction Evnet.
type CancelPredictionEventPayload {
  # If present, there was an error with the request.
  error: CancelPredictionEventError
  # The canceled Prediction Event.
  predictionEvent: PredictionEvent
}

# CancelRaidError is the error associated with a cancelRaid.
type CancelRaidError {
  # The associated error code.
  code: CancelRaidErrorCode!
}

# CancelRaidErrorCode are the possible errors that this mutation returns.
enum CancelRaidErrorCode {
  # The a raid does not exist.
  RAID_DOES_NOT_EXIST
  # The request is missing valid channel parameters.
  INVALID_CHANNEL
  # The user tries to unraid without an active raid.
  NO_ACTIVE_RAID
}

# Inputs to the cancelRaid mutation.
input CancelRaidInput {
  # Source ID.
  sourceID: ID!
}

# Outputs from the cancelRaid mutation.
type CancelRaidPayload {
  # The possible error returned from the service.
  error: CancelRaidError
  # The cancelled raid.
  raid: Raid
}

# Inputs for the mutation. Gift to be canceled by productID and originID.
input CancelSubscriptionGiftInput {
  # originID is the origin id created during the gift purchase.
  originID: ID!
  # productID is the ticket product id for this gift.
  productID: ID!
}

# The returned payload from the mutation for canceling a Subscription Gift.
type CancelSubscriptionGiftPayload {
  # SubscriptionGift object that was deleted.
  gift: SubscriptionGift
}

# Required input to cancel an unban request.
input CancelUnbanRequestInput {
  # ID of the unban request to be canceled.
  id: ID!
}

# Result of canceling an unban request.
type CancelUnbanRequestPayload {
  # Used for errors arising from canceling the unban request.
  error: UnbanRequestError
  # The canceled unban request.
  unbanRequest: UnbanRequest
}

# The status of a chat message.
enum CaughtMessageStatus {
  # INVALID status.
  INVALID
  # The caught message is approved by a mod.
  ALLOWED
  # The caught message is denied by a mod.
  DENIED
  # The caught message is pending for a while and now it's expired.
  EXPIRED
  # The caught message is pending review.
  PENDING
}

# CCPA cookie vendor for a user.
type CCPACookieVendor {
  # User content status for each vendor.
  consentStatus: ConsentStatus!
  # A flag that shows if the consent is given by the user or by consent service as default value.
  hasUserSetConsent: Boolean!
  # A flag that shows if the vendor should be visible to management page.
  isVisible: Boolean!
  # Vendor name.
  name: VendorName!
}

# List of CCPA cookie vendors.
type CCPAVendorConsent {
  # status for vendors.
  status: [CCPACookieVendor!]!
}

# Celebration is a configuration that denotes when a celebration is triggerd and
# when sort of celebration will show when it triggers.
type Celebration {
  # Area of the channel page in which the celebration will appear.
  area: CelebrationArea!
  # Duration which the celebration will play.
  durationMilliseconds: Int!
  # Effect which will be shown when then celebration is triggered.
  effect: CelebrationEffect!
  # Amount that needs to be met in order to trigger this celebration.
  # For example, when the event type is subscription gift, this value will
  # determine how many gifts must be given at a single time to trigger the
  # celebration.
  eventThreshold: Int!
  # Type of event which will trigger this celebration.
  eventType: CelebrationEventType!
  # Unique identifier for the celebration.
  id: ID!
  # Intensity of the celebration.
  # Should be bounded (TBA) value which will determine the spectacle of the celebration.
  intensity: Int!
  # If true, the celebration is enabled.
  isEnabled: Boolean!
}

# Area in which the celebration will show.
enum CelebrationArea {
  # Celebration will show everywhere over the channel page.
  EVERYWHERE
  # Celebration will show only over the video.
  VIDEO_ONLY
  # Celebration will show over the video and panel.
  VIDEO_AND_PANEL
  # Unknown celebration area.
  UNKNOWN
}

# The channels configuration of celebrations.
type CelebrationConfig {
  # List of celebrations for this channel.
  celebrations: [Celebration!]!
  # The identifier for the celebration config.
  id: ID!
  # If celebrations are enabled on this channel.
  isEnabled: Boolean!
}

# Type of effect that can show during a celebration.
enum CelebrationEffect {
  # Will show fireworks when the celebration triggers.
  FIREWORKS
  # Will show an emote rain when the celebration triggers.
  RAIN
  # Will show an flamethrowers when the celebration triggers.
  FLAMETHROWERS
  # Unknown effect.
  UNKNOWN
}

# Celebration error.
type CelebrationError {
  # Code describing the error.
  code: CelebrationErrorCode!
}

# Vote in celebration error code.
enum CelebrationErrorCode {
  # Attempted to preform operation on celebration that does not exist.
  CELEBRATION_NOT_FOUND
  # A celebration with that same event type and threshold already exists.
  CELEBRATION_ALREADY_EXISTS
  # Requesting user does not have permission.
  PERMISSION_DENIED
  # The user has reached the limit (20) of celebrations they can have.
  OVER_CELEBRATION_LIMIT
  # An unknown error occurred.
  UNKNOWN
}

# Type of event that can trigger a celebration.
enum CelebrationEventType {
  # Cheering with bits.
  BITS_CHEER
  # Gifting subscriptions to other users.
  SUBSCRIPTION_GIFT
  # Unknown event type.
  UNKNOWN
}

# Type of intensity of a celebration.
enum CelebrationIntensity {
  # A small intensity celebration.
  SMALL
  # A medium intensity celebration.
  MEDIUM
  # A large intensity celebration.
  LARGE
  # Unknown intensity.
  UNKNOWN
}

# A celebration product that a user may purchase.
type CelebrationProduct implements ProductCatalogItem {
  # A list of benefits the user will receive when purchasing the celebration product.
  benefits: [ProductCatalogBenefit!]
  # A description of the product.
  description: String
  # The identifier of the celebration product.
  id: ID!
  # The intensity of the celebration product.
  intensity: CelebrationIntensity!
  # Indicates if the celebration product is enabled for purchase in the channel.
  isEnabled: Boolean!
  # A list of offers available for purchasing this celbration product.
  offers: [Offer!]
  # The owner (ex: channel) of the celebration product.
  owner: ID!
  # A list of potential offers that a broadcaster could set for purchasing this celebration product.
  potentialOffers: [Offer!]
  # The title of the product.
  title: String!
}

# A celebration product benefit the user will receive when purchasing the celebration product.
type CelebrationProductBenefit implements ProductCatalogBenefit {
  # The identifier of the celebration product benefit.
  id: ID!
}

# Configuration settings to change for a celebration product.
input CelebrationProductConfigInput {
  # The intensity of the celebration product.
  intensity: CelebrationIntensity!
  # If the celebration product is enabled for purchase in the channel.
  isEnabled: Boolean
  # ID of the offer (i.e. price) through which the celebration can be purchased in the channel.
  offerID: ID
}

# A container for celebration settings for the logged in user.
type CelebrationUserSettings {
  # A boolean flag that denotes if the user has opted out of seeing celebrations.
  isOptedOut: Boolean!
}

# A condition to be satisfied by a specific owner.
type ChallengeCondition {
  # When the condition was created.
  createdAt: Time
  # Settings that define how the effects of the condition participants associated with this condition will be processed.
  effectSettings: [ChallengeEffectSettings!]
  # Unique ID of the condition.
  id: ID!
  # The name of the condition.
  name: String!
  # The user who creates and owns the condition.
  owner: User
  # A summary of condition participants attached to the condition.
  participantSummary: ChallengeConditionParticipantSummaryByState
  # The current state of the condition.
  state: ChallengeConditionState!
  # The list of effect types supported by this condition.
  supportedEffects: [ChallengeEffectType!]!
  # When the condition times out.
  timeoutAt: Time
  # When the condition was last modified.
  updatedAt: Time
  # Whether the condition becomes inactive once it has been satisfied.
  willDisableWhenSatisfied: Boolean!
}

# A condition participant action that will be taken if an associated condition is satisfied.
type ChallengeConditionParticipant {
  # The associated condition.
  condition: ChallengeCondition
  # The effect that will occur if the condition participant is satisfied.
  effect: ChallengeEffect!
  # Final state of the condition participant.
  endState: ChallengeConditionParticipantEndState!
  # Unique ID of the condition participant.
  id: ID!
  # The user who creates and owns the condition participant.
  owner: User
  # Whether or not the condition participant was successfully processed upon condition completion.
  processingState: ChallengeConditionParticipantProcessingState!
}

# Final state of the condition participant.
enum ChallengeConditionParticipantEndState {
  # Pending completion of associated condition.
  PENDING
  # Associated condition expired.
  CONDITION_EXPIRED
  # Associated condition was canceled.
  CONDITION_CANCELED
  # Associated condition was satisfied.
  CONDITION_SATISFIED
  # Condition participant expired before associated condition could be satisfied.
  EXPIRED
  # Condition participant was canceled.
  CANCELED
  # Condition participant failed validation prior to being processed.
  FAILED_VALIDATION
  # Unknown state.
  UNKNOWN
}

# Whether or not the condition participant was successfully processed upon condition completion.
enum ChallengeConditionParticipantProcessingState {
  # Pending completion of associated condition.
  PENDING
  # Condition participant processed successfully.
  SUCCESS
  # Error processing condition participant.
  ERROR
  # Unknown state.
  UNKNOWN
}

# A summary of participants attached to a particular condition in a particular state.
type ChallengeConditionParticipantSummary {
  # Summary of participant effects attached to a particular condition in a particular state.
  effects: ChallengeEffectSummary
  # Total count of participants attached to a particular condition in a particular state.
  total: Int!
}

# A summary of condition participants attached to a particular condition, grouped by state.
type ChallengeConditionParticipantSummaryByState {
  # Summary of participants attached to a particular condition in the CANCELED state.
  canceled: ChallengeConditionParticipantSummary
  # Summary of participants attached to a particular condition in the CONDITION_CANCELED state.
  conditionCanceled: ChallengeConditionParticipantSummary
  # Summary of participants attached to a particular condition in the CONDITION_TIMEOUT state.
  conditionTimeout: ChallengeConditionParticipantSummary
  # Summary of participants attached to a particular condition in the FAILED_VALIDATION state.
  failedValidation: ChallengeConditionParticipantSummary
  # Summary of participants attached to a particular condition in the PENDING state.
  pending: ChallengeConditionParticipantSummary
  # Summary of participants attached to a particular condition in the SATISFIED state.
  satisfied: ChallengeConditionParticipantSummary
  # Summary of participants attached to a particular condition in the TIMEOUT state.
  timeout: ChallengeConditionParticipantSummary
  # Total count of participants attached to a particular condition.
  total: Int!
}

# The current state of the condition.
enum ChallengeConditionState {
  # New condition participants can be associated with this condition.
  ACTIVE
  # Condition was manually terminated. New condition participants cannot be associated.
  CANCELED
  # Condition was satisfied for the final time. New condition participants cannot be associated with this condition.
  INACTIVE
  # Condition was automatically terminated. New condition participants cannot be associated.
  EXPIRED
  # Unknown state.
  UNKNOWN
}

# An effect that will occur if a challenge condition participant is satisfied.
type ChallengeEffect {
  # Details of the effect.
  details: ChallengeEffectDetails!
  # The type of effect.
  type: ChallengeEffectType!
}

# Details of the effect.
union ChallengeEffectDetails = ChallengeUseBitsEffectDetails
# Settings that define how effects will be processed when a condition is satisfied.
type ChallengeEffectSettings {
  # Details of the effect settings.
  details: ChallengeEffectSettingsDetails!
  # The type of effect.
  type: ChallengeEffectType!
}

# Details of the effect settings.
union ChallengeEffectSettingsDetails = ChallengeUseBitsEffectSettingsDetails
# A summary of effects attached to a particular condition in a particular state. Keys correspond to ChallengeEffectType enum.
type ChallengeEffectSummary {
  # USE_BITS effects.
  useBits: ChallengeUseBitsEffectSummary
}

# The type of effect.
enum ChallengeEffectType {
  # Type of effect that results in using a user's bits.
  USE_BITS
  # Unknown type.
  UNKNOWN
}

# Details of the UseBits effect.
type ChallengeUseBitsEffectDetails {
  # The user who uses the bits.
  benefactor: User
  # The amount of bits to be used.
  bitsAmount: Int!
}

# Details of the UseBits effect settings.
type ChallengeUseBitsEffectSettingsDetails {
  # A list of the different bits recipients and their weighted share of the total bits pool once the condition is satisfied.
  bitsRecipientWeightedShares: [ChallengeUseBitsPoolRecipientWeightedShare!]!
}

# A summary of USE_BITS effects attached to a particular condition in a particular state.
type ChallengeUseBitsEffectSummary {
  # Sum of Bits rolling up to a particular condition in a particular state.
  totalBitsAmount: Int!
  # Total count of USE_BITS effects rolling up to a particular condition in a particular state.
  totalEffects: Int!
}

# ChallengeUseBitsPoolRecipientWeightedShare represents the weighted share of the total bits pool
# that a recipient user is entitled to upon condition satisfaction.
type ChallengeUseBitsPoolRecipientWeightedShare {
  # The bits recipient user.
  recipient: User
  # The weight of the recipient's share from the total bits pool. The sum of all the recipients' weights
  # dictates the proportion that a particular recipient receives from the pool
  # (shareWeight/totalShareWeight * totalBitsAmountInPool).
  weight: Int!
}

# ChangelogEntry is an entry that displays new items and notifications in the creator homepage changelog.
type ChangelogEntry {
  # content is localized text content for the changelog entry.
  content: String!
  # iconURL is the url for the entry's icon image.
  iconURL: String!
  # id is a unique human readable slug for the entry e.g. "squad-stream".
  id: ID!
  # linkText is the text that the linkURL should display.
  linkText: String
  # linkURL is an optional link for more content for this changelog entry.
  linkURL: String
  # position is where entry should be located within changelog entries of the same date.
  position: Int!
  # publishedAt is the timestamp that the changelog entry was published.
  publishedAt: Time
  # title is the localized title of the changelog entry.
  title: String!
}

# Error returned during an invalid change username request.
type ChangeUsernameCodeError {
  # Error code returned by the backend.
  code: ChangeUsernameErrorCode!
}

# Possible error codes returned from a change username.
enum ChangeUsernameErrorCode {
  # Sudo token expired, prompt the user to log in again.
  REAUTH_NEEDED
  # Too many attempts to update login.
  REQUESTS_THROTTLED
  # Login was changed recently (last 60 days).
  LOGIN_CHANGE_COOLDOWN
  # Login is not available.
  LOGIN_UNAVAILABLE
  # Login is too short.
  LOGIN_TOO_SHORT
  # Login is too long.
  LOGIN_TOO_LONG
  # Login contains characters that are not allowed.
  LOGIN_CONTAINS_INVALID_CHARACTERS
  # Login change requires a verified email.
  LOGIN_CHANGE_EMAIL_VERIFIED
  # Unrecognized error returned from the backend service.
  UNKNOWN_ERROR
}

# Input for a change username.
input ChangeUsernameInput {
  # The new login for the user.
  login: String!
  # User id of the user being updated.
  userID: ID!
}

# The result of a change username.
type ChangeUsernamePayload {
  # Error code for error returned from change username.
  error: ChangeUsernameCodeError
  # The modified user.
  user: User
}

# ChanletSort indicates the desired order of chanlets in the list returned by LoadChanletsByUserID.
enum ChanletSort {
  # ChanletSortNone indicates that the order of chanlets returned is insignificant
  # to the client and is allowed to be arbitrary.
  NONE
  # ChanletSortViewerCount indicates chanlets should return sorted by viewer counts, descending.
  VIEWER_COUNT
}

# A User's place on Twitch.
type Channel {
  # All Prediction Events that are actively accepting new predictions.
  activePredictionEvents: [PredictionEvent!]
  # A mapping of AutoMod categories to levels.
  autoModConfiguration: AutoModConfiguration
  # A list of content attributes created for the channel, that can be associated
  # with the chanlets, to augment the multi-view experience.
  availableContentAttributes: [MultiviewContentAttribute!]
  # A list of available Drops that viewers of this channel can claim when certain game events are met.
  availableDrops: [DropObject]
    @deprecated(reason: "use channel.viewerDropCampaigns")
  # A paginated list of users who are banned from this channel.
  bannedUsers(after: Cursor, first: Int = 25): ChannelBannedUserConnection
  # A paginated list of the channel's blocked terms.
  blockedTerms(after: Cursor, first: Int = 25): ChannelBlockedTermConnection
  # The boost settings for the channel.
  boostSettings: BoostSettings
  # The language the broadcaster has chosen to stream in.
  broadcasterLanguage: String!
    @deprecated(reason: "Use stream.language instead.")
  # The celebration configuration for the channel, which contains if celebrations
  # are enabled and a list of configured celebrations.
  celebrations: CelebrationConfig
  # The stream key for this channel if it is a multi-view chanlet. The requesting
  # user must "own" this chanlet to be authorized to see this.
  chanletStreamKey: String
  # A list of the channel's chanlets (sub-channels) in a multi-view experience.
  chanlets(
    sort: ChanletSort = NONE
    bypassDisableFlag: Boolean = false
  ): [Channel!]
  # Get the chatters on this channel.
  chatters: ChattersInfo
  # The clip settings for a channel, includes settings on clip creation.
  clipsSettings: ChannelClipsSettings
  # Get a single community points custom reward redemption by its ID.
  communityPointsCustomRewardRedemption(
    id: ID!
  ): CommunityPointsCustomRewardRedemption
  # The queue of community points custom reward redemptions in this channel.
  communityPointsRedemptionQueue(
    first: Int = 10
    after: Cursor
    options: CommunityPointsRedemptionQueueOptions
  ): CommunityPointsCustomRewardRedemptionConnection
  # Details about community points in the channel.
  communityPointsSettings: CommunityPointsChannelSettings
  # For a multi-view chanlet, this is the list of content attributes that have been associated with the given chanlet.
  contentAttributes: [MultiviewContentAttribute!]
  # The channel's badge flair setting and assets that are available to eligible subscribers.
  creatorBadgeFlair: CreatorBadgeFlair
  # Details about crowd chants in the channel.
  crowdChants: CrowdChants
  # Fetch the requesting user's currently playing radio content.
  currentRadioTrack: RadioCurrentlyPlaying
  # Returns configurations for a dashboard view in different parts of Twitch, such as Stream Manager
  # or Twitch Studio. Includes configurations for things like layout and other features.
  dashboardView(type: ChannelDashboardViewType!): ChannelDashboardView!
  # The channel's name, with user-specified formatting.
  displayName: String
  # A drop 2.0 campaign including personal settings (e.g. account connection status). (Streamer dashboard individual item).
  dropCampaign(id: ID!): DropCampaign
  # A list of all available Drops 2.0 campaigns that a channel is eligible to participate in. (Streamer dashboard list).
  dropCampaigns: [DropCampaign!]
  # founderBadgeAvailability is a number of available slots for Founder Badge entitlement.
  founderBadgeAvailability: Int!
  # The name of the last game played on this channel.
  game: String! @deprecated(reason: "Use user.lastBroadcast.game.name instead.")
  # The Home of a channel.
  home: ChannelHome
  # The structure that contains information about the channel's Hype Train execution and config.
  hypeTrain: HypeTrain!
  # The channel's unique identfier.
  id: ID!
  # A setting which states whether or not users can create Clips on this channel.
  # By default, clipping on a channel is enabled.
  isClipsEnabled: Boolean!
    @deprecated(reason: "Use channel.clipsSettings instead.")
  # Whether or not the channel is a hidden multi-view chanlet that is only meant
  # to be accessible through another channel and not exist as a completely
  # independent channel.
  isHiddenChanlet: Boolean!
  # Whether the broadcaster has designated the channel's broadcast for mature audiences only.
  isMature: Boolean! @deprecated(reason: "Use stream.isMature instead.")
  # Whether the channel has opted out of drops.
  isOptedOutOfDrops: Boolean
  # Whether the channel is using the new AutoMod vendor for enforcement.
  isMemberOfAutoModRollout: Boolean
  # leaderboardSet contains the set of leaderboards that are active on this channel.
  leaderboardSet(first: Int = 10): LeaderboardSet
  # leaderboardTimePeriod indicates whether the leaderboard type is of WEEKLY, ALL-TIME, etc.
  leaderboardTimePeriod: LeaderboardTimePeriodType
  # All Prediction Events that are no longer accepting new predictions, and are awaiting resolution.
  lockedPredictionEvents: [PredictionEvent!]
  # Retrieves video manager videos for the channel, this requires owner or editor permissions.
  managedVideos(
    first: Int = 10
    after: Cursor
    statuses: [VideoStatus!]
    types: [BroadcastType!]
    sort: VideoSort = TIME
  ): VideoConnection
  # Returns a resolver to query moderation logs.
  moderationLogs: ModerationLogs
  # The channel's name.
  name: String!
  # The number of VIP roles a user can assign in their channel.
  numberOfVIPsAllowed: Int
  # The user who owns this channel.
  owner: User
  # Configurations for chanlets this channel owns.
  ownerChanletAttributes: OwnerChanletAttributes
  # A paginated list of the channel's blocked terms.
  permittedTerms(after: Cursor, first: Int = 25): ChannelPermittedTermConnection
  # Settings dictating how Prediction Events are run on this channel.
  predictionSettings: ChannelPredictionSettings
  # Fetches most recent chat messages sent for the given channel.
  recentChatMessages: [Message!]!
  # A single page of Prediction Events that have been resolved.
  resolvedPredictionEvents(
    first: Int = 10
    after: Cursor
  ): PredictionEventConnection
  # The restriction that is currently active on the channel for restricting a user's access to it.
  restriction: ResourceRestriction
  # The stream schedule of the user.
  # Returns null when the user has not set a schedule.
  schedule: Schedule
  # The requesting user's relationship with the channel.
  self: ChannelSelfEdge
  # Extension information pertaining to the active user. Note that this is not
  # part of the `self` property as this still returns data for anonymous users.
  selfInstalledExtensions(
    isMobile: Boolean = false
  ): [ExtensionInstallationSelfEdge!]
  # The channel's social media links and favicons.
  socialMedias: [SocialMedia!]
  # A user-defined status message.
  status: String! @deprecated(reason: "Use user.lastBroadcast.title instead.")
  # The live broadcast associated with this channel, if currently broadcasting.
  stream: Stream @deprecated(reason: "Use user.stream instead.")
  # A list of streams for a given channel for multi-view.
  streams: [Stream!]
  # Channel trailer for this channel.
  trailer: Trailer
  # Requests from channel-banned users to be unbanned submitted on the channel.
  # Accessible by users with moderator role or higher.
  unbanRequests(
    after: Cursor
    first: Int = 25
    options: UnbanRequestsOptions
  ): UnbanRequestConnection
  # Settings for users creating unban requests on the channel.
  unbanRequestsSettings: UnbanRequestsSettings
  # The URL to view the channel in a browser.
  url: String!
  # Video stream settings for ingesting a stream such as stream key, latency mode, or vod save preference.
  videoStreamSettings: VideoStreamSettings
  # A list of available Drop 2.0 Campaigns of which drops viewers of this channel
  # can claim when certain game events or minutes watched events are met. (Channel
  # highlight card).
  viewerDropCampaigns: [DropCampaign!]
}

# Channel Analytics in Creator Dashboard.
type ChannelAnalytics {
  # SubCountSeries in Channel Analytics that shows a user's sub count over time.
  subCountSeries: SubCountSeries
}

# Analytics around what other content my viewers watch.
type ChannelAnalyticsContentOverlap {
  # Other channels that my viewers like to watch.
  channels: [ChannelOverlap!]
  # Games that my viewers like to watch.
  games: [GameOverlap!]
}

# ChannelBannedUser is an object that defines metadata about a channel ban.
type ChannelBannedUser {
  # When the ban was created.
  bannedAt: Time!
  # Representation of the banned user.
  bannedUser: User
  # Representation of the mod that banned the user.
  modUser: User
}

# Paginated list of users banned from a channel.
type ChannelBannedUserConnection {
  # The elements of the list.
  edges: [ChannelBannedUserEdge!]
  # Information about this page of banned users.
  pageInfo: PageInfo!
}

# Element in a list of users banned from a channel.
type ChannelBannedUserEdge {
  # Opaque cursor describing this edge's position in the paginated list.
  cursor: Cursor!
  # A ban record for a user banned from a channel.
  node: ChannelBannedUser
}

# ChannelBlockedTerm is an object that defines things that automod should permit in a channel.
type ChannelBlockedTerm {
  # ID of the term.
  id: ID!
  # If the term is permitted or banned type.
  category: String! @deprecated(reason: "ChannelBlockedTerm is always banned")
  # When the term was created.
  createdAt: Time
  # When the term expires at.
  expiresAt: Time
  # If mods should be able to see and edit this term.
  isModEditable: Boolean!
  # phrases are the string representation of a term.
  phrases: [String!]! @deprecated(reason: "Replaced by phrase field")
  # phrase is the string representation of a term.
  phrase: String!
  # User who added the term to the blocked terms list.
  source: User
  # When the term was last updated.
  updatedAt: Time
}

# Paginated list of Channel Blocked Terms.
type ChannelBlockedTermConnection {
  # The elements of the list.
  edges: [ChannelBlockedTermEdge!]!
  # Information about this page.
  pageInfo: PageInfo!
}

# Element in a list of Channel Blocked Terms.
type ChannelBlockedTermEdge {
  # Opaque cursor describing this edge's position in the paginated list.
  cursor: Cursor!
  # The Channel Blocked Term.
  node: ChannelBlockedTerm
}

# A challenge to which users can contribute bits.
interface ChannelChallenge {
  # Total bits amount contributed.
  bitsAmount: Int!
  # Time when challenge was created.
  createdAt: Time!
  # User that created the challenge.
  createdBy: User
  # Amount of seconds from when the challenge starts to when it ends.
  durationSeconds: Int!
  # ID of challenge.
  id: ID!
  # User who owns this challenge. The challenge will appear on their channel.
  ownedBy: User
  # Amount of milliseconds before the challenge times out.
  # 0 when the challenge has timed out.
  remainingDurationMilliseconds: Int!
  # The authenticated user's relationship with this challenge.
  # Main use case is to connect the user to a challenge to allow bit contributions.
  # Null if un-authenticated user is making this query.
  self: ChannelChallengeSelfEdge
  # The status of the challenge.
  status: ChannelChallengeStatus!
  # Time when challenge was updated.
  updatedAt: Time!
}

# A connection between the challenge and metadata.
type ChannelChallengeConnection {
  # The list of challenges for the user.
  edges: [ChannelChallengeEdge!]
  # Information about pagination in this connection.
  pageInfo: PageInfo!
}

# A page entry, that contains the Challenge item and a cursor to return from the query to allow pagination.
type ChannelChallengeEdge {
  # Cursor used for next query.
  cursor: Cursor!
  # The underlying challenge.
  node: ChannelChallenge!
}

# A participant contributing to a challenge and associated information.
type ChannelChallengeParticipant {
  # The bits this participant has contributed to a challenge.
  bits: Int!
  # The Challenge this participant contributed to.
  challenge: ChannelChallenge
  # Time when participant first contributed to the challenge.
  firstContributedAt: Time!
  # id of the participant in the challenge.
  id: ID!
  # Time when participant last contributed to the challenge.
  lastContributedAt: Time!
}

# A connection between a challenge and the authenticated user.
type ChannelChallengeSelfEdge {
  # The participant object pertaining to the authenticated user.
  participant: ChannelChallengeParticipant
}

# Possible sort orders for lists of challenges.
enum ChannelChallengeSort {
  # Sort the challenges by time.
  START_TIME
  # Sort the challenges by time.
  END_TIME
}

# The status of the challenge.
enum ChannelChallengeStatus {
  # Encountered some challenge status that we do not know how to handle.
  UNKNOWN
  # Challenge is active. Users can contribute bits, with the challenge information publicly visible.
  ACTIVE
  # Challenge was manually ended by a user and marked as "completed". Users cannot
  # contribute bits. Challenge information publicly visible.
  COMPLETED
  # Challenge was manually ended by a user and marked as "failed". Users cannot
  # contribute bits. Challenge information publicly visible.
  FAILED
  # Challenge has ended and is no longer publicly visible. Users cannot contribute
  # bits. Challenge information publicly visible.
  TIMED_OUT
}

# ChannelClipsCreationAuthRestrictionOptionsInput are the additional options for the auth restrictions.
input ChannelClipsCreationAuthRestrictionOptionsInput {
  # The time requirement in minutes, of how long a follower needs to be following to create clips.
  followingLengthMinutes: Int
}

# ChannelClipsCreationRestrictedTo contains the roles that are allowed to create Clips on a channel
# that has isClipsEnabled set to true.
type ChannelClipsCreationRestrictedTo {
  # Clip creation is restricted to users that are followers.
  isFollower: Boolean!
  # Clip creation is restricted to users that are subscribers.
  isSubscriber: Boolean!
}

# ChannelClipsCreationRestrictedToInput contains the roles that are allowed to create Clips on a channel
# that has isClipsEnabled set to true.
input ChannelClipsCreationRestrictedToInput {
  # Allow channel followers to create Clips.
  followers: Boolean!
  # Allow channel subscribers to create Clips.
  subscribers: Boolean!
}

# ChannelClipsCreationRestrictionOptions are the additional options for the auth restrictions.
type ChannelClipsCreationRestrictionOptions {
  # The time requirement in minutes, of how long a follower needs to be following to create clips.
  followingLengthMinutes: Int
}

# ChannelClipsSettings are the clips setting for the channel, including restriction settings for clip creation.
type ChannelClipsSettings {
  # If isClipsEnabled is true, allow the following roles to create Clips on the channel.
  creationRestrictedTo: ChannelClipsCreationRestrictedTo
  # If there are clip creation restrictions, use the following to add options to those restrictions.
  creationRestrictionOptions: ChannelClipsCreationRestrictionOptions
  # Set whether or not users can create Clips on this channel.
  isClipsCreationEnabled: Boolean!
}

# Settings dictating how Crowd Chants are run on a channel.
type ChannelCrowdChantSettings {
  # Whether the channel is allowed to run Crowd Chants at all.
  isEligible: Boolean!
}

# Data about a single configured Mosaic layout. This layout
# specifies a configuration of panel dimensions and positions
# in a grid, as defined by the Mosaic algorithm.
interface ChannelDashboardLayout {
  # A unique identifier to uniquely reference this layout.
  id: ID!
  # The display name for the layout shown to the user.
  name: String!
  # A version to identify how the layout was generated,
  # such as for deprecation purposes.
  version: String!
  # When the layout was last updated
  lastUpdated: Time
}

# A view for editing a channel, including panels, layouts, options, etc.
# Includes views like Stream Manager, Twitch Studio, etc.
type ChannelDashboardView {
  # Panel layout configurations for this view type.
  layouts: [ChannelDashboardLayout!]
  # Information about the view pertaining to the current channel for the
  # current user, such as how many custom layouts have been used.
  options: ChannelDashboardViewOptions!
}

# Details about the specific data of a layout type for
# a channel, such as the number of custom layouts available
# for use by the current user.
type ChannelDashboardViewOptions {
  # Total (maximum) number of custom layouts the user can use for the channel
  # for the specific dashboard view type.
  customLayoutsTotal: Int
  # Amount of layouts the user has used for the channel for a specific dashboard view type.
  customLayoutsUsed: Int
}

# What channel feature the dashboard view is for.
enum ChannelDashboardViewType {
  # Views for Stream Manager layout panels and other components.
  STREAM_MANAGER
  # Views for Twitch Studio layout panels.
  TWITCH_STUDIO
}

# The Home of a channel.
type ChannelHome {
  # The preferences that power a channel's home page.
  preferences: ChannelHomePreferences
  # The shelves that are shown on a channel's home page.
  shelves: ChannelHomeShelves
}

# A list of categories displayed on a channel home's Category Shelf.
type ChannelHomeCategoryShelf {
  # The list of categories to display in the shelf.
  edges: [ChannelHomeCategoryShelfEdge!]!
}

# The edges of the channel home category shelf.
type ChannelHomeCategoryShelfEdge {
  # The category to display in the shelf.
  node: Game
}

# A list of categories displayed on a channel home's Category Shelf.
type ChannelHomeCategorySuggestionsShelf {
  # The list of categories to display in the shelf.
  edges: [ChannelHomeCategorySuggestionsShelfEdge!]!
}

# Contains a category and a boolean to denote whether the user has chosen to hide
# that category from their channel home page's category shelf.
type ChannelHomeCategorySuggestionsShelfEdge {
  # This is true if the user has chosen to hide this category from their category shelf.
  isHidden: Boolean!
  # The category.
  node: Game
}

# The streamer's channel home preferences.
type ChannelHomePreferences {
  # The hero preset.
  heroPreset: HeroPreset!
  # The type of streamer shelf to display.
  streamerShelfType: StreamerShelfType!
}

# The shelves that are shown on a channel's home page.
type ChannelHomeShelves {
  # A list of categories displayed on a channel home's Category Shelf.
  categoryShelf(first: Int = 20): ChannelHomeCategoryShelf
  # A list of suggested categories to display on a channel home's Category Shelf.
  categoryShelfSuggestions(first: Int = 20): ChannelHomeCategorySuggestionsShelf
  # The type and, if applicable, the list of users displayed in a channel home's Streamer Shelf.
  streamerShelf(first: Int = 20): ChannelHomeStreamerShelf
}

# The list of users displayed in a channel home's Streamer Shelf.
type ChannelHomeStreamerShelf {
  # The list of users to display in the shelf.
  edges: [ChannelHomeStreamerShelfEdge!]!
  # The type of streamer shelf to display (Autohost, Team, or Disabled).
  type: StreamerShelfType!
}

# The edges of the channel home streamer shelf.
type ChannelHomeStreamerShelfEdge {
  # The user to display in the shelf.
  node: User
}

# Paginated list of moderation actions on a channel.
type ChannelModerationActionConnection {
  # List of moderation actions.
  edges: [ChannelModerationActionEdge!]
  # Information about page.
  pageInfo: PageInfo!
}

# Element in a list of moderation actions of a user on a channel.
type ChannelModerationActionEdge {
  # A cursor for the current node.
  cursor: Cursor!
  # A moderation action.
  node: ChannelModerationActionEntry
}

# An entry of a moderation action performed on a channel.
interface ChannelModerationActionEntry {
  # The action that was taken.
  action: ModerationAction!
  # Timestamp when action was taken.
  createdAt: Time!
  # UUID of the moderation action.
  id: ID!
  # The moderator who took the action.
  moderator: User
}

# Moderation Actions relating to automod levels.
# ex: automod level change.
type ChannelModerationActionOnAutomodLevelEntry implements ChannelModerationActionEntry {
  # The action that was taken.
  action: ModerationAction!
  # New automod level properties (based on Sift categories, to be deprecated).
  automodNewProperties: AutoModProperties
  # Previous automod level properties (based on Sift categories, to be deprecated).
  automodOldProperties: AutoModProperties
  # Previous automod level properties.
  automodPreviousLevels: AutoModConfiguration
  # The newly updated automod level properties.
  automodUpdatedLevels: AutoModConfiguration
  # Timestamp when action was taken.
  createdAt: Time!
  # UUID of the moderation action.
  id: ID!
  # The moderator who took the action.
  moderator: User
}

# Moderation Actions relating to automod terms.
# ex: add permitted term, remove permitted term, add banned term, remove banned term.
type ChannelModerationActionOnAutomodTermEntry implements ChannelModerationActionEntry {
  # The action that was taken.
  action: ModerationAction!
  # Timestamp when action was taken.
  createdAt: Time!
  # UUID of the moderation action.
  id: ID!
  # If the action originated from a message caught by Automod.
  isFromAutomod: Boolean!
  # The moderator who took the action.
  moderator: User
  # Strings that were add/deleted from permitted/blocked lists.
  terms: [String!]
}

# Moderation Actions relating to another channel.
# ex: host, unhost, raid, unraid.
type ChannelModerationActionOnChannelEntry implements ChannelModerationActionEntry {
  # The action that was taken.
  action: ModerationAction!
  # Timestamp when action was taken.
  createdAt: Time!
  # UUID of the moderation action.
  id: ID!
  # Is auto hosted.
  isAutoHosted: Boolean!
  # Is hosted after raiding.
  isHostedAfterRaiding: Boolean!
  # The moderator who took the action.
  moderator: User
  # Should the viewer count for host or raids should be shown.
  shouldRevealViewerCount: Boolean!
  # Target channel for hosting and raiding.
  target: User
  # How many users participated in a host or raid.
  viewerCount: Int
}

# Moderation Actions relating to chat messages.
# ex: delete message.
type ChannelModerationActionOnChatMessageEntry implements ChannelModerationActionEntry {
  # The action that was taken.
  action: ModerationAction!
  # Timestamp when action was taken.
  createdAt: Time!
  # UUID of the moderation action.
  id: ID!
  # The message contents of the message deleted.
  messageBody: String
  # The id of the message deleted.
  messageID: ID
  # The sender of the message.
  messageSender: User
  # The moderator who took the action.
  moderator: User
}

# Moderation Actions realting to chat modes.
# ex: slow on, followers only on, emotes only, sub only, clear chat.
type ChannelModerationActionOnChatModeEntry implements ChannelModerationActionEntry {
  # The action that was taken.
  action: ModerationAction!
  # Timestamp when action was taken.
  createdAt: Time!
  # Duration of the chat time in seconds.
  durationSeconds: Int
  # UUID of the moderation action.
  id: ID!
  # The moderator who took the action.
  moderator: User
}

# Moderation Actions relating to unban requests.
# ex: approve, deny.
type ChannelModerationActionOnUnbanRequestsEntry implements ChannelModerationActionEntry {
  # The action that was taken.
  action: ModerationAction!
  # Timestamp when action was taken.
  createdAt: Time!
  # UUID of the moderation action.
  id: ID!
  # The moderator who took the action.
  moderator: User
  # Reason for action.
  reason: String!
  # The user which the action targets if any.
  target: User
}

# Moderation Actions relating to a user.
# ex: ban, unban, timeout, untimeout, mod, unmod, vip, unvip.
type ChannelModerationActionOnUserEntry implements ChannelModerationActionEntry {
  # The action that was taken.
  action: ModerationAction!
  # Timestamp when action was taken.
  createdAt: Time!
  # Duration of the chat time in seconds for timeouts.
  durationSeconds: Int
  # UUID of the moderation action.
  id: ID!
  # The moderator who took the action.
  moderator: User
  # Reason for action.
  reason: String!
  # The user which the action targets if any.
  target: User
}

# Moderation Actions that are unused, invalid or deprecated.
type ChannelModerationActionOtherEntry implements ChannelModerationActionEntry {
  # The action that was taken.
  action: ModerationAction!
  # Timestamp when action was taken.
  createdAt: Time!
  # UUID of the moderation action.
  id: ID!
  # The moderator who took the action.
  moderator: User
}

type ChannelNotificationSetting {
  # The setting category.
  category: String!
  # Whether this setting is on or off for the given event.
  isEnabled: Boolean!
  # The exact state of the setting. ("on", "off", "friends_only", etc).
  settingState: String!
}

# Data about notification settings for a follow relationship.
type ChannelNotificationSettings {
  # If true, enabled notifications will be send. If false, all notifications are
  # disabled, even if their individual setting is enabled.
  isEnabled: Boolean!
  # A list of channel notification settings.
  nodes: [ChannelNotificationSetting!]!
}

# Channel that my viewers also like to watch.
type ChannelOverlap {
  # How much my viewers like to watch this channel.
  score: Float!
  # Channel that my viewers also like to watch.
  viewersAlsoWatch: User
}

# An enumeration of permissions a user can have on a channel.
enum ChannelPermission {
  # Permission to manage Chanlets, which represent sub-streams in a multiview mode.
  MULTIVIEW_ADMIN
  # Permission to create restrictions on the channel.
  SET_CHANNEL_RESTRICTION
}

# ChannelPermittedTerm is an object that defines things that automod should permit in a channel.
type ChannelPermittedTerm {
  # ID of the term.
  id: ID!
  # If the term is permitted or banned type.
  category: String!
    @deprecated(
      reason: "ChannelPermittedTerm type will always be of category permitted"
    )
  # When the term was created.
  createdAt: Time
  # When the term expires at.
  expiresAt: Time
  # If mods should be able to see and edit this term.
  isModEditable: Boolean!
    @deprecated(reason: "ChannelPermittedTerm is always mod editable")
  # phrases are the string representation of a term.
  phrases: [String!]! @deprecated(reason: "Replaced by phrase field")
  # phrase is the string representation of a term.
  phrase: String!
  # User who added the term to the permitted terms list.
  source: User
  # When the term was last updated.
  updatedAt: Time
}

# Paginated list of Channel Permitted Terms.
type ChannelPermittedTermConnection {
  # The elements of the list.
  edges: [ChannelPermittedTermEdge!]!
  # Information about this page.
  pageInfo: PageInfo!
}

# Element in a list of Channel Permitted Terms.
type ChannelPermittedTermEdge {
  # Opaque cursor describing this edge's position in the paginated list.
  cursor: Cursor!
  # The Channel Permitted Term.
  node: ChannelPermittedTerm
}

# Settings dictating how Prediction Events are run on a channel.
type ChannelPredictionSettings {
  # Whether channel moderators are allowed to create and resolve Prediction Events.
  canModeratorsManagePredictions: Boolean!
  # Whether the channel is allowed to run Prediction Events at all.
  isEligibleForPredictions: Boolean!
}

# A restriction for a specific channel.
type ChannelRestriction {
  # The time that the restriction is no longer active.
  endsAt: Time
  # Information about being exempt from the restriction.
  exemptionInfo: ChannelRestrictionExemptionInfo!
    @deprecated(reason: "Use resourceRestriction.exemptions instead.")
  # The ID of the channel restriction.
  id: ID!
  # The time that the restriction becomes active.
  startsAt: Time
  # The type of restriction on this channel.
  type: ChannelRestrictionType!
}

# Exemption information for a specific channel restriction.
type ChannelRestrictionExemptionInfo {
  # The type of exemption.
  exemptionType: String!
    @deprecated(reason: "Use channelRestriction.type instead.")
}

# An enumeration of the different restriction types.
enum ChannelRestrictionType {
  # The resource is restricted for an unknown reason.
  UNKNOWN
  # The channel is restricted by a subscription.
  SUB_ONLY_LIVE
  # The channel is restricted by the All-Access Pass.
  ALL_ACCESS_PASS
}

# Information about the requesting user with respect to a channel.
type ChannelSelfEdge {
  # Whether or not the requesting user can request an unban on the channel.
  canRequestUnban: Boolean
  # Properties relating to the authenticated user's community points in a channel.
  # Null if community points are not enabled in the channel.
  communityPoints: CommunityPointsProperties
  # Whether or not the requesting user is authorized to view the channel's content in a channel restrictions context.
  isAuthorized: Boolean!
  # Whether or not the resource is restricted for the requesting user.
  isResourceRestricted: Boolean!
  # Returns the user's last unban request on the channel.
  lastUnbanRequest: UnbanRequest
  # Chat messages sent in a channel that are relevant to moderators.
  modChatLogs(
    first: Int = 100
    after: Cursor
    order: SortOrder = DESC
    includeMessageCount: Boolean = false
    includeTargetedActions: Boolean = false
    includeAutoModCaughtMessages: Boolean = true
  ): ModLogsMessageConnection
  # List of channel feature permissions the logged in user has on the channel.
  permissions: [ChannelPermission!]!
  # List of recent (either still active or recently resolved) Predictions made by this user on this Channel.
  recentPredictions: [Prediction!]
  # If restricted, how the resource is restricted.
  restrictionType: ResourceRestrictionType
  # Reason why user cannot request an unban on the channel.
  unbanRequestRestriction: UnbanRequestRestrictionReason
}

# The possible user roles within a channel.
enum ChannelUserRole {
  # The channel owner.
  BROADCASTER
  # An editor for the channel.
  EDITOR
  # A moderator for the channel.
  MODERATOR
  # A subscriber of the channel.
  SUBSCRIBER
  # A user with no roles.
  REGULAR
}

# Channel/Viewer pair.
type ChannelViewer {
  # ID of the form userID:channelID.
  id: ID!
  # Fetches global badges and channel badges earned by the User on a channel.
  # The returned list of badges will exclude badges that userID has elected to hide.
  # If the user is the authenticated user, Badge.self.isVisibleInChatCard will reflect
  # the user's stored preference, which can be editted on a per-badge basis with the
  # setBadgePublicVisiblity mutation.
  earnedBadges: [Badge!]
}

# Information about the intended device for making a refill purchase for a user.
type ChargeInstrument {
  # A charge instrument Id.
  id: ID!
}

# Input charge instrument information.
input ChargeInstrumentInput {
  # A charge instrument Id.
  id: ID!
}

# ChargeModel describes the model used for charging the user. Will only contain
# one credit model, one external model, or one internal model.
type ChargeModel {
  # A charge model in which a user is charged using credits purchased or earned on Twitch.
  credit: CreditChargeModel
  # A charge model in which a user is charged via a third-party in a fiat currency.
  external: ExternalChargeModel
  # A charge model in which a user is charged by Twitch in a fiat currency.
  internal: InternalChargeModel
}

# ChargeModelPlan defines the payment plan of the charge model.
type ChargeModelPlan {
  # The time interval for the charge model.
  interval: ChargeModelPlanInterval!
  # The renewal policy for the charge model.
  renewalPolicy: RenewalPolicy!
}

# ChargeModelPlanInterval is the time interval for the charge model.
type ChargeModelPlanInterval {
  # The duration of the charge model interval (used with the unit).
  duration: Int!
  # The unit of the charge model interval.
  unit: ChargeModelPlanIntervalUnit!
}

# ChargeModelPlanIntervalUnit defines the unit of the charge model interval.
enum ChargeModelPlanIntervalUnit {
  # Interval unit of Days.
  DAYS
  # Interval unit of Months.
  MONTHS
  # Unknown interval unit.
  UNKNOWN
}

# ChatPauseSetting represents the possible settings for the user's preferred way to pause chat when moderating.
enum ChatPauseSetting {
  # SCROLL_ONLY is the default behavior and pauses chat every time the users scrolls over the chat list.
  SCROLL_ONLY
  # MOUSEOVER pauses chat whenever a user's mouse hovers over the list, unpauses
  # automatically after 5 seconds if no scroll is performed.
  MOUSEOVER
  # ALTKEY pauses chat when the user presses the alt key (option for mac users). It unpauses when the key is released.
  ALTKEY
  # MOUSEOVER_ALTKEY pauses chat on mouse hover and hitting the alt key.
  MOUSEOVER_ALTKEY
}

# Reasons that a user might not be allowed to chat in a specific channel.
enum ChatRestrictedReason {
  # The user is prevented from chatting without a verified phone number.
  # They will be prompted to verify one upon chatting.
  REQUIRE_VERIFIED_PHONE_NUMBER
  # The user is prevented from chatting by subscribers-only mode. They should
  # subscribe to the channel to chat.
  SUBSCRIBERS_ONLY
  # The user is prevented from chatting by followers-only mode. They should
  # either follow the channel, or wait longer to satisfy the required time.
  # See user.self.follower.followedAt for when the user followed, and
  # user.self.chatSettings.followersOnlyDurationMinutes for the minimum
  # required follow time.
  FOLLOWERS_ONLY
  # The user is prevented from chatting by verified-only mode. They should
  # verify their account to chat.
  VERIFIED_ONLY
  # The user can't chat because they've chatted too recently. See
  # user.self.lastRecentChatMessageAt to calculate how much time is remaining
  # before they can chat again.
  SLOW_MODE
}

type ChatRoomBanStatus {
  # The user being banned of this chat.
  bannedUser: User
  # The time the ban was imposed.
  createdAt: Time!
  # The time at which the ban will automatically expire.
  expiresAt: Time
  # The time in ms at which the ban will expire.
  expiresInMs: Int
  # Conveys if the ban is permanent.
  isPermanent: Boolean!
  # The moderator that carried out the action.
  moderator: User
  # The reason the user was banned.
  reason: String
  # The entity representing the users channel or chat room.
  roomOwner: User
}

# ChatSettings are settings and rules for chatting in a channel.
type ChatSettings {
  # autoModLevel is an integer from 0-4 representing the level of automoderation of chat
  # 0 is off, 4 is the highest level of moderation.
  autoModLevel: Int! @deprecated(reason: "No longer used.")
  # blockLinks indicates if links should be deleted from non-mod messages.
  blockLinks: Boolean!
  # chatDelayMs is the delay before non-mods see a message.
  chatDelayMs: Int!
  # The number of minutes a user must be following the broadcaster in order to chat
  # If value is null, followers only mode is not enabled.
  followersOnlyDurationMinutes: Int
  # isBroadcasterLanguageModeEnabled indicates if the broadcaster requires chat messages to
  # match their language.
  isBroadcasterLanguageModeEnabled: Boolean!
    @deprecated(reason: "No longer used.")
  # Indicates whether chat is currently enforcing that messages may only contain emotes.
  isEmoteOnlyModeEnabled: Boolean!
  # Indicates whether subscribers are allowed to bypass slowmode.
  isFastSubsModeEnabled: Boolean!
  # If isOptedOutOfGlobalBannedWordsList is true, the legacy twitch banned words list will
  # be inserted into automod if the channel has automod enabled.
  isOptedOutOfGlobalBannedWordsList: Boolean!
    @deprecated(reason: "No longer used.")
  # Indicates whether chat is currently restricted to subscribers only.
  isSubscribersOnlyModeEnabled: Boolean!
  # Indicates whether chat is currently enforcing that messages must be reasonably unique
  # from recent messages. Previously known as "r9k mode".
  isUniqueChatModeEnabled: Boolean!
  # requireVerifiedAccount indicates if users must be verified to chat.
  requireVerifiedAccount: Boolean!
  # rules is a list of rules to display to users when joining a chat channel.
  rules: [String!]!
  # The number of seconds a user must wait in between sending chat messages
  # If value is null, slow mode is not enabled.
  slowModeDurationSeconds: Int
}

# User info about the chatter.
type Chatter {
  # User login of the chatter.
  login: String!
}

# Information about the active chatters on a channel.
type ChattersInfo {
  # List with the broadcaster.
  broadcasters: [Chatter!]!
  # Number of active chatters.
  count: Int!
  # List of active moderators.
  moderators: [Chatter!]!
  # List of active staff members.
  staff: [Chatter!]!
  # List of active viewers.
  viewers: [Chatter!]!
  # List of active VIPs.
  vips: [Chatter!]!
}

# ChatTheme is a client-side UI theme.
# It can be used to provide different images based on the dominant background color they are designed to display on.
enum ChatTheme {
  DARK
  LIGHT
}

# Various user specific settings on how to render chat.
type ChatUISettings {
  # Setting to store the user's preferred way to pause chat when moderating.
  chatPauseSetting: ChatPauseSetting
  # Setting for how deleted messages should be displayed for channel broadcaster or moderator.
  deletedMessageDisplaySetting: DeletedMessageDisplaySetting
  # Whether emote animations are enabled.
  isEmoteAnimationsEnabled: Boolean
  # Whether readable chat colors are enabled.
  isReadableChatColorsEnabled: Boolean
  # Whether the emote animations setting callout has been dismissed.
  isEmoteAnimationsSettingCalloutDismissed: Boolean
}

# Actions required when initiating a checkout flow.
enum CheckoutAction {
  # Action to block saved payment methods.
  BLOCK_SAVED_PAYMENT_METHOD
  # Action to show velocity limit CTA.
  EXCEEDED_VELOCITY_LIMITS
  # Action to show the user enabled 2FA before saving their payment method.
  VERIFIED_SAVED_PAYMENT_METHOD
  # Action to disable new credit cards from being added on purchases.
  DISABLE_NEW_CREDIT_CARD
  # Action to disable new credit cards from being added on purchases.
  DISABLE_NEW_DIRECT_DEBIT
  # Action to indicate this user is authorized to make purchases.
  AUTHORIZED_USER
  # Action to indicate xsolla should be prioritized.
  PRIORITIZE_XSOLLA
}

# Configs that help initiate the bits checkout flow.
type CheckoutConfiguration {
  # Contains configuration (e.g. iFrameURL) to enable completing purchases via Xsolla, a payment provider.
  xsolla(
    productType: PurchaseableProductType
    productID: ID
    offerTagBindings: [OfferTagBindingInput!]
    quantity: Int
    giftRecipientIDs: [ID!]
    tenantTracking: String
    paymentSession: PaymentSession
    isDarkMode: Boolean
  ): Xsolla
}

# Inputs for checkoutConfiguration.
input CheckoutConfigurationInput {
  # Whether the gift is anonymous.
  isAnonymous: Boolean
  # Whether the purchase is a gift.
  isGift: Boolean!
  # Whether the user is reactivating their subscription with a recurring or non-recurring payment plan.
  isReactivateRecurring: Boolean
  # The number of gifts being purchased.
  mysteryGiftCount: Int
  # Payment's session tracking.
  paymentSession: PaymentSession
  # The ID of the gift recipient.
  recipientID: ID
  # The country code for tax purposes.
  taxCountryCode: String
}

# Price information about an item in the checkout process.
type CheckoutPriceSummary {
  # The currency associated with the price of a subscription product.
  currency: Currency!
  # The description associated with pricing information.
  description: String!
  # The discounted total with breakdown by discounted price and tax.
  discount: DiscountBreakdown
  # The ISO-4217 wording of deriving price.
  exponent: Int!
  # Identifier used for caching.
  id: ID!
  # If the tax is already included in price.
  isTaxInclusive: Boolean!
  # The numerical price of a subscription product.
  price: Int!
  # Pricing identifier of the item being purchased.
  pricingIdentifier: String!
  # The tax rate of localized product.
  tax: Int!
  # The total price given price and tax.
  total: Int!
}

# CheerInfo is the channel-specific bits/cheer settings and current state.
type CheerInfo {
  # Gets the list of available bits badges the user offers.
  availableBadges: [Badge!]
  # Badge tier emotes are the emotes in this channel that are unlocked when a user unlocks a Bits badge tier.
  # Filter determines which emotes are returned.
  badgeTierEmotes(filter: BadgeTierEmotesFilter!): [Emote]!
  # cheerGroups contain all of the channel-specific Cheermotes, grouped by type.
  cheerGroups: [CheermoteGroup!]!
  # emotes are the metadata about the different cheermotes that can be use to cheer in this channel.
  # This can optionally be filtered to return only certain cheermotes by either prefix and/or emote types.
  # If `prefixes` is null or empty all available cheermotes will be returned, and then `type` filter
  # will be applied to the result unless it's null or empty.
  # If includeUpperTiers is true, the upper tiers of the cheermotes will be returned.
  emotes(
    prefixes: [String!]
    type: [CheermoteType!]
    includeUpperTiers: Boolean
    includeSponsored: Boolean
  ): [Cheermote]!
    @deprecated(reason: "Scheduled to be removed. Use cheerGroups instead")
  # hashtags for augmenting cheering with different actions, such as #charity will donate bits to
  # charity, or like #eddie to cheer and support Eddie.
  hashtags(first: Int = 10, after: String): BitsHashtagConnection
    @deprecated(reason: "Hashtags is no longer a supported feature.")
  id: ID!
  # leaderboard contains the top users by number of bits cheered for the channel.
  leaderboard(first: Int!): BitsLeaderboard
  # recentTimeoutMs is the remaining duration the recent message will be pinned for.
  # This feature is deprecated and will always return 0.
  recentTimeoutMs: Int!
    @deprecated(
      reason: "Recent cheer is a a removed feature, this functionality shouldn't be used anymore."
    )
  # settings are the channel-specific cheer settings.
  settings: CheerSettings!
}

# Cheermote is the metadata about different variations of a single cheermote that can be use to cheer in this channel.
type Cheermote {
  # A nullable campaign associated with the cheermote. This would only be attached to
  # cheermotes that are of the CheermoteType.SPONSORED.
  campaign: CheermoteCampaign
  # The ID of the cheermote.
  id: ID!
  # prefix for this cheering action (Kappa, cheer, Kreygasm, etc).
  # Any case-insensitive match of this prefix directly followed by a number
  # (Kappa100, kappa100, kApPa100, etc) is to be considered a cheering message.
  prefix: String!
  # tiers are bits breakpoints for different images for this cheermote.
  tiers: [CheermoteTier!]!
  # type is the kind of cheermote (custom vs 1st- or 3rd-party global).
  type: CheermoteType!
}

# A campaign that is in association with a cheermote. Like, Old Spice could have a cheermote with
# Terry Crew's head that they will sponsor X Bits that get added on to cheers that use their cheermote.
type CheermoteCampaign {
  # The percentage of remaining bits that can be added to cheers.
  bitsPercentageRemaining: Float!
  # An optional field that shows the user how many bits are being used to sponsor the campaign.
  bitsTotal: Int
  # An optional field that shows the user how many bits have been used out of the sponsored pool.
  bitsUsed: Int
  # Image url for the brand image.
  brandImageURL: String!
  # The name of the brand, used in strings.
  brandName: String!
  # The cheermote campaign ID. This is unique.
  id: ID!
  # The minimum bits amount to make a cheer add bits from the sponsored campaign.
  minimumBitsAmount: Int!
  # The nullable edge that relates the user to the campaign.
  self: CheermoteCampaignSelfEdge
  # Thresholds for matching on sponsored cheering.
  thresholds: [CheermoteCampaignThreshold!]!
  # Amount of bits that an individual user can contribute.
  userLimit: Int!
}

# Edge that relates a cheermote campaign to the logged in user.
type CheermoteCampaignSelfEdge {
  # The total bits used by the user in the campaign.
  bitsUsed: Int!
  # Eligibility for the user to cheer with the sponsored bits in the campaign.
  canBeSponsored: Boolean!
  # The ID is comprised of the campaign ID and the user ID.
  id: ID!
}

# Threshold for sponsored cheermote campaign matching.
type CheermoteCampaignThreshold {
  # Id for threshold, generated using the campaign id and the minimum bits field.
  id: ID!
  # Percentage for matching.
  matchedPercent: Float!
  # Minimum number of bits to get this level of matching.
  minimumBits: Int!
}

# The color that should be used to display each cheer amount.
type CheermoteColorConfig {
  # bits is the minimum number of bits that are required to render this tier.
  # To render at this tier the cheemote must have used >= this minimum but < the next smallest tier.
  bits: Int!
  # color is the hex color used to render the number of bits for this tier.
  color: String!
}

# The CheermoteDisplayConfig provides information about how Cheermotes can be displayed
# This includes things like the possible sizes, colors, backgrounds, and display order.
type CheermoteDisplayConfig {
  # A list of the backgrounds that a Cheermote can be rendered at. For example, ["light", "dark"]
  # Although this is probably more accurately represented as an emum, these strings are going to have to be used
  # when creating the full URL for a Cheermote from the template URL. Rather than forcing each client to create the
  # same enum -> string mapping, we will just pass these directly as strings.
  backgrounds: [String!]!
  # A list of the colors that should be used to display text for each Cheer amount.
  colors: [CheermoteColorConfig!]!
  # A list of the order in which CheermoteTypes should be displayed.
  order: [CheermoteType!]!
  # A list of the scales that a Cheermote can be rendered at. For example,  ["1", "1.5", "2", "3", "4"]
  # Although this is probably more accurately represented as an emum, these strings are going to have to be used
  # when creating the full URL for a Cheermote from the template URL. Rather than forcing each client to create the
  # same enum -> string mapping, we will just pass these directly as strings.
  scales: [String!]!
  # A list of the display types available for Cheermotes.
  types: [CheermoteDisplayType!]!
}

# Information about the methods to display a Cheermote.
type CheermoteDisplayType {
  # The animation style. For example, "static" or "animated"
  # Although this is probably more accurately represented as an emum, these strings are going to have to be used
  # when creating the full URL for a Cheermote from the template URL. Rather than forcing each client to create the
  # same enum -> string mapping, we will just pass these directly as strings.
  animation: String!
  # The extension for this animation style. For example, "png" or "gif"
  # Although this is probably more accurately represented as an emum, these strings are going to have to be used
  # when creating the full URL for a Cheermote from the template URL. Rather than forcing each client to create the
  # same enum -> string mapping, we will just pass these directly as strings.
  extension: String!
}

# Contains a group of related Cheermotes that share the same CDN template.
type CheermoteGroup {
  # The Cheermotes which belong to this group.
  nodes: [Cheermote!]!
  # The template URL that clients can use to construct the image URL for each cheermote tier.
  # The displayConfig field on Query provides values you'll need to fill in this template,
  # so don't forget to request that as well.
  templateURL: String!
}

# CheermoteImage is a single image variation of a `CheermoteTier`.
type CheermoteImage {
  # dpiScale is the scale of the cheermote image.
  # Currently available scales are: 1, 1.5, 2, 3, or 4.
  dpiScale: Float! @deprecated(reason: "Scheduled to be removed.")
  # The ID of CheermoteImage.
  id: ID! @deprecated(reason: "Scheduled to be removed.")
  # isAnimated is true for animated cheermotes and false otherwise.
  isAnimated: Boolean! @deprecated(reason: "Scheduled to be removed.")
  # theme is the UI theme the cheermote is designed to be rendered on.
  theme: ChatTheme! @deprecated(reason: "Scheduled to be removed.")
  # url is the URL of the image asset.
  url: String! @deprecated(reason: "Scheduled to be removed.")
}

# CheermoteTier has information about a single tier of a cheermote.
type CheermoteTier {
  # bits is the minimum number of bits that are required to render this tier.
  # To render at this tier the cheemote must have used >= this minimum but < the next smallest tier.
  bits: Int!
  # Can this cheer tier be used as a cheermote.
  canCheer: Boolean! @deprecated(reason: "Scheduled to be removed.")
  # Can this cheer tier be shown in the Bits card.
  canShowInBitsCard: Boolean!
  # color is the hex color used to render the number of bits for this tier.
  color: String! @deprecated(reason: "Scheduled to be removed.")
  # The ID of CheermoteTier.
  id: ID!
  # images are urls for the cheermote that match various settings.
  # This can optionally be filtered to only certain variations or called without arguments to return all available images.
  images(
    theme: ChatTheme
    isAnimated: Boolean
    dpiScale: Float
  ): [CheermoteImage]! @deprecated(reason: "Scheduled to be removed.")
  # tierID of this specific cheermote icon. For "Kappa100" this will be "100".
  tierID: ID! @deprecated(reason: "Scheduled to be removed.")
}

# The supported cheermote tier thresholds.
enum CheermoteTierThreshold {
  # Cheermote tier threshold requiring at least 1 Bit.
  TIER_1
  # Cheermote tier threshold requiring at least 100 Bits.
  TIER_100
  # Cheermote tier threshold requiring at least 1000 Bits.
  TIER_1000
  # Cheermote tier threshold requiring at least 5000 Bits.
  TIER_5000
  # Cheermote tier threshold requiring at least 10000 Bits.
  TIER_10000
}

# CheermoteToken is used to render a cheermote in a message.
type CheermoteToken {
  # The number of bits in the cheermote.
  bitsAmount: Int!
  # The prefix of the cheermote (e.g. cheer in cheer100).
  prefix: String!
  # The tier of the cheer used to determine which image to show for the cheermote.
  # In cheer150, this would be 100.
  tier: Int!
}

# CheermoteType is the kind of cheermore (custom vs 1st- or 3rd-party global).
enum CheermoteType {
  # The type for the generic "Cheer" action.
  DEFAULT
  # Custom Channel Cheermotes.
  CUSTOM
  # Sponsored Cheermotes.
  SPONSORED
  # Charity Cheermotes.
  CHARITY
  # First Party Cheermotes, like Kappa and BibleThump.
  FIRST_PARTY
  # Third Party Cheermotes, like Muxy and BitBoss.
  THIRD_PARTY
  # Cheermotes for display only. The cannot be cheered, but will be rendered in Chat.
  DISPLAY_ONLY
  # The type for the anonymous cheer action.
  ANONYMOUS
  # Unknown cheermote type, we only return this if we get a bad cheermote,
  # we decided this is better than erroring the whole response, the front end should treat this the same as DISPLAY_ONLY.
  UNKNOWN
}

# Bits partner settings associated with the badges.
type CheerPartnerBadgeSettings {
  # Whether or not the broadcaster is enabled to upload bits badge tier emote rewards.
  canUploadBadgeTierEmoticons: Boolean
  # A list of tiers, starting from 1 bit to as high as 5,000,000 bits.
  tiers: [BitsBadgeTier!]!
}

# Bits partner settings associated with the chat message.
type CheerPartnerChatMessageSettings {
  # The setting that controls if the user has project v enabled on their channel.
  isOptedOutOfProjectV: Boolean!
  # The minimum setting that controls the minimum bits that must be part of a cheer emote.
  minBitsPerEmote: Int!
  # The minimum setting that controls the minimum amount a user must cheer in the channel.
  minBitsToCheer: Int!
}

# Bits partner dashboard settings for the bits cheer bomb events.
type CheerPartnerCheerBombSettings {
  # Flag that is true if the user has opted out of seasonal cheer bomb events.
  isOptedOut: Boolean!
}

# Bits partner settings for custom cheermote prefix.
type CheerPartnerCustomPrefixSettings {
  # Flag that is set if the user has the custom cheermote prefix enabled.
  isEnabled: Boolean!
  # The prefix string that is used in their channel for their custom cheermote.
  prefix: String!
  # The custom prefix images that have been uploaded by the user.
  tiers: [CheermoteTier!]
}

# Bits partner dashboard settings for the bits leaderboard.
type CheerPartnerLeaderboardSettings {
  # Flag that is true if the user has bits leaderboards turned on.
  isEnabled: Boolean!
  # The time period the user wants the leaderboard to be displayed as.
  timePeriod: LeaderboardTimePeriodType!
}

# Bits partner settings associated with recent cheers.
type CheerPartnerRecentCheerSettings {
  # Flag that when true pins the recent cheer to their channel.
  canPin: Boolean!
  # The minimum bits a user must cheer to show their cheer on the chat header.
  minimumBits: Int!
  # The amount of time a recent cheer is shown before being dismissed.
  timeoutMilliseconds: Int!
}

# Cheer settings, configured in their partner dashboard.
type CheerPartnerSettings {
  # Partner settings related to bit badges.
  badges: CheerPartnerBadgeSettings
  # Partner settings related to chat messages with bits.
  chatMessage: CheerPartnerChatMessageSettings!
  # Partner settings related to seasonal cheer bomb events.
  cheerBomb: CheerPartnerCheerBombSettings!
  # Partner settings related to the custom cheermote prefix.
  customPrefix: CheerPartnerCustomPrefixSettings!
  # Flag that is set when a user has filled out the bits legal ammendement.
  # This can be true and isOnboarding false for legacy partners who onboarded before bits.
  hasSignedBitsAmendment: Boolean!
  # An ID used for caching purposes for Apollo.
  id: ID!
  # Flag that is set when a user has been onboarded for bits usage.
  isOnboarded: Boolean!
  # Partner settings related to the bits leaderboard.
  leaderboard: CheerPartnerLeaderboardSettings!
    @deprecated(reason: "Use leaderboard settings in user settings instead.")
  # Partner settings related to the recent cheer message.
  recentCheer: CheerPartnerRecentCheerSettings!
  # Partner settings related to sponsored cheermotes.
  sponsoredCheermotes: CheerPartnerSponsoredCheermoteSettings!
}

# Partner settings related to sponsored cheermotes.
type CheerPartnerSponsoredCheermoteSettings {
  # The sponsored cheermote channel settings that are associated with the user.
  campaigns: SponsoredCheermoteChannelSettingsConnection
}

# CheerSettings are the channel-specific cheer settings.
type CheerSettings {
  # cheerMinimumBits is the minimum number of bits per message (sum of all cheermotes) required to cheer in this channel.
  cheerMinimumBits: Int!
  # emoteMinimumBits is the smallest number of bits that can be spent on an individual cheermote in this channel.
  emoteMinimumBits: Int!
  # event is the name of a special cheering event this channel is currently participating in.
  # If there is no current event this will return null.
  event: String
  id: ID!
  # Indicates if the bits football cheerbomb event is enabled on the channel.
  isCheerBombEventEnabled: Boolean!
  # Indicates if polls is enabled.
  isPollsEnabled: Boolean!
    @deprecated(
      reason: "Unsupported field. Check partner or affiliate status instead of using this field"
    )
  # isRecentEnabled indicates if recent cheers are pinned in this channel.
  # This can be used by a client to update `CheerInfo.recent` as new cheers are received.
  isRecentEnabled: Boolean!
  # isTopEnabled indicates if top cheers are pinned in this channel.
  # This can be used by a client to update `CheerInfo.top` as new cheers are received.
  isTopEnabled: Boolean!
  # leaderboard contains all of the Bits settings related to Bits Leaderboards for this channel.
  leaderboard: BitsLeaderboardSettings
    @deprecated(reason: "Use leaderboard settings in user settings instead.")
  # recentMinimumBits is the number of bits required for a cheer to be pinned.
  recentMinimumBits: Int!
  # recentTimeoutMs is the amount of time a pinned recent message should be displayed for.
  recentTimeoutMs: Int!
}

# An interface to represent a claimable thing.
interface Claimable {
  # A description of what the claimable is.
  description: String!
  # The ID of the claimable.
  id: ID!
  # A field that is populated with relevant information about claiming the object given a valid logged in user.
  self: SelfClaimEdge
  # The type of claimable.
  type: ClaimableType!
}

# The enumerated types of claimables.
enum ClaimableType {
  # A key code that has a bits amount associated with it.
  BITS_KEY_CODE
  # A key code that has a subscription to a product associated with it.
  SUBS_KEY_CODE
  # A key code that has a gift card with monetary value associated with it.
  GIFT_CARD_KEY_CODE
}

# Error code for an error that occurs while claiming the bounty.
type ClaimBountyError {
  # Error code for error that occurred while claiming the bounty.
  code: ClaimBountyErrorCode!
}

# Error types recognized.
enum ClaimBountyErrorCode {
  # Invalid parameter in the request.
  INVALID_PARAMETER
  # User reached the maximum number of bounties.
  BOUNTY_LIMIT_REACHED
  # User already claimed that bounty.
  BOUNTY_ALREADY_CLAIMED
  # The user is not authorized to claim the bounty.
  UNAUTHORIZED
  # Unknown error being returned from service.
  UNKNOWN_ERROR
}

# ClaimBountyInput includes the bounty a user is trying to claim.
input ClaimBountyInput {
  # Unique Identifier for the bounty campaign.
  bountyCampaignID: ID!
  # Unique Identifier for the bounty.
  bountyID: ID!
  # Platform selected by the user to play this bounty's game on.
  platform: String
  # Region selected by the user for the game key.
  region: String
  # UserID of the user that will claim the bounty.
  userID: ID!
}

# Data that was mutated after claiming the bounty.
type ClaimBountyPayload {
  # The claimed bounty with the updated status.
  claimedBounty: Bounty
  # The possible error returned from the service.
  error: ClaimBountyError
  # The user that now has the claimed bounty.
  user: User
}

# An error from claiming community points.
type ClaimCommunityPointsError {
  # An identifier for the error that occurred.
  code: ClaimCommunityPointsErrorCode
}

# The possible reasons a claim could fail.
enum ClaimCommunityPointsErrorCode {
  # The point claim was not found.
  NOT_FOUND
  # The current user is not allowed to claim these points.
  FORBIDDEN
}

# Input for claiming community points.
input ClaimCommunityPointsInput {
  # The channel ID the claim is in.
  channelID: ID!
  # The claim ID.
  claimID: ID!
}

# The response from claiming community points.
type ClaimCommunityPointsPayload {
  # The points claim that was claimed.
  claim: CommunityPointsClaim
  # The user's point balance in the channel, after the claim.
  currentPoints: Int
  # An error that occurred while claiming. If there is an error, the claim did not go through.
  error: ClaimCommunityPointsError
}

# ClaimDropRewardsInput has fields required to claim a drop.
input ClaimDropRewardsInput {
  # dropInstanceID is the unique drop instance to claim.
  dropInstanceID: ID!
}

# ClaimDropRewardsPayload returns the state of the claim.
type ClaimDropRewardsPayload {
  # Summary information for the drop the reward is claimed of.
  drop: DropObject
    @deprecated(reason: "No longer supported. Use dropType instead.")
  # dropInstanceID is the same as the provided input.
  dropInstanceID: ID
  # A single Drop. This could be either an event or time based drop.
  dropType: DropType
  # UserAccountConnected is a boolean specifying if the user has a connected account link to the game the Reward is for.
  isUserAccountConnected: Boolean
  # rewards lists the rewards that were claimed and their statuses.
  rewards: [DropReward!]!
  # status is an enum specifying the status of the claim request.
  status: DropInstanceEligibilityStatus
}

# Hint describing the current availability state of the claim for the user.
enum ClaimHint {
  # We found no existing entitlements for the customer for the offer.
  # The offer is ready for claiming.
  AVAILABLE
  # We found an existing entitlement for the customer, and the currently linked
  # Amazon account is the account on the entitlement.
  # This is preventing a future claim by the querying account.
  CLAIMED_NO_CONFLICTS
  # We found an existing entitlement for the customer, but the currently linked
  # Amazon account is NOT the account on the entitlement.
  # This is preventing a future claim by the querying account.
  CLAIMED_AMAZON_LINK_CONFLICT
  # We found an existing entitlement for one of the accounts for the customer.
  # The existing entitlement is not blocking an additional claim.
  RECLAIMABLE_NO_CONFLICTS
  # We found an existing entitlement linked to the household, but the querying account did not claim it themselves.
  # This is preventing a future claim by the querying account.
  CLAIMED_BY_MEMBER_OF_HOUSEHOLD
  # Customer does not have Twitch Prime.
  # The user needs to sign up before claiming.
  NEED_PRIME
  # The entitlement we found is for a code offer, and we have run out of codes.
  # We may restock codes in the future and will report another claim hint type if so.
  OFFER_FULLY_CLAIMED
  # No valid claim hint was provided.
  # This will also occur when we implement new claim hints but have not yet updated this repo.
  UNKNOWN
}

# Error code for an error that occurs while claiming prime offer.
type ClaimPrimeOfferError {
  # Error code for error that occurred while claiming prime offer.
  code: ClaimPrimeOfferErrorCode!
}

# Error types recognized.
enum ClaimPrimeOfferErrorCode {
  # Status when offer is already claimed by the current user or an associated account.
  OFFER_ALREADY_CLAIMED
  # Unknown error being returned from service.
  UNKNOWN
}

input ClaimPrimeOfferInput {
  # Unique Identifier for an offer.
  offerID: ID!
}

# Data that was mutated after claiming the prime offer, in this case, the entitlement.
type ClaimPrimeOfferPayload {
  # The possible error returned from the service.
  error: ClaimPrimeOfferError
  # The connection for whether the user is entitled to the offer.
  self: PrimeOfferSelfConnection
}

# ClearUnreadFriendRequestsPaylod is the payload returned by ClearUnreadFriendRequests.
type ClearUnreadFriendRequestsPayload {
  # The modified user.
  user: User
}

# The authorization a user has provided to an OAuth client.
type ClientAuthorization {
  # The ID of the client.
  clientID: ID!
  # The name of the client.
  clientName: String
  # The time when the authorization was created.
  createdAt: Time
}

# A recorded, replayable part of a live broadcast.
type Clip {
  # The broadcast of the clip. This should only be used to fetch the ID of the broadcast.
  # Because not all videos have broadcasts (e.g. uploads), not all clips will have a broadcast.
  broadcast: Broadcast
  # The broadcaster from which the clip originated.
  broadcaster: User
  # The curator's clip champ badge if it has been attained on the broadcaster's channel.
  # This has been deprecated and will be always be null.
  champBadge: Badge
    @deprecated(reason: "Clip Champ Badges are no longer being awarded")
  # The time when the clip was created.
  createdAt: Time!
  # Different video qualities are being created in the background.
  # The creation state indicates when the source quality clip is playable
  # and transcoding of the clip in other video qualities has begun.
  creationState: ClipCreationState
  # The user who created the clip.
  curator: User
  # The duration of the clip, in seconds.
  durationSeconds: Int!
  # The URL used in the embed player.
  embedURL: String!
  # The game depicted in the clip.
  game: Game
  # The clip's unique identifier.
  id: ID!
  # Whether or not the clip has been published.
  isPublished: Boolean
  # The language of the clip.
  language: Language!
  # The playback access token that determines whether the user can watch the clip.
  # Fetched for both authed and unauthed users.
  playbackAccessToken(params: PlaybackAccessTokenParams!): PlaybackAccessToken
  # Metadata around the raw media.
  rawMedia: ClipRawMedia!
  # The different quality options of this clip's raw media used for editing.
  rawVideoQualities: [ClipVideoQuality!]
  # The reactions associated with this clips.
  reactions: [Reaction]
  # Lists of related clips based on different algorithms.
  relatedClips: ClipRelatedClips
  # A URL-friendly identifier.
  slug: String!
  # A URL to a thumbnail image.
  # Valid sizes are "86x45", "260x147", and "480x272".
  thumbnailURL(width: Int = 260, height: Int = 147): String!
  # The title of the clip.
  title: String!
  # A URL to the clip's page.
  url: String!
  # The video of the clip. Because not all broadcasts are archived, not all clips will
  # have a video.
  video: Video
  # The number of seconds into a VOD this clip was generated from.
  videoOffsetSeconds: Int
  # The different quality options of this clip available for playback.
  # The clip will first be available in the source video quality, indicated by when the
  # clipCreationState is 'CREATED'. videoQualities will gradually be added to afterwards as
  # more video quality options become playable.
  videoQualities: [ClipVideoQuality!]
  # The number of times this clip has been viewed.
  viewCount: Int!
}

# A list of clips related to the subject.
type ClipConnection {
  # The clips.
  edges: [ClipEdge]
  # Information about pagination in this connection.
  pageInfo: PageInfo
}

# An enumeration on the different status strings returned by a clip status.
enum ClipCreationState {
  # The creating status indicates that the source quality video is still
  # undergoing processing and transcoding.
  CREATING
  # Clip has been successfully created in the source video quality.
  # The field videoQualities will be gradually added to with other quality options.
  CREATED
  # Clip creation failed and will remain in this state.
  # Possible errors can happen due to problems in downloading and slicing
  # the source of the original video, clipping offline channels, transcoding, etc.
  FAILED
}

type ClipEdge {
  # Uniquely identifies this clip's position in a connection.
  cursor: Cursor
  # The clip.
  node: Clip
}

# ClipRawMedia describes metadata about the clip's raw media used in clip editing.
type ClipRawMedia {
  # Default Offset is the seconds into the raw clip media the default clip begins at.
  defaultClipInitialOffset: Float!
  # Total duration of the raw media.
  duration: Float!
  # Total number of frames displayed in the spritesheet film strip.
  filmStripFrames: Int!
  # Seconds covered by each frame in the spritesheet film strip.
  filmStripSecondsPerFrame: Int!
  # Height of the frames displayed.
  frameHeight: Int!
  # Width of the frames displayed.
  frameWidth: Int!
  # Spritesheet displayed to user for clip editing.
  spritesheetURL: String!
  # Status of the clip's raw media.
  status: ClipCreationState!
  # URL link to the video mp4 containing to upwards of 90 seconds of the raw video from which the clip can be created from.
  videoURL: String!
}

# There are different algorithms that return a different set of related clips.
# They only return up to 4 clips per list.
type ClipRelatedClips {
  # Up-to 4  randomly selected, top viewed clips from the same broadcaster created within the last 4 days.
  broadcaster: [Clip!]
  # Up-to 10 clips, in order, combined from the other returned clip sets.
  # Clips are included in the priority of similar, broadcaster, game, and then top.
  combined: [Clip!]
  # Up-to 4  randomly selected, top viewed clips from the same user created within the last 4 days.
  curator: [Clip!]
  # Up-to 4  randomly selected, top viewed clips from the same game created within the last 4 days.
  game: [Clip!]
  # Up-to 4 similar clips, based on the recommendations service.
  # Deprecated: The underlying recommendations service that determined similar clips has been deprecated.
  similar: [Clip!]
    @deprecated(reason: "Similar clips relied on a deprecated backend service.")
  # Up-to 4 randomly selected, top viewed clips created within the last 4 days.
  top: [Clip!]
}

# ClipSegmentInput represents a single segment of a clip.
input ClipSegmentInput {
  # The number of seconds this clip segment encompasses.
  durationSeconds: Float!
  # The offset into the clip's 90 second raw media.
  offsetSeconds: Float!
  # Valid input speeds are 0.25, 0.5, 1.0, 1.5, and 2.0.
  # The segment speed will be set to 1 by default if unspecified.
  speed: Float = 1
}

# The set of methods to restrict clips results.
enum ClipsFilter {
  # Limit results to trending clips.
  TRENDING
  # Limit results to clips created in the period between now and the last 24 hours.
  LAST_DAY
  # Limit results to clips created in the period between now and the last 7 days.
  LAST_WEEK
  # Limit results to clips created in the period between now and the last 30 days.
  LAST_MONTH
  # No limit on clips creation period.
  ALL_TIME
}

# An enumeration on the different time frames to filter clips results based on
# creation time.
enum ClipsPeriod {
  # Limit results to clips created in the period between now and the last 24 hours.
  LAST_DAY
  # Limit results to clips created in the period between now and the last 7 days.
  LAST_WEEK
  # Limit results to clips created in the period between now and the last 30 days.
  LAST_MONTH
  # No limit on when the clips were created.
  ALL_TIME
}

# An enumeration on the different sort orders of clips results.
enum ClipsSort {
  # Sort the clips ascending by created_at.
  CREATED_AT_ASC
  # Sort the clips descending by created_at.
  CREATED_AT_DESC
  # Sort the clips ascending by views.
  VIEWS_ASC
  # Sort the clips descending by views.
  VIEWS_DESC
  # Sort the clips descending by popularity.
  TRENDING
}

# ClipVideoQuality describes metadata about an available playback source for a clip.
type ClipVideoQuality {
  # Frame rate is the number of frames per second of this video.
  # This value is a 64-bit float, with a default value of 30.0,
  # and is used for supporting different playback speeds.
  # Frame rate will be empty for raw media video qualities.
  frameRate: Float
  # Clips can have multiple playback qualities via transcoding.
  # Some examples of qualities include "1080", "720", "480", "360", and "source".
  quality: String!
  # The source video URL for the clip in this specific playback quality.
  sourceURL: String!
}

# CloneExtensionDiscoveryDataError is an error associated with the cloneExtensionDiscoveryData mutation.
enum CloneExtensionDiscoveryDataError {
  # User is unable to clone the extension.
  UNAUTHORIZED
  # Version specified is invalid.
  INVALID_NEW_VERSION
  # The Version to clone from does not exist.
  VERSION_NOT_FOUND
}

# CloneExtensionDiscoveryData copies a given version's discovery data to another version.
input CloneExtensionDiscoveryDataInput {
  # The extension ID of the extension to clone.
  id: ID!
  # The version to clone to.
  newVersion: String!
  # The extension version to clone from.
  version: String!
}

# CloneExtensionDiscoveryDataPayload returns any errors that occur during the copying of the discovery data.
type CloneExtensionDiscoveryDataPayload {
  # The error when the mutation fails to update an extension.
  error: CloneExtensionDiscoveryDataError
  # The updated extension discovery data.
  manifest: ExtensionVersionDiscoveryManifest
}

# CloneExtensionManifestError is an error associated with the cloneExtensionManifest mutation.
enum CloneExtensionManifestError {
  # User is unable to clone the extension.
  UNAUTHORIZED
  # Version specified is invalid.
  INVALID_NEW_VERSION
  # The version to clone to already exists.
  VERSION_ALREDY_EXISTS
  # The Version to clone from does not exist.
  VERSION_NOT_FOUND
}

# CloneExtensionManifest copies the data in a given extension version to a new version.
input CloneExtensionManifestInput {
  # The extension ID of the extension to clone.
  id: ID!
  # The version of the clone.
  newVersion: String!
  # The extension version to clone.
  version: String!
}

# CloneExtensionManifestPayload returns any errors that occur during update and the new manifest.
type CloneExtensionManifestPayload {
  # The error when the mutation fails to update an extension.
  error: CloneExtensionManifestError
  # The updated extension manifest.
  manifest: ExtensionManifest
}

# Represents a cloud broadcast and its state.
type CloudBroadcast {
  # The id of the cloud broadcast.
  id: ID!
  # The status of a cloud broadcast.
  state: CloudBroadcastState!
  # The ingest URI for the broadcast.
  # This is available if the broadcast is in an online state; otherwise null.
  uri: String
}

# A cloud broadcast provider id.
type CloudBroadcastProvider {
  # The supported capabilities of a cloud broadcast.
  capabilities: CloudBroadcastProviderCapabilities
  # The friendly display name of the provider.
  displayName: String!
  # The logical id of the provider, for interacting with providers.
  id: ID!
}

# Capabilities of a cloud broadcast provider.
type CloudBroadcastProviderCapabilities {
  # The maximum supported broadcast framerate for the provider, if available.
  framerate: Int
  # The maximum supported broadcast height for the provider, if available.
  height: Int
  # The ID of the provider associated with the capabilities.
  id: ID!
  # Whether or not if the broadcaster can send broadcasts to the service.
  isAvailable: Boolean!
  # The maximum supported broadcast width for the provider, if available.
  width: Int
}

# A cloud broadcast provider id.
type CloudBroadcastProviderKey {
  # The friendly display name of the provider.
  displayName: String!
  # The logical id of the provider, for interacting with providers.
  id: ID!
}

# Represents the status of a cloud broadcast.
enum CloudBroadcastState {
  # Broadcast is offline and needs to be started.
  OFFLINE
  # Broadcast is pending and currently starting.
  PENDING
  # Broadcast is online and ready.
  ONLINE
  # The broadcast status is unknown.
  UNKNOWN
}

# Collection (a.k.a. Playlist) is a backend concept for a list of videos.
type Collection {
  # The user-supplied description of the collection.
  description: String!
  # The collection's identifier.
  id: ID!
  # The paginated items in the collection. At this time, they will all be VoDs.
  items(first: Int = 10, after: Cursor): CollectionConnection!
  # Total length of the collection as summed from all video lengths.
  lengthSeconds: Int!
  # The owner of the collection.
  owner: User
  # The thumbnailURL for the collection.
  # If either `height` or `width` are not given, a templated value (i.e.
  # `{height}
`, `{width}
`) will be present in the URL instead.
  thumbnailURL(height: Int, width: Int): String
  # The user-supplied title of the collection.
  title: String!
  # The type of collection, either a series or default collection which is ''.
  type: CollectionType!
  # Time when the collection was last updated.
  updatedAt: Time!
  # The total view count of a collection.
  viewCount: Int
}

# A paginated list of videos, and its metadata.
type CollectionConnection {
  # The list of items in this page.
  edges: [CollectionItemEdge]!
  # Information about this page of videos.
  pageInfo: PageInfo!
  # The total number of items in the collection.
  totalCount: Int!
}

# The types of objects that can be contained in a collection.
union CollectionItem = Video
# A page entry, that contains a collection item and a cursor to return
# from the query to allow pagination.
type CollectionItemEdge {
  cursor: Cursor!
  node: CollectionItem!
}

# A Collection input to set options to include all items in a collection.
input CollectionOptions {
  # Include all playlist items including private and deleted items.
  includeAllItems: Boolean = false
}

# These two types allow clients to query for a LIST of COLLECTIONS
# (i.e. a two-dimensional array of videos).
type CollectionsConnection {
  edges: [CollectionsItemEdge]!
  pageInfo: PageInfo!
}

type CollectionsItemEdge {
  cursor: Cursor
  node: Collection!
}

# Options for filtering collections.
input CollectionsOptions {
  # Option to include empty collections.
  includeEmpty: Boolean = false
  # Only return collections that include the given video ID.
  withVideoID: ID
}

# The set of different collection types.
enum CollectionType {
  # Series collection type.
  SERIES
  # Default collection type.
  DEFAULT
}

# An automatic community points reward.
type CommunityPointsAutomaticReward {
  # The background color for the reward icon.
  backgroundColor: String
  # The point cost of this reward.
  cost: Int
  # The default background color for this reward.
  defaultBackgroundColor: String!
  # The default point cost of this reward.
  defaultCost: Int!
  # The default image for this reward.
  defaultImage: CommunityPointsImage!
  # Time that the global template for this reward was last updated in a way that
  # should show a new content indicator to viewers.
  globallyUpdatedForIndicatorAt: Time!
  # The unique identifier of this reward in this channel.
  id: ID!
  # The custom icon for this reward, if any.
  image: CommunityPointsImage
  # Whether this reward is turned on or off in this channel at the moment.
  isEnabled: Boolean!
  # Whether only non-subscribers are allowed to redeem this reward in this channel.
  isHiddenForSubs: Boolean!
  # The lowest the broadcaster is allowed to set the cost of this reward.
  minimumCost: Int!
  # The type of automatic reward this is.
  type: CommunityPointsAutomaticRewardType!
  # Time that this reward was last updated for the channel in a way that should show a new content indicator to viewers.
  # Will be null if the channel hasn't made any updates to override the global settings.
  updatedForIndicatorAt: Time
}

# Types of CommunityPointsAutomaticRewards.
enum CommunityPointsAutomaticRewardType {
  # Send a single message through sub-only mode.
  SINGLE_MESSAGE_BYPASS_SUB_MODE
  # Unlock a random subscriber emote.
  RANDOM_SUB_EMOTE_UNLOCK
  # Unlock a chosen subscriber emote.
  CHOSEN_SUB_EMOTE_UNLOCK
  # Send a highlighted chat message.
  SEND_HIGHLIGHTED_MESSAGE
  # Unlock a chosen modification for a subscriber emote.
  CHOSEN_MODIFIED_SUB_EMOTE_UNLOCK
}

# Information on how points are earned by viewers in a specific channel.
type CommunityPointsChannelEarningSettings {
  # The average number of points per hour earned by a regular (non-sub) user on this channel.
  averagePointsPerHour: Int!
  # The average number of points per hour earned by a subscriber on this channel.
  averagePointsPerHourSubscriber: Int!
    @deprecated(
      reason: "Front-end messaging will update to display base averagePointsPerHour value and multipliers instead."
    )
  # How many points are earned for cheering in a channel.
  cheerPoints: Int!
  # How many minutes will pass in between bonus claims becoming available.
  claimPeriodMinutes: Int!
  # How many points are earned for clicking a bonus claim.
  claimPoints: Int!
  # How many points are earned for following the channel.
  followPoints: Int!
  # A unique identifier.
  id: ID!
  # The possible multipliers users can have on earning points.
  multipliers: [CommunityPointsMultiplier!]!
  # How many minutes must be watched to earn points for passively watching the channel.
  passiveWatchPeriodMinutes: Int!
  # How many points are earned for passively watching the channel.
  passiveWatchPoints: Int!
  # How many points are earned for following a raid by the channel.
  raidPoints: Int!
  # The earning multiplier applied to subscribers to the channel.
  # This multiplier only applies to "watch" and "claim" actions.
  subscriberMultiplier: Float!
    @deprecated(
      reason: "This is the T1 specific multipler value, which is now included in multipliers list."
    )
  # How many points are earned for gifting a subscription in a channel.
  subscriptionGiftPoints: Int!
  # How many points are earned for watching consecutive streams.
  # This list will be sorted from shortest duration to longest duration.
  # Watch streaks beyond the longest duration here will be treated the same as watch streaks of the longest duration.
  watchStreakPoints: [CommunityPointsWatchStreakEarningSettings!]!
}

# Settings for a channel's Community Points.
type CommunityPointsChannelSettings {
  # Archived community goals for this channel.
  archivedGoals(
    first: Int = 10
    after: Cursor
  ): CommunityPointsCommunityGoalConnection
  # Automatic rewards for this channel. If no automatic rewards exist, will be an empty array.
  automaticRewards: [CommunityPointsAutomaticReward!]
  # The default max contribution to a community goal per user per stream.
  communityGoalMaxContributionPerStream: Int!
  # The default small contribution to a community goal.
  communityGoalSmallContribution: Int!
  # Single custom reward by the given id for this channel.
  customReward(id: ID!): CommunityPointsCustomReward
  # Collections of the custom reward templates for this channel.
  customRewardTemplateCollections: [CommunityPointsCustomRewardTemplateCollection!]
  # Custom rewards for this channel. If no custom rewards exist, will be an empty array.
  customRewards: [CommunityPointsCustomReward!]
  # The default image for community points.
  defaultImage: CommunityPointsImage!
  # Properties concerning the user's participation in the Channel Points early access program.
  earlyAccess: CommunityPointsEarlyAccessSettings
    @deprecated(reason: "Early Access period is over.")
  # Information on how points are earned by viewers in this channel.
  earning: CommunityPointsChannelEarningSettings
  # A list of the emote variants (base emote + modifications) that are available for this channel.
  emoteVariants: [CommunityPointsEmoteVariant!]
  # Non-archived community goals for this channel.
  goals(
    includeGoalTypes: [CommunityPointsCommunityGoalType!]
  ): [CommunityPointsCommunityGoal!]
  # The channel's custom community points icon. Null if they have not set an icon.
  image: CommunityPointsImage
  # Whether the channel is allowed to turn community points on now.
  isAvailable: Boolean!
  # Whether the channel will be allowed to turn community points on at full public launch.
  isAvailableAtLaunch: Boolean!
    @deprecated(reason: "Early Access period is over.")
  # Whether the channel has community points turned on now.
  isEnabled: Boolean!
  # Whether the channel will have community points turned on at full public launch.
  isEnabledAtLaunch: Boolean!
    @deprecated(reason: "Early Access period is over.")
  # The channel's custom community points name. Null if they have not set a name.
  name: String
  # The amount of points earned for participating in a raid from the channel.
  raidPointAmount: Int!
    @deprecated(reason: "Should use earning.raidPoints instead")
  # A list of Smart Costs acknowledgements.
  smartCostsAcknowledgements: [SmartCostsAcknowledgement!]
  # A summary of information about unfulfilled redemptions of each custom reward.
  summarizedRewards: [CommunityPointsRewardSummary!]
  # A list of the progress for all ongoing Update Custom Reward Redemption Statuses requests.
  updateCustomRewardRedemptionStatusesProgress: [CommunityPointsUpdateCustomRewardRedemptionStatusesProgress!]
}

# Points that are available for a user to click to claim in a channel.
type CommunityPointsClaim {
  # The claim's unique ID.
  id: ID!
  # The multipliers that will affect this claim.
  # Multipliers start at a base of 1.0, and are additive.
  # Two multipliers of [0.2] and [0.3] will give a final multiplier of 1.5x.
  multipliers: [CommunityPointsMultiplier!]!
  # The baseline points this claim will grant, before applying multipliers.
  pointsEarnedBaseline: Int!
  # The total points this claim will grant.
  pointsEarnedTotal: Int!
}

# Community goal.
type CommunityPointsCommunityGoal {
  # The amount of community points that this goal needs to succeed.
  amountNeeded: Int!
  # The background color of this goal. Should be a hex color string, for example "FF0000".
  backgroundColor: String!
  # The default image of community goals.
  defaultImage: CommunityPointsImage!
  # The description of this goal.
  description: String
  # The *initial* duration the streamer set for the goal.
  # Only really used during the UNSTARTED state; once the goal is started
  # the endedAt timestamp is populated (and updated for extended deadlines).
  durationDays: Int!
  # When the goal ended / will end.
  endedAt: Time
  # The id of the goal.
  id: ID!
  # The image of the goal.
  image: CommunityPointsImage
  # If this goal is available to be contributed to.
  # true when the goal is active and the streamer is live.
  # For MLP, this is just whether the channel is live.
  isInStock: Boolean!
  # The max per stream, per user contribution limit.
  perStreamUserMaximumContribution: Int!
  # The total points contributed to this goal.
  pointsContributed: Int!
  # The small contribution needed to contribute to the goal. Contribution can only be
  # less than this amount if the goal has less than this amount left to complete or if
  # the viewer has less than this amount to be able to contribute.
  smallContribution: Int!
  # When the goal started.
  startedAt: Time
  # The current status of this goal.
  status: CommunityPointsCommunityGoalStatus!
  # The title of this goal.
  title: String!
  # The type of this goal.
  type: CommunityPointsCommunityGoalType!
}

# A paginated list of community goals.
type CommunityPointsCommunityGoalConnection {
  # The list of community goals in this page.
  edges: [CommunityPointsCommunityGoalEdge!]
  # Information about this page of community goals.
  pageInfo: PageInfo!
}

# Community goal contribution.
type CommunityPointsCommunityGoalContribution {
  # The community goal.
  goal: CommunityPointsCommunityGoal!
  # The amount of user's channel points contributed to this community goal this stream.
  userPointsContributedThisStream: Int!
}

# A community goal page entry, contains an item and a cursor.
type CommunityPointsCommunityGoalEdge {
  # Identifies this community goal's position in a connection.
  cursor: Cursor!
  # The community goal.
  node: CommunityPointsCommunityGoal!
}

# Community goal status.
enum CommunityPointsCommunityGoalStatus {
  # Goal was just created.
  UNSTARTED
  # Goal was started.
  STARTED
  # Goal ended.
  ENDED
  # Goal marked fulfilled by streamer.
  FULFILLED
  # Goal archived.
  ARCHIVED
  # Goal status unknown.
  UNKNOWN
}

# Community goal type.
enum CommunityPointsCommunityGoalType {
  # Goal owned by creator.
  CREATOR
  # Community Boost Goal.
  BOOST
  # Goal type unknown.
  UNKNOWN
}

# The different types of content for community points.
enum CommunityPointsContentType {
  # The content type is not understood by GQL.
  UNKNOWN
  # The content type for automatic rewards.
  AUTOMATIC_REWARD
  # The content type for custom rewards.
  CUSTOM_REWARD
}

# A custom community points reward on a channel.
type CommunityPointsCustomReward {
  # The custom background color for this reward. If no background color specified, will be null.
  backgroundColor: String
  # The cooldown expires at field indidicates when reward will be able to be redeemed after the cooldown is set.
  # This field will only have a value if the global cooldown feature is enabled and has been recently redeemed.
  cooldownExpiresAt: Time
  # The point cost of this reward.
  cost: Int!
  # The default image for community points custom rewards.
  defaultImage: CommunityPointsImage!
  # The most rewards of this type that can be redeemed per the global cooldown.
  globalCooldownSetting: CommunityPointsCustomRewardGlobalCooldownSetting!
  # Whether this reward has real world value. Null if the broadcaster has not set this field yet.
  hasRealWorldValue: Boolean
  # The unique identifier for this reward.
  id: ID!
  # The custom image for this reward. If no image exists, will be null.
  image: CommunityPointsImage
  # Whether this reward is enabled in this channel at the moment.
  isEnabled: Boolean!
  # Whether this reward is in stock at the moment.
  # If the reward has already been redeemed the maximum number of times per stream, this will be false.
  isInStock: Boolean!
  # Whether redemptions of this reward are temporarily paused.
  isPaused: Boolean!
  # Whether only subscribers are allowed to redeem this reward in this channel.
  isSubOnly: Boolean!
  # Whether this reward requires users to enter text input.
  isUserInputRequired: Boolean!
  # The most rewards of this type that can be redeemed per stream.
  maxPerStreamSetting: CommunityPointsCustomRewardMaxPerStreamSetting!
  # The most rewards of this type that can be redeemed per user per stream.
  maxPerUserPerStreamSetting: CommunityPointsCustomRewardMaxPerUserPerStreamSetting!
  # The user-facing prompt for this reward. If no prompt exists, will be null.
  prompt: String
  # The value of redemptions of the reward for the current stream.
  # This field will only have a value if the max per user per stream is enabled and has been recently redeemed.
  redemptionsRedeemedCurrentStream: Int
  # Whether redemptions for this reward should skip the broadcaster's request queue and get
  # automatically fulfilled.
  shouldRedemptionsSkipRequestQueue: Boolean!
  # The id for the CustomReward template this reward was created from. Will be null if not created from a template.
  templateID: ID
  # The short title displayed for this reward.
  title: String!
  # Time that this reward was last updated in a way that should show a new content indicator to viewers.
  updatedForIndicatorAt: Time!
}

# Settings for how often a custom reward may be redeemed per stream.
type CommunityPointsCustomRewardGlobalCooldownSetting {
  # The most rewards of this type that can be redeemed per the global cooldown.
  globalCooldownSeconds: Int!
  # Whether the cooldown is being enforced.
  isEnabled: Boolean!
}

# Input for creating and updating a Community Points custom reward's max per stream settings.
input CommunityPointsCustomRewardGlobalCooldownSettingInput {
  # The most rewards of this type that can be redeemed per global cooldown.
  globalCooldownSeconds: Int!
  # Whether the cooldown is being enforced.
  isEnabled: Boolean!
}

# Settings for how often a custom reward may be redeemed per stream.
type CommunityPointsCustomRewardMaxPerStreamSetting {
  # Whether the maximum is being enforced.
  isEnabled: Boolean!
  # The most rewards of this type that can be redeemed per stream.
  maxPerStream: Int!
}

# Input for creating and updating a Community Points custom reward's max per stream settings.
input CommunityPointsCustomRewardMaxPerStreamSettingInput {
  # Whether the maximum is being enforced.
  isEnabled: Boolean!
  # The most rewards of this type that can be redeemed per stream.
  maxPerStream: Int!
}

# Settings for how often a custom reward may be redeemed per stream.
type CommunityPointsCustomRewardMaxPerUserPerStreamSetting {
  # Whether the maximum is being enforced.
  isEnabled: Boolean!
  # The most rewards of this type that can be redeemed per user per stream.
  maxPerUserPerStream: Int!
}

# Input for creating and updating a Community Points custom reward's max per stream settings.
input CommunityPointsCustomRewardMaxPerUserPerStreamSettingInput {
  # Whether the maximum is being enforced.
  isEnabled: Boolean!
  # The most rewards of this type that can be redeemed per user per stream.
  maxPerUserPerStream: Int!
}

# A community points custom reward that has been redeemed in a channel.
type CommunityPointsCustomRewardRedemption {
  # The unique ID of this redemption.
  id: ID!
  # The user-provided text input, if it exists.
  input: String
  # The custom reward that was redeemed.
  reward: CommunityPointsCustomReward
    @deprecated(reason: "Use the 'rewardID' and 'rewardTitle' fields instead.")
  # The unique ID of the reward that was redeemed.
  rewardID: ID!
  # The title of the custom reward that was redeemed, at the time it was redeemed.
  rewardTitle: String!
  # The status of this redemption.
  status: CommunityPointsCustomRewardRedemptionStatus!
  # The time that the reward was redeemed at.
  timestamp: Time!
  # The user that redeemed the reward.
  user: User
}

# A paginated list of Community Points redemptions, and its metadata.
# Only returns results for logged-in, authorized users, otherwise returns a nil response.
type CommunityPointsCustomRewardRedemptionConnection {
  # The list of items in this page.
  edges: [CommunityPointsCustomRewardRedemptionEdge!]!
  # Information about this page of Community Points redemptions.
  pageInfo: PageInfo!
}

# A page entry, that contains a CommunityPointsCustomRewardRedemption item and a cursor to
# return from the query to allow pagination.
type CommunityPointsCustomRewardRedemptionEdge {
  # Cursor used for next query.
  cursor: Cursor!
  # The underlying Community Points redemption.
  node: CommunityPointsCustomRewardRedemption!
}

# Ways to sort Community Points redemptions.
enum CommunityPointsCustomRewardRedemptionQueueSortOrder {
  # The oldest redemption first.
  OLDEST
  # The newest redemption first.
  NEWEST
}

# Possible states for a CommunityPointsCustomRewardRedemption.
enum CommunityPointsCustomRewardRedemptionStatus {
  # A redemption that has not been acted on by the broadcaster.
  UNFULFILLED
  # A redemption that has been fulfilled by the broadcaster.
  FULFILLED
  # A redemption that has been canceled by the broadcaster.
  CANCELED
  # A redemption that has been reported by the broadcaster.
  REPORTED
}

# A template used to create a custom reward.
type CommunityPointsCustomRewardTemplate {
  # The custom background color for a reward created from this template.
  backgroundColor: String!
  # The point cost for a reward created from this template.
  cost: Int!
  # The maximum number of redemptions for the reward created from this
  # template that can be redeemed per the global cooldown.
  globalCooldownSetting: CommunityPointsCustomRewardGlobalCooldownSetting!
  # The unique identifier for this reward template.
  id: ID!
  # The default image for a reward created from this template.
  image: CommunityPointsImage!
  # Whether only subscribers are allowed to redeem the reward created
  # from this template.
  isSubOnly: Boolean!
  # Whether the reward created from this template requires users to enter
  # text input.
  isUserInputRequired: Boolean!
  # The maximum number of redemptions for the reward created from this
  # template that can be redeemed per stream.
  maxPerStreamSetting: CommunityPointsCustomRewardMaxPerStreamSetting!
  # The maximum number of redemptions for the reward created from this
  # template that can be redeemed per user per stream.
  maxPerUserPerStreamSetting: CommunityPointsCustomRewardMaxPerUserPerStreamSetting!
  # The user-facing prompt for the reward created from this template.
  # If no prompt exists, will be null.
  prompt: String
  # Whether redemptions for the reward created from this template should
  # skip the broadcaster's request queue and get automatically fulfilled.
  shouldRedemptionsSkipRequestQueue: Boolean!
  # The short title displayed for the reward created from this template.
  title: String!
}

# A collection of custom reward templates for a category on a channel.
type CommunityPointsCustomRewardTemplateCollection {
  # The category these templated custom rewards are for.
  category: CommunityPointsCustomRewardTemplateCollectionCategory!
  # The templated custom rewards.
  customRewardTemplates: [CommunityPointsCustomRewardTemplate!]!
}

# The possible categories for a collection of custom reward templates.
enum CommunityPointsCustomRewardTemplateCollectionCategory {
  # Unknown category.
  UNKNOWN
  # The templates are for custom rewards that are related to actions in a game.
  GAME
  # The templates are for custom rewards that are related to actions irl.
  IRL
  # The templates are for custom rewards that are related to actions on twitch.
  TWITCH
}

# Custom reward user redemption.
type CommunityPointsCustomRewardUserRedemption {
  # The custom reward.
  reward: CommunityPointsCustomReward!
  # The amount of redempetions per user on this reward during the current stream.
  userRedemptionsCurrentStream: Int!
}

# Properties concerning the user's participation in the Community Points early access program.
type CommunityPointsEarlyAccessSettings {
  # Whether the user is eligible to sign up for Community Points early access.
  canSignUp: Boolean!
  # Whether the user has signed up for Community Points early access.
  isSignedUp: Boolean!
}

# A community points emote.
type CommunityPointsEmote {
  # The emote's identifier.
  id: ID!
  # The text token of the emote.
  token: String!
}

# A community points emote modification.
type CommunityPointsEmoteModification {
  # The modified emote.
  emote: CommunityPointsEmote!
  # Time that the modification was last updated globally in a way that should show a new content indicator to viewers.
  globallyUpdatedForIndicatorAt: Time!
  # The emote modification's identifier.
  id: ID!
  # The modifier of the emote.
  modifier: CommunityPointsEmoteModifier!
  # The dark version of the icon to represent the modification made to the emote.
  modifierIconDark: CommunityPointsImage!
    @deprecated(reason: "Use field in modifier.")
  # The light version of the icon to represent the modification made to the emote.
  modifierIconLight: CommunityPointsImage!
    @deprecated(reason: "Use field in modifier.")
  # The title for the modification.
  title: String! @deprecated(reason: "Use field in modifier.")
}

# A community points emote modifier.
type CommunityPointsEmoteModifier {
  # The dark version of the icon to represent a modification made to an emote.
  iconDark: CommunityPointsImage!
  # The light version of the icon to represent a modification made to an emote.
  iconLight: CommunityPointsImage!
  # The emote modifier's identifier.
  id: ID!
  # The title of the modifier.
  title: String!
}

# A community points emote variant, includes base emote plus modifications.
type CommunityPointsEmoteVariant {
  # The base emote for this variant.
  emote: CommunityPointsEmote!
  # The emote variant's identifier.
  id: ID!
  # Whether community points can be used to unlock the base emote.
  isUnlockable: Boolean!
  # The modifications available to be unlocked for this emote.
  modifications: [CommunityPointsEmoteModification!]!
}

# Image URLs of different sizes for community points rewards.
type CommunityPointsImage {
  # The URL for the small size image.
  url: String!
  # The URL for the medium size image.
  url2x: String!
  # The URL for the large size image.
  url4x: String!
}

# The information required for the client to upload an image for Community Points.
type CommunityPointsImageUploadInfo {
  # The upload ID.
  uploadID: ID!
  # The URL to upload to.
  url: String!
}

# Holds the last time a content type was viewed.
type CommunityPointsLastViewedContentByType {
  # The type of content that was viewed at the lastViewedAt time.
  contentType: CommunityPointsContentType!
  # The time at which the contentType was last viewed. Will be null if the content hasn't been viewed.
  lastViewedAt: Time
}

# Holds the last time a specific piece of content was viewed.
type CommunityPointsLastViewedContentByTypeAndID {
  # A unique identifier for the piece of content based on the type of content dictated by contentType.
  contentID: ID!
  # The type of content that was viewed at the lastViewedAt time.
  contentType: CommunityPointsContentType!
  # The time at which the content was last viewed. Will be null if the content hasn't been viewed.
  lastViewedAt: Time
}

# Availability of limited earn actions for a viewer in a specific channel.
type CommunityPointsLimitedEarnings {
  # Timestamp of when points will become available for cheering on the channel.
  # This will be nil if isCheerAvailable is true and can be nil when isCheerAvailable is false
  # indicating that there is not currently a time in the future when it will become available.
  cheerAvailableAt: Time
  # A unique identifier.
  id: ID!
  # Can the user cheer to get points on the channel.
  isCheerAvailable: Boolean!
  # Can the user follow to get points on the channel.
  isFollowAvailable: Boolean!
  # Can the user gift a subscription in the channel to get points on the channel.
  isSubscriptionGiftAvailable: Boolean!
  # Timestamp of when points will become available for gifting subscriptions on the channel.
  # This will be nil if isSubscriptionGiftAvailable is true and can be nil when isSubscriptionGiftAvailable is false
  # indicating that there is not currently a time in the future when it will become available.
  subscriptionGiftAvailableAt: Time
}

# A multiplier affecting the rate of community points earned for a user in a channel.
type CommunityPointsMultiplier {
  # The multiplying factor being applied.
  # Multipliers start at a base of 1.0, and are additive.
  # Two multipliers of [0.2] and [0.3] will give a final multiplier of 1.5x.
  factor: Float!
  # The reason that the multiplier is being applied.
  reasonCode: CommunityPointsMultiplierReason!
}

# Reasons that community point earning could be multiplied for a user in a channel.
enum CommunityPointsMultiplierReason {
  # Tier-1 Subscriber.
  SUB_T1
  # Tier-2 Subscriber.
  SUB_T2
  # Tier-3 Subscriber.
  SUB_T3
}

# Properties relating to a user's community points in a channel.
type CommunityPointsProperties {
  # Multipliers currently affecting the logged in user's rate of point gaining in this channel.
  # If there are no multipliers active, will be an empty array.
  activeMultipliers: [CommunityPointsMultiplier!]
  # Points that are available for the user to click to claim in this channel. Null if there are no points available to claim.
  availableClaim: CommunityPointsClaim
  # The number of community points this user currently has available to use in this channel.
  balance: Int!
  # Whether the user can redeem rewards on this channel for free.
  # The main example is broadcasters on their own channels.
  canRedeemRewardsForFree: Boolean!
  # The community goal contributions.
  goalContributions: [CommunityPointsCommunityGoalContribution!]
  # Timestamps of when the user last viewed the different types of community points content on the channel.
  lastViewedContent: [CommunityPointsLastViewedContentByType!]
  # Availability of limited earning actions for the user in this channel.
  limitedEarnings: CommunityPointsLimitedEarnings
  # The custom reward user redemptions for the current live stream.
  userRedemptions: [CommunityPointsCustomRewardUserRedemption!]
}

# Optional filters that can be applied to a redemption queue query.
input CommunityPointsRedemptionQueueOptions {
  # The order of the results, either oldest first or newest first.
  order: CommunityPointsCustomRewardRedemptionQueueSortOrder = OLDEST
  # Filter results to only redemptions of this reward.
  rewardID: ID
  # Filter results to only redemptions of this status.
  status: CommunityPointsCustomRewardRedemptionStatus
}

# A summary of information about redemptions of a given custom community points reward.
# Only returns results for logged-in, authorized users, otherwise returns a nil response.
type CommunityPointsRewardSummary {
  # The total number of unfulfilled redemptions of this reward on the channel.
  count: Int!
  # If the count is at the max, the true count could be any number greater than or equal to the count.
  # Clients should indicate that there could be more redemptions than the number indicates.
  # For example, if count = 100 and isCountAtMaximum = true, clients could show "100+".
  isCountAtMaximum: Boolean!
  # The reward being summarized.
  node: CommunityPointsCustomReward!
}

# An error from redeeming an unlock emote Community Points reward.
type CommunityPointsUnlockEmoteError {
  # The error code.
  code: CommunityPointsUnlockEmoteErrorCode!
}

# Possible errors from redeeming an unlock emote Community Points reward.
enum CommunityPointsUnlockEmoteErrorCode {
  # The emote ID provided is for the wrong channel or the wrong type of emote.
  INVALID_EMOTE
  # The user is already entitled to the emote provided.
  EMOTE_ALREADY_ENTITLED
  # The user is entitled to all emotes that would be randomly selected from.
  NO_EMOTES_AVAILABLE
  # The user does not have sufficient points to redeem the reward.
  INSUFFICIENT_POINTS
  # The client is retrying a redemption with a transaction id that has already been redeemed.
  TRANSACTION_ALREADY_COMMITTED
  # The client is retrying a redemption with a transaction id that is currently being redeemed in another request.
  TRANSACTION_IN_PROGRESS
  # The reward cost has changed since the user has tried to redeem it.
  REWARD_COST_MISMATCH
  # The reward is currently disabled.
  REWARD_DISABLED
  # The user is not allowed to redeem this reward on this channel.
  REWARD_FORBIDDEN
  # An unknown error occurred.
  UNKNOWN
}

# Methods for updating community points CustomReward redemption statuses.
enum CommunityPointsUpdateCustomRewardRedemptionStatusesMethod {
  # Unknown method.
  UNKNOWN
  # Statuses for all redemptions for the channel are being updated.
  BY_CHANNEL
  # Statuses for all redemptions for a reward are being updated.
  BY_REWARD
  # Statuses for the provided redemptions are being updated.
  BY_REDEMPTIONS
}

# The type representing Community Points Update Custom Reward Redemption Statuses Progress.
type CommunityPointsUpdateCustomRewardRedemptionStatusesProgress {
  # The channel ID the redemptions are being updated for.
  channelID: ID!
  # Unique identifier for the progress.
  id: ID!
  # The method being used to update the custom reward redemption statuses.
  method: CommunityPointsUpdateCustomRewardRedemptionStatusesMethod!
  # The new status the redemptions are being set to.
  newStatus: CommunityPointsCustomRewardRedemptionStatus!
  # The number of redemptions that have been processed so far.
  processed: Int!
  # The reward ID the redemptions being updated are for.
  # Will only be set if method is BY_REWARD.
  rewardID: ID
  # The total number of redemptions being updated.
  total: Int!
}

# Properties relating to a user's community points across twitch.
type CommunityPointsUserProperties {
  # Timestamps of when the user last viewed the different global pieces of content for community points.
  lastViewedContent: [CommunityPointsLastViewedContentByTypeAndID!]
}

# Settings for how many community points are awarded for a watch streak of a specific duration.
type CommunityPointsWatchStreakEarningSettings {
  # How many points are awarded for a streak of this length.
  points: Int!
  # How long of a streak a user has.
  streakLength: Int!
}

# A company that is on Twitch.
type Company {
  # The bounty board campaigns that the company owns.
  bountyCampaigns(
    campaignID: ID
    status: BountyCampaignStatus
  ): BountyCampaignConnection
  # The brand portal settings for the company.
  brandPortalSettings: BrandPortalSettings
  # ID of the Company in the CurseForge Infrastructure.
  curseCompanyID: ID
  # The estimated viewer reach for the pool of broadcasters this company is considering targeting.
  estimatedBroadcasterViewerReach(
    gameNames: [String!]!
    targetAllBroadcasters: Boolean!
    targetVarietyBroadcasters: Boolean!
    streamLengthSeconds: Int
    targetAllCountries: Boolean = false
    targetAllGames: Boolean = false
    countries: [String!] = []
  ): BroadcasterViewerReach
  # The games associated with the company. Optionally include games that a company can use for Bounty Board
  # campaigns (ie. "Just Chatting" for trailer campaigns).
  games(includeBountyBoardGames: Boolean = false): [Game!]
  # The company's unique identifier.
  id: ID!
  # Legacy Companies need to agree to the Drops Terms.
  isCampaignsEnabled: Boolean!
  # Legacy Companies are required to sign the Contract.
  isContractSigned: Boolean!
  # Indicates if the Company is a Legacy Company from the first iteration of the DevSite.
  isLegacy: Boolean!
  # The human-readable name of the company.
  name: String!
  # Indicates if company is a developer, publisher or other.
  type: OrganizationType!
  # The Company URL for their Corporate Website.
  url: String!
}

# A Competition created by a competition organizer.
type Competition {
  # Banner image for the competition event page.
  bannerImageURL: String
  # The time when a competition organizer cancelled a competition.
  cancelledAt: Time
  # This is the amount of time (in minutes) available for participants to check-in once competition startAt has passed.
  checkInDurationMinutes: Int!
  # The time the competition was created.
  createdAt: Time!
  # Long form text block description for the competition and will be converted to Markdown client-side.
  description: String
  # The time the competition is scheduled to end.
  endAt: Time!
  # The format contains the type and type metadata of the competition. (i.e. single elimination, round robin, etc.).
  format: CompetitionFormat!
  # The game being played in the competition.
  game: Game
  # Unique Competition ID.
  id: ID!
  # Primary artwork for the competition.
  imageURL: String
  # The name of the competition.
  name: String!
  # The competition organizer.
  owner: User
  # The participant-facing points of contact for the competition that only registered participants can see.
  participantOnlyContactInfo: CompetitionContactInfo
  # The type of participant for the competition. e.g. SOLO, TEAM, ...
  participantType: CompetitionParticipantType!
  # Paginated list of participants in the competition.
  participants(first: Int = 10, after: Cursor): CompetitionParticipantConnection
  # A list of phases in the competition.
  phases: [CompetitionPhase!]!
  # Paginated list of players in the competition.
  players(
    first: Int = 10
    after: Cursor
    state: CompetitionPlayerState
  ): CompetitionPlayerConnection
  # Long form text block description that explains the prizing for the competition
  # and will be converted to Markdown client-side.
  prizeDescription: String
  # The public points of contact for the competition that anyone can see.
  publicContactInfo: CompetitionContactInfo
  # The time the competition is scheduled to end registration.
  registrationEndAt: Time!
  # The maximum number of players in a REGISTERED state.
  registrationLimit: Int!
  # The type of a registration for the competition. e.g. OPEN, INVITATIONAL, ...
  registrationType: RegistrationType!
  # Long form text block description that explains the rules for the competition
  # and will be converted to Markdown client-side.
  rulesDescription: String
  # The relationship between the authenticated user and the competition.
  self: CompetitionSelfEdge
  # Paginated, ordered list representing the standings of the competition.
  standings(first: Int = 100, after: Cursor): CompetitionStandingConnection
  # The time the competition is scheduled to start.
  startAt: Time!
  # The state of the tournament.
  state: CompetitionState!
  # The number of players within a single team entity. Must be 1 for solo-type competitions.
  teamSize: Int!
  # Paginated list of teams in the competition.
  teams(first: Int = 10, after: Cursor): CompetitionTeamConnection
  # Link URL to any additional terms and conditions.
  termsURL: String
  # The time the competition was last updated.
  updatedAt: Time!
  # Visibility of the competition.
  visibility: CompetitionVisibilityState!
}

# Enum for fields passing through automod.
enum CompetitionAutomodField {
  # Competition name.
  COMPETITION_NAME
  # Public contact info discord URL.
  PCI_DISCORD
  # Public contact info email.
  PCI_EMAIL
  # Participant only contact info discord URL.
  POCI_DISCORD
  # Participant only contact info email.
  POCI_EMAIL
  # Competition image URL.
  IMAGE_URL
  # Competition banner image URL.
  BANNER_IMAGE_URL
  # Terms URL.
  TERMS_URL
  # Competition description.
  DESCRIPTION
  # Competition rules description.
  RULES
  # Competition prize description.
  PRIZE
  # Player discord username.
  PLAYER_DISCORD_USERNAME
  # Player in game username.
  PLAYER_IN_GAME_USERNAME
  # Team name.
  TEAM_NAME
  # Used when the field is unknown.
  UNKNOWN
}

# Paginated list of Competitions.
type CompetitionConnection {
  # The elements of the list.
  edges: [CompetitionEdge!]!
  # Are there more competitions in the list and what is the cursor.
  pageInfo: PageInfo!
}

# The contact information to contact the organizers for the competition.
type CompetitionContactInfo {
  # Link to Discord server for competition contact purposes.
  discordURL: String
  # Email address point of contact for the competition.
  email: String
}

# Contains information about a Competition's relationship to a given page (connection),
# and the Competition itself.
type CompetitionEdge {
  # Opaque cursor describing this edge's position in the paginated list.
  cursor: Cursor!
  # A competition record in the list of competitons.
  node: Competition!
}

# Information to communicate to the user about an error state.
type CompetitionError {
  # The fields failing to pass automod (on an automod failure).
  automodFailedFields: [CompetitionAutomodField!]
  # The error code.
  code: CompetitionErrorCode!
  # The error message string.
  message: String!
}

# Enum for user errors.
enum CompetitionErrorCode {
  # Used when an argument is missing but was required.
  REQUIRED_ARGUMENT
  # Used when an argument that is passed in is invalid in some way.
  INVALID_ARGUMENT
  # Used when an attempt to add a resource but that resource already exists.
  ALREADY_EXISTS
  # Used when the registration limit on the competition has been reached.
  LIMIT_REACHED
  # Used when a competition field fails to pass automod.
  AUTOMOD_FAILED
  # Used when the error is unknown.
  UNKNOWN
}

# The CompetitionFormat contains the type and type metadata of the competition. (i.e. single elimination, round robin, etc.).
type CompetitionFormat {
  # The details of the format, currently only used for LEADERBOARD type.
  details: FormatTypeDetails
  # The type of the format for the competition.
  type: FormatType!
}

# The competition Image type sent by the user to determine what image is being uploaded to the competition.
enum CompetitionImageType {
  # Banner image for the competition.
  BANNER
  # Thumbnail image for the competition.
  THUMBNAIL
  # Image type is unknown.
  UNKNOWN
}

# Identifiers for the competition image.
type CompetitionImageUpload {
  # ID of the upload.
  id: ID!
  # URL at which clients can access the image.
  url: String!
}

# A Lobby in a phase.
type CompetitionLobby {
  # Lobby ID of lobby to advance the winner to.
  advanceNextLobby: ID
  # Unique lobby ID.
  id: ID!
  # Lobby ID of lobby to advance the loser to.
  lossNextLobby: ID
  # The participants of a lobby, and their scores.
  participants: [CompetitionLobbyParticipant!]
  # The count of reported scores of the lobby.
  reportedScoreCount: Int!
  # The state of the lobby.
  state: LobbyState!
  # The participant who had a higher score, if scores are equal and the lobby is
  # done, the lobby ended in a tie and winner returns null
  winner: CompetitionLobbyParticipant
}

# A CompetitionLobbyParticipant, and its scores, in a lobby.
type CompetitionLobbyParticipant {
  # The detailed participant associated with the lobby participant, can be a Competition Player or Competition Team.
  detailedParticipant: CompetitionParticipant!
  # Unique ID for CompetitionLobbyParticipant.
  id: ID!
  # The score for this participant.
  score: Int
  # Tie breaker points awarded to the participant for this lobby
  tiebreakerScore: Int
}

# The features a user has access to when creating a competition with the Versus product.
type CompetitionOrganizerCapability {
  # The features a user available to them when they are a Competition Organizer.
  # null or [] mean no special permissions are given to this user.
  allowedRegistrationTypes: [RegistrationType!]
  # Can this user upload or attach additional terms of service for a competition.
  canAttachTerms: Boolean
  # Can this user create competitions in Versus.
  canCreateCompetitions: Boolean
  # Can this user change participant statuses (invited -> registered) without participant consent.
  canManageParticipantStatus: Boolean
  # Can this user host a Custom Format competition.
  canUseCustomFormat: Boolean
}

# A CompetitionParticipant is either a CompetitionPlayer who is playing solo or a CompetitionTeam who plays as a team.
union CompetitionParticipant = CompetitionPlayer | CompetitionTeam
# Sorted list of competition participants.
type CompetitionParticipantConnection {
  # The elements of the list.
  edges: [CompetitionParticipantEdge!]!
  # Are there more competition participants and what is the cursor.
  pageInfo: PageInfo!
  # The total amount of competition participants in the competition.
  totalCount: Int!
}

# Contains information about a competition participant relationship to the paginated request,
# and the participant themselves.
type CompetitionParticipantEdge {
  # Opaque cursor describing this edge's position in the paginated list.
  cursor: Cursor!
  # A competition participant record.
  node: CompetitionParticipant!
}

# The participant type signifies whether the competition will be played as team or solo.
enum CompetitionParticipantType {
  # Participants are represented as a team.
  TEAM
  # Participant is represented as solo.
  SOLO
  # Unknown participant type.
  UNKNOWN
}

# A Phase created by a competition organizer.
type CompetitionPhase {
  # Unique phase ID.
  id: ID!
  # The lobbies in a phase.
  lobbies: [CompetitionLobby!]!
  # The state of the phase. It is derived on whether any of the lobbies are actively playing.
  state: PhaseState!
  # For more complex tournaments, the type determines how you progress after a phase.
  type: CompetitionPhaseType
}

# The phase type subdivides phases for more complex tournament types.
enum CompetitionPhaseType {
  # This phase contains participants who have not used their second-chance.
  DOUBLE_ELIMINATION_WINNERS
  # This phase contains participants who have lost a lobby once.
  DOUBLE_ELIMINATION_LOSERS
  # Phase type is not applicable to a phase of this competition type.
  NOT_APPLICABLE
  # Phase type is unknown.
  UNKNOWN
}

# The placement within the competition for an participant.
type CompetitionPlacement {
  # The position in the total participant list a participant ranks.
  position: Int
}

# A player is solo participant in a Competition.
type CompetitionPlayer {
  # Competition ID player is a part of.
  competitionID: ID!
  # The time the player was added.
  createdAt: Time!
  # The discord username for the player.
  discordUsername: String
  # Unique ID for competition player.
  id: ID!
  # The in game username for the player.
  inGameUsername: String
  # Indicates whether the player is disqualified.
  isDisqualified: Boolean!
  # The state a player has in the competition.
  state: CompetitionPlayerState!
  # The associated team the user is part of.
  team: CompetitionTeam
  # The total score for the competition player.
  totalScore: Int!
  # The associated user.
  user: User!
}

# Paginated list of players in a Competition.
type CompetitionPlayerConnection {
  # The elements of the list.
  edges: [CompetitionPlayerEdge!]!
  # Are there more players in the competition and what is the cursor.
  pageInfo: PageInfo!
  # The total amount of players in the competition.
  totalCount: Int!
}

# Contains information about a Players relationship to a given page (connection),
# and the Player themselves.
type CompetitionPlayerEdge {
  # Opaque cursor describing this edge's position in the paginated list.
  cursor: Cursor!
  # A competition record in the list of competitions.
  node: CompetitionPlayer!
}

# The states a player can have in the competition.
enum CompetitionPlayerState {
  # The player has been invited.
  INVITED
  # The player has registered to compete in this competition in the future.
  REGISTERED
  # The player has checked in to compete now.
  CHECKED_IN
  # The player has competed in the competition.
  COMPETED
  # The player has declined the competition.
  DECLINED
  # The player state is unknown.
  UNKNOWN
}

# The relationship between the authenticated user and the competition.
type CompetitionSelfEdge {
  # Whether the user is invited to the competition.
  isInvited: Boolean
  # Whether the user is the owner.
  isOwner: Boolean
  # Whether the user is a player in the competition.
  isPlayer: Boolean
  # Whether the user is registered in the competition.
  isRegistered: Boolean
}

# A single participant's competition standing including score and placement.
type CompetitionStanding {
  # A record of all lobbies (1 per phase) in which the participant has competed.
  history: [HistoricalCompetitionLobby!]
  # The participant whose score and placement are being reported.
  participant: CompetitionParticipant!
  # Placement is a participant's rank in the competition standings.
  placement: CompetitionPlacement!
  # The participant's current score for the competition.
  score: Int
  # Summation of bonus points awarded to a participant.
  tiebreakerScore: Int
  # Percentage of done lobbies the participant has won out of the done lobbies the
  # participant in, if participant is not in any done lobbies this will be null.
  winPercentage: Int
}

# Paginated list of standings for a Competition.
type CompetitionStandingConnection {
  # The elements of the list.
  edges: [CompetitionStandingEdge!]!
  # Are there more standings for the competition and what is the cursor.
  pageInfo: PageInfo!
}

# Contains information about a CompetitionStanding's relationship to a given page (connection),
# and the standing itself.
type CompetitionStandingEdge {
  # Opaque cursor describing this edge's position in the paginated list.
  cursor: Cursor!
  # A competition standing record in the list of competition standings.
  node: CompetitionStanding!
}

# The State of the Competition.
enum CompetitionState {
  # Upcoming competition.
  UPCOMING
  # Past competition.
  PAST
  # Live competition.
  LIVE
  # A competition that's awaiting check-ins.
  CHECK_IN
  # A competition that's ready to be started.
  READY
  # A competition that finished with no conclusion.
  CANCELLED
  # Unknown state.
  UNKNOWN
}

# A Team is scheduled or has competed in a Competition.
type CompetitionTeam {
  # The captain of the team is a Competition Player.
  captain: CompetitionPlayer
  # CompetitionID we are a part of.
  competitionID: ID!
  # Unique ID for competition team.
  id: ID!
  # Indicates whether the team is disqualified.
  isDisqualified: Boolean!
  # The members of the team are Competition Players.
  members: [CompetitionPlayer!]
  # The name of the competition team.
  name: String!
  # The relationship between the authenticated user and the competition team.
  self: CompetitionTeamSelfEdge
  # The total score for the competition team.
  totalScore: Int!
}

# List of competition teams and their scores.
type CompetitionTeamConnection {
  # The elements of the list.
  edges: [CompetitionTeamEdge!]!
  # Are there more teams in the competition and what is the cursor.
  pageInfo: PageInfo!
  # The total amount of teams in the competition.
  totalCount: Int!
}

# Contains information about a Team relationship to a given page (connection),
# and the Team themselves.
type CompetitionTeamEdge {
  # Opaque cursor describing this edge's position in the paginated list.
  cursor: Cursor!
  # A competition team record.
  node: CompetitionTeam!
}

# The relationship between the authenticated user and the competition Team.
type CompetitionTeamSelfEdge {
  # Whether the user is the captain.
  isCaptain: Boolean!
}

# Information to communicate to the user about an error state.
type CompetitionUploadImageError {
  # The error code.
  code: CompetitionUploadImageErrorCode!
  # The error message string.
  message: String!
}

# Enum for user errors.
enum CompetitionUploadImageErrorCode {
  # Used when an argument is missing but was required.
  REQUIRED_ARGUMENT
  # Used when an argument that is passed in is invalid in some way.
  INVALID_ARGUMENT
  # Used when the error is unknown.
  UNKNOWN
}

# The Visibility of the Competition.
enum CompetitionVisibilityState {
  # Private competition.
  PRIVATE
  # Public competition.
  PUBLIC
  # Unknown state.
  UNKNOWN
}

# The required configuration to activate a component extension.
input ComponentActivationInput {
  # The slot name of where the component extension should be displayed.
  slot: String!
  # The horizontal positioning of the left side of the component extension from the left side
  # of the visible video space as a fixed-point percentage (ie: 5742 would represent 57.42 percent).
  x: Int
  # The vertical positioning of the top side of the component extension from the top side
  # of the visible video space as a fixed-point percentage (ie: 5742 would represent 57.42 percent).
  y: Int
}

# The view configuration of an extension if the component anchor is supported.
type ComponentView implements ExtensionView {
  # Specifies the width of a component extension in relation to it's targetHeight and aspectRatioY.
  #
  # NOTE:  targetHeight and aspectRatio will replace aspectHeight and aspectWidth.
  #        however, since both will be used for a short time during the rollout of the new UI,
  #        aspectWidth and aspectHeight will not be deprecated until later.
  aspectRatioX: Int!
  # Specifies the height of a component extension in relation to it's targetHeight and aspectRatioX.
  #
  # NOTE:  targetHeight and aspectRatio will replace aspectHeight and aspectWidth,
  #        however, since both will be used for a short time during the rollout of the new UI,
  #        aspectWidth and aspectHeight will not be deprecated until later.
  aspectRatioY: Int!
  # Specifies whether or not the extension has the ability to link to external websites.
  canLinkExternalContent: Boolean!
  # Specifies whether to automatically scale the extension iframe using css zoom as the video
  # player dimensions change.
  hasAutoscale: Boolean!
  # If Autoscale is true, this indicates the baseline width of the extension.
  # This fields is optional, but is required if hasAutoscale is true.
  scalePixels: Int
  # The percentage of the available space (0-100) (between the top and bottom player controls)
  # that the extension aims to consume.
  #
  # NOTE:  targetHeight and aspectRatio will replace aspectHeight and aspectWidth,
  #        however, since both will be used for a short time during the rollout of the new UI,
  #        aspectWidth and aspectHeight will not be deprecated until later.
  targetHeight: Int!
  # Relative path of the HTML file to load for this view, used by devsite to specify the layout of assets.
  viewerPath: String!
  # The URL which should be loaded in for the extension.
  viewerURL: String!
}

# The view configuration of an extension if the component anchor is supported.
input ComponentViewInput {
  # The developer configured height of the extension as a ratio relative to it's width.
  aspectHeight: Int!
  # The developer configured width of the extension as a ratio relative to it's height.
  aspectWidth: Int!
  # Specifies whether CSS zooming should be applied to the CE container, creating a consistent
  # size of 1024 pixels along the long edge of the component. Default: true.
  hasZoom: Boolean!
  # Size of the long edge of the Component Extension, relative to the length of the corresponding
  # interactable dimension of the video.
  size: Float!
  # Relative path of the HTML file to load for this view.
  viewerPath: String!
  # If hasZoom is set to true, specify the effective CSS zoom to apply to the long edge of the CE.
  # Default: 1024.
  zoomPixels: Int
}

# ConfigView holds the view configuration of an extension if the config page is supported.
type ConfigView implements ExtensionView {
  # Specifies whether or not the extension has the ability to link to external websites.
  canLinkExternalContent: Boolean!
  # Relative path of the HTML file to load for this view, used by devsite to specify the layout of assets.
  viewerPath: String!
  # The URL which should be loaded in for the extension.
  viewerURL: String!
}

# ConfigViewInput holds the view configuration of an extension if the config page is supported.
input ConfigViewInput {
  # Relative path of the HTML file to load for this view.
  viewerPath: String!
}

# ConnectAdIdentityInput accepts a deviceID and other parameters to generate an ad identity for that user.
input ConnectAdIdentityInput {
  # mobile is an optional field that provides mobile device data.
  mobile: MobileAdIdentityInput
  # targetDeviceID is the acting device ID.
  targetDeviceID: ID!
}

# ConnectAdIdentityPayload contains the identity URL.
type ConnectAdIdentityPayload {
  # URL that the client should use to link ad identity.
  identityURL: String
}

# The consent status returned for the current user.
type Consent {
  # The unique identifier of a consent status.
  id: ID!
  # Identifier to determine whether consent is denied due to user underage.
  isDeniedUnderage: Boolean!
  # Privacy law, e.g. CCPA or GDPR.
  privacyLawName: PrivacyLawName!
  # Identifier to determine whether should notification to the user.
  shouldShowNotification: Boolean!
  # Identifier to determine whether should show the consent settings page to the user.
  shouldShowSettingsPage: Boolean!
  # A list of vendor consent status of a user.
  vendorConsentStatus: VendorConsent!
  # A list of vendor consent status of a user.
  vendorStatus: [VendorConsentStatus!]!
    @deprecated(reason: "Use vendorConsentStatus instead")
}

# List of features from GVL https://vendorlist.consensu.org/v2/vendor-list.json.
enum ConsentFeature {
  # Match and combine offline data sources.
  MATCH_COMBINE_OFFLINE_DATA_SOURCES
  # Link different devices.
  LINK_DIFFERENT_DEVICES
  # Receive and use automatiâ€¦tics for identification.
  RECEIVE_USE_AUTO_SENT_DEVICE_CHARACTERISTICS_FOR_IDENTIFICATION
}

# List of purposes from GVL https://vendorlist.consensu.org/v2/vendor-list.json.
enum ConsentPurpose {
  # Store and/or access information on a device.
  STORE_ACCESS_INFO_ON_DEVICE
  # Select basic ads.
  SELECT_BASIC_ADS
  # Create a personalised ads profile.
  CREATE_PERSONALISED_ADS_PROFILE
  # Select personalised ads.
  SELECT_PERSONALISED_ADS
  # Create a personalised content profile.
  CREATE_PERSONALISED_CONTENT_PROFILE
  # Select personalised content.
  SELECT_PERSONALISED_CONTENT
  # Measure ad performance.
  MEASURE_AD_PERFORMANCE
  # Measure content performance.
  MEASURE_CONTENT_PERFORMANCE
  # Apply market research toâ€¦erate audience insights.
  APPLY_MARKET_RESEARCH_TO_GENERATE_AUDIENCE_INSIGHTS
  # Develop and improve products.
  DEVELOP_IMPROVE_PRODUCTS
}

# List of special features from GVL https://vendorlist.consensu.org/v2/vendor-list.json.
enum ConsentSpecialFeature {
  # Use precise geolocation data.
  USE_PRECISE_GEO_DATA
  # Actively scan device chaâ€¦tics for identification.
  ACTIVELY_SCAN_DEVICE_CHARACTERISTICS_FOR_IDENTIFICATION
}

# List of special purposes from GVL https://vendorlist.consensu.org/v2/vendor-list.json.
enum ConsentSpecialPurpose {
  # Ensure security, prevent fraud, and debug.
  ENSURE_SECURITY_PREVENT_FRAUD_DEBUG
  # Technically deliver ads or content.
  TECHNICALLY_DELIVER_ADS_CONTENT
}

# ConsentStatus is the flag to show user gives or denies the consent.
enum ConsentStatus {
  # User gives consent.
  GIVEN
  # User denies consent.
  DENIED
}

# An enumeration on the different content type that enable tagging.
enum ContentType {
  # Clip will enable tagging in v2.
  CLIP
  # User is enabled for tagging in v1.
  USER
  LIVE_CHANNEL @deprecated(reason: "Use 'USER' instead")
  # VOD will enable tagging in v2.
  VOD
  # Games and other stream categories.
  CATEGORY
}

# Contribute community goal error.
type ContributeCommunityPointsCommunityGoalError {
  # The error code.
  code: ContributeCommunityPointsCommunityGoalErrorCode!
}

# Contribute community goal error codes.
enum ContributeCommunityPointsCommunityGoalErrorCode {
  # The goal is not currently redeemable, possibly because stream is not live.
  NOT_CURRENTLY_REDEEMABLE
  # The current user does not have enough points to contribute this amount.
  NOT_ENOUGH_POINTS
  # The community goal was not found.
  NOT_FOUND
  # The current user is not allowed to contribute community points towards community goals for this channel.
  FORBIDDEN
  # The current user has already reached the maximum points contributable per stream.
  MAX_PER_STREAM
  # The current user has a contribution already in progress.
  TRANSACTION_IN_PROGRESS
  # The current user has already completed this transaction.
  DUPLICATE_TRANSACTION
  # The current user is banned.
  USER_BANNED
  # An unknown error occurred.
  UNKNOWN
}

# Contribute community goal input.
input ContributeCommunityPointsCommunityGoalInput {
  # The redemption amount.
  amount: Int!
  # The channel.
  channelID: ID!
  # The id of the community goal.
  goalID: ID!
  # The id of this transaction.
  transactionID: ID!
}

# Contribute community goal payload.
type ContributeCommunityPointsCommunityGoalPayload {
  # The error, if any.
  error: ContributeCommunityPointsCommunityGoalError
}

# Contribute to challenge error.
type ContributeToChallengeError {
  # Code describing the error.
  code: ContributeToChallengeErrorCode!
}

# Contribute to challenge error code.
enum ContributeToChallengeErrorCode {
  # User tried to contribute to a challenge that doesn't exist i.e. there is no indicated challenge at all).
  CHALLENGE_NOT_FOUND
  # User tried to contribute to a challenge that is not active.
  CHALLENGE_NOT_ACTIVE
  # Request is for a channel ID that is invalid (e.g. banned channel, channel doesn't exist).
  INVALID_CHANNEL_ID
  # User's bits balance is too low to perform request (e.g. they only have 10 bits and they request to spend 100).
  INSUFFICIENT_BITS_BALANCE
  # User is not allowed to contribute to the challenge (e.g. they're banned in the channel).
  USER_FORBIDDEN
  # An unknown error occurred.
  UNKNOWN
}

# Inputs for contributing to a challenge.
input ContributeToChallengeInput {
  # The amount of bits being contributed for this challenge.
  bits: Int!
  # The id of the challenge that is being contributed to.
  challengeID: ID!
  # The user id of the contributer.
  userID: ID!
}

# Output from the contribute to challenge mutation.
type ContributeToChallengePayload {
  # The participant object returned by the Contribute to Challenge operation.
  challengeParticipant: ChannelChallengeParticipant
  # If present, there was an error with the request.
  error: ContributeToChallengeError
}

# CookieVendorType is the type of cookie.
enum CookieVendorType {
  # Vendors cookies that are essential.
  ESSENTIAL
  # Vendors cookies that are used for analytics purposes.
  ANALYTICS
  # Vendors cookies that are used for advertising purposes.
  ADVERTISING
}

# A claim filed under a copyright law that a channel has infringed upon a copyholder's rights.
type CopyrightClaim {
  # The id of the claim.
  id: ID!
  # The individual or group who filed a copyright claim.
  claimant: CopyrightClaimant!
  # The work that is claimed to be wrongfully used.
  work: String!
  # The date on which this claim was filed.
  date: Time!
}

# Details about the individual or group who filed a copyright claim.
type CopyrightClaimant {
  # The name of the claim issuer.
  name: String!
  # The email of the claim issuer.
  email: String!
}

# Paginated list of Copyright Claims.
type CopyrightClaimConnection {
  # The elements of the list.
  edges: [CopyrightClaimEdge!]
  # Pagination information.
  pageInfo: PageInfo!
}

# Contact information of the entity submitting a copyright claim.
input CopyrightClaimContact {
  # The relationship that the form submitter has to the affected party.
  relationship: String!
  # The name of the entity that owns the content.
  ownerName: String!
  # The claimant's name.
  claimantName: String!
  # Phone number to contact regarding this copyright claim.
  phoneNumber: String!
  # Contact email address of the entity submitting this form.
  emailAddress: String!
  # Twitch email linked to the logged in user submitting this claim.
  twitchEmail: String!
  # Origin country of the copyright submitter.
  country: String!
  # Origin city of the copyright submitter.
  city: String!
  # Street address of the copyright submitter.
  streetAddress: String!
  # State/Province of the copyright submitter.
  stateOrProvince: String!
  # Zipcode of the copyright submitter.
  zipCode: String!
}

# An edge for Copyright Claim data.
type CopyrightClaimEdge {
  # Opaque cursor describing this edge's position in the paginated list.
  cursor: Cursor!
  # The specific CopyrightClaim that belongs to this edge.
  node: CopyrightClaim!
}

# Information detailing a piece of copyrighted content.
input CopyrightedWork {
  # Description of the work being alledgedly infringed upon.
  description: String!
  # The type of the copyrighted work.
  type: CopyrightedWorkType!
  # URL directing to an example/showing of the copyrighted work.
  url: String!
}

# Copyrighted work Enum Types [video, photo, artwork, music, other].
enum CopyrightedWorkType {
  # The copyrighted work was of type OTHER.
  OTHER
  # The copyrighted work was of type VIDEO.
  VIDEO
  # The copyrighted work was of type IMAGE/PHOTO.
  IMAGE_OR_PHOTO
  # The copyrighted work was of type ARTWORK.
  ARTWORK
  # The copyrighted work was of type MUSIC.
  MUSIC
}

# Timestamp of when the copyright infringment occurred.
input CopyrightTimeOffset {
  # When the start of the timestamp began.
  startTimeSeconds: Int!
  # Optional: provides an end bound to this timestamp.
  endTimeSeconds: Int
}

# Errors for creating emotes.
type CreateArchivedEmoteError {
  # The associated error code.
  code: CreateArchivedEmoteErrorCode!
}

# Possible error codes returned for creating emotes.
enum CreateArchivedEmoteErrorCode {
  # The user cannot own any more emotes of this type.
  USER_OWNED_EMOTE_LIMIT_REACHED
  # Only the channel owner is allowed to upload archived emotes.
  INVALID_OWNER
  # The emote code submitted is unacceptable (contains offensive, banned, or "bad" words, which violates guidelines).
  EMOTE_CODE_UNACCEPTABLE
  # Data for least one of the image sizes is not provided or invalid.
  INCOMPLETE_EMOTE_IMAGE_DATA
  # The emote code suffix submitted contains invalid characters.
  INVALID_CODE_SUFFIX
  # The upload emote image could not be parsed.
  INVALID_IMAGE_UPLOAD
  # The uploaded emote image could not be found.
  EMOTE_IMAGE_NOT_FOUND
  # There were not enough image assets supplied for the selected asset type.
  NOT_ENOUGH_EMOTE_IMAGE_ASSETS
  # There were more image assets supplied than required for the selected asset type.
  TOO_MANY_EMOTE_IMAGE_ASSETS
  # The selected emote asset type was invalid.
  INVALID_EMOTE_ASSET_TYPE
  # The selected emote state was invalid.
  INVALID_EMOTE_STATE
  # There were more emote groups supplied than required for the emote state.
  TOO_MANY_EMOTE_GROUPS
  # A static image asset was not supplied, but is required for the selected asset type.
  EMOTE_MISSING_STATIC_ASSET
  # An animated image asset was not supplied, but is required for the selected asset type.
  EMOTE_MISSING_ANIMATED_ASSET
  # Other errors returned from the service.
  UNKNOWN_ERROR
}

# The data needed to finalize the creation of a non-active (aka archived) Emote.
input CreateArchivedEmoteInput {
  # The type of image asset for the emote.
  assetType: EmoteAssetType
  # The channel's emote prefix and the codeSuffix of the emote put together. This is how the emote is invoked in chat.
  code: String!
  # The custom suffix of the emote code. When appended to the channel's emote prefix this will form the full emote code.
  codeSuffix: String!
  # A list containing the image IDs for all assets needed for the emote.
  imageAssets: [EmoteImageAssetInput!]!
}

# Results of the create emote publish.
type CreateArchivedEmotePayload {
  # The newly created emote if successful.
  emote: Emote
  # Service error, if any.
  error: CreateArchivedEmoteError
}

# A 4xx-level error from the CreateBadgeFlair mutation
type CreateBadgeFlairError {
  # Code describing the cause of the error.
  code: CreateBadgeFlairErrorCode!
  # String containing any relevant error message from Subscriptions.
  message: String!
}

# Error code describing a CreateBadgeFlairError
enum CreateBadgeFlairErrorCode {
  # Channel ID argument was invalid or empty.
  INVALID_CHANNEL_ID
  # Image ID for 1x image was invalid or empty.
  INVALID_FLAIR_IMAGE_1X_ID
  # Image ID for 2x image was invalid or empty.
  INVALID_FLAIR_IMAGE_2X_ID
  # Image ID for 4x image was invalid or empty.
  INVALID_FLAIR_IMAGE_4X_ID
  # Tier value was invalid or empty.
  INVALID_TIER
}

# Input to the CreateBadgeFlair mutation
input CreateBadgeFlairInput {
  # ID of the creator/channel which owns this custom badge flair.
  channelID: ID!
  # The S3 ID of the 1x sized badge, provided to clients by Upload Service. (See the createLoyaltyBadgeUploadConfig mutation).
  image1xID: ID!
  # The S3 ID of the 2x sized badge provided to clients by Upload Service. (See the createLoyaltyBadgeUploadConfig mutation).
  image2xID: ID!
  # The S3 ID of the 4x sized badge provided to clients by Upload Service. (See the createLoyaltyBadgeUploadConfig mutation).
  image4xID: ID!
  # Sub tier which receives access to this flair.
  tier: CreatorBadgeFlairTier!
}

# Payload from the CreateBadgeFlair mutation
type CreateBadgeFlairPayload {
  # Error representing any 4xx-level error, if any.
  error: CreateBadgeFlairError
}

# CreateBitsChallengeConditionForExtensionInput creates a Bits condition on behalf of a user by an extension.
input CreateBitsChallengeConditionForExtensionInput {
  # A list of the different bits recipients and their weighted share of the total bits pool once the condition is satisfied.
  # If this is not defined during condition creation, it must be defined when the condition is satisfied.
  bitsRecipientWeightedShares: [BitsChallengeConditionPoolRecipientWeightedShare!]
  # Description of the condition.
  description: String
  # Whether to disable the condition once it has been satisfied or keep it active.
  disableWhenSatisfied: Boolean!
  # ID of the extension creating the conditional.
  extensionID: ID!
  # ID of the channel where the extension is installed.
  # TODO: change to required once the extension coordinator starts sending this param.
  extensionInstallationChannelID: ID
  # Name of the condition.
  name: String!
  # Time when the condition should time out.
  timeoutAt: Time
}

# CreateBitsChallengeConditionForExtensionPayload returns the new condition that was created.
type CreateBitsChallengeConditionForExtensionPayload {
  # The newly created condition.
  condition: ChallengeCondition
  # If present, there was an error in the request.
  error: CreateChallengeConditionError
}

# CreateBitsChallengeConditionParticipantForExtensionInput creates a Bits
# condition participant on behalf of a user by an extension.
input CreateBitsChallengeConditionParticipantForExtensionInput {
  # Bits quantity to be held pending condition satisfaction.
  bitsAmount: Int!
  # ID of the associated condition.
  conditionID: ID!
  # TUID of condition owner.
  conditionOwnerID: ID!
  # ID of the extension creating the conditionParticipant.
  extensionID: ID!
  # Time in seconds, after which the conditionParticipant is expired and the Bits are released (range: 1-43_200).
  ttlSeconds: Int!
}

# CreateBitsChallengeConditionParticipantForExtensionPayload returns the new condition participant that was created.
type CreateBitsChallengeConditionParticipantForExtensionPayload {
  # The newly created condition participant.
  conditionParticipant: ChallengeConditionParticipant
  # If present, there was an error in the request.
  error: CreateChallengeConditionParticipantError
}

# CreateBountyCampaignInput includes the campaign that is being created.
input CreateBountyCampaignInput {
  # The platforms that the campaign applies to.
  availablePlatforms: [String!]
  # The list of broadcaster IDs to blacklist (if any) for the campaign.
  blacklistedBroadcasters: [ID!]
  # Optional box art URL for the campaign.
  boxArtURL: String
  # The message that will be shown to the broadcaster when they view the campaign.
  broadcasterMessage: String
  # The multiplier for the broadcaster payout rate.
  broadcasterMultiplier: Float!
  # The budget for the campaign in cents.
  budgetCents: Int!
  # The chat Calls to Action for the campaign.
  chatCTAs: [BountyCampaignChatCTAInput!]
  # The ID of the content that the campaign is related to.
  contentID: ID
  # Optional cover URL for the campaign.
  coverURL: String
  # Optional display for the campaign.
  displayName: String
  # When the campaign will end.
  endAt: Time!
  # If the campaing is a promotional campaign.
  isPromotionEligible: Boolean
  # The ID of the organization that the campaign is related to.
  organizationID: ID!
  # If the campaign should allow any game to be played.
  shouldAllowAllGames: Boolean
  # The optional name of the sponsor of the campaign.
  sponsor: String
  # When the campaign will start.
  startAt: Time!
  # Deprecated. How long the broadcaster needs to stream the sponsored content to complete the bounty (in minutes).
  streamLengthMinutes: Int
  # How long the broadcaster needs to stream the sponsored content to complete the bounty (in seconds).
  streamLengthSeconds: Int
  # Flag to target all broadcaters for the campaign.
  targetAllBroadcasters: Boolean
  # Flag to target all countries for the campaign.
  targetAllCountries: Boolean
  # Flag to target all games for the campaign.
  targetAllGames: Boolean
  # The click target of the campaign if it is a promotional campaign.
  targetPromotionalVideoClicks: Int
  # Flag to target variety broadcaters for the campaign.
  targetVarietyBroadcasters: Boolean
  # Targeted countries for the campaign (represented by ISO 3166-1 alpha-2).
  targetedCountries: [String!]
  # Targeted Games (game titles) for the campaign.
  targetedGames: [String!]
  # The title of the campaign.
  title: String!
  # The tracking URLs for this campaign.
  trackingPixels: [TrackingPixelInput!]
  # The type of the campaign.
  type: BountyCampaignType
  # Deprecated, use videos instead. The URL of the video for this campaign.
  videoURL: String
  # The video URLS for the campaign.
  videos: [BountyCampaignVideoInput!]
}

# Data that was mutated after the campaign was created.
type CreateBountyCampaignPayload {
  # The campaign that was created.
  campaign: BountyCampaign
}

# CreateBountyCampaignUploadConfigInput is the input for create bounty campaign upload configuration.
input CreateBountyCampaignUploadConfigInput {
  # The ID of the organization that the campaign is related to.
  organizationID: ID!
  # The image type to be uploaded.
  uploadType: BountyCampaignUploadType!
}

# Returned information about image upload including URL to upload the image to.
type CreateBountyCampaignUploadConfigPayload {
  # Unique identifier for the image.
  imageID: ID
  # Unique identifier for the generated URL.
  uploadID: ID
  # The actual URL to be used by the client to upload the image.
  uploadURL: String
}

# Inputs for creating a new celebration.
input CreateCelebrationInput {
  # Where on the channel page the celebration will show.
  area: CelebrationArea!
  # Channel id to create the celebration on.
  channelID: ID!
  # Length the celebration will play.
  durationMilliseconds: Int!
  # Effect which will show when the celebration triggers (ex Fireworks).
  effect: CelebrationEffect!
  # Threshold which will trigger the celebration (ex: Cheering 100 Bits).
  eventThreshold: Int!
  # Event type which will trigger the celebration (ex: Cheering Bits).
  eventType: CelebrationEventType!
  # Intensity of the celebration.
  # Should be bounded (TBA) value which will determine the spectacle of the celebration.
  intensity: Int!
  # If true, the celebration is enabled.
  isEnabled: Boolean!
}

# Outputs from the create celebration mutation.
type CreateCelebrationPayload {
  # The created celebration.
  celebration: Celebration
  # If present, there was an error with the request.
  error: CelebrationError
}

# Create Challenge Condition error.
type CreateChallengeConditionError {
  # Code describing the error.
  code: CreateChallengeConditionErrorCode!
}

# Create Challenge Condition error code.
enum CreateChallengeConditionErrorCode {
  # User tried to create a condition with a bits recipient that is ineligible to receive bits.
  BITS_RECIPIENT_INELIGIBLE
  # An unknown error occurred.
  UNKNOWN
}

# Create Challenge Condition Participant error.
type CreateChallengeConditionParticipantError {
  # Code describing the error.
  code: CreateChallengeConditionParticipantErrorCode!
}

# Create Challenge Condition Participant error code.
enum CreateChallengeConditionParticipantErrorCode {
  # User tried to create a condition participant with a USE_BITS effect type, but they are ineligible to use bits.
  BITS_BENEFACTOR_INELIGIBLE
  # User tried to create a condition participant with a USE_BITS effect type, but they lacked sufficient bits.
  INSUFFICIENT_BITS_BALANCE
  # User tried to create a condition participant for an inactive condition.
  CONDITION_NOT_ACTIVE
  # User tried to create a condition participant for a non-existent condition.
  CONDITION_NOT_FOUND
  # User tried to create a condition participant with an effect type that is not supported by the associated condition.
  EFFECT_TYPE_UNSUPPORTED_BY_CONDITION
  # An unknown error occurred.
  UNKNOWN
}

# CreateChanletInput creates a chanlet under the given channelID.
input CreateChanletInput {
  # The ID of the channel the chanlet should belong to.
  channelID: ID!
}

# CreateChanletPayload returns the new chanlet that was created.
type CreateChanletPayload {
  # The chanlet that was created.
  chanlet: Channel!
  # The channelID that the chanlet was created under.
  channelID: ID!
}

# CreateClipError is an error associated with the createClip mutation.
type CreateClipError {
  # The associated error code.
  code: CreateClipErrorCode
}

# CreateClipErrorCode contains the possible errors that can occur when creating a clip.
enum CreateClipErrorCode {
  # This channel cannot be clipped.
  CHANNEL_NOT_CLIPPABLE
  # The channel has been banned and cannot be clipped.
  CHANNEL_BANNED
  # User has been banned from the channel and cannot clip.
  USER_BANNED
  # User has been timed out from the channel and cannot clip.
  USER_TIMED_OUT
  # Clip cannot be created because channel is no longer live.
  CHANNEL_NOT_LIVE
  # Clip cannot be created because the request is throttled.
  REQUEST_THROTTLED
  # User does not have permissions and cannot clip.
  USER_RESTRICTED
  # Unknown error.
  UNKNOWN
}

# CreateClipInput creates a clip either from a broadcast or video. If both broadcastID
# and videoID are set, the broadcastID will be preferred.
input CreateClipInput {
  # The ID of the broadcast to create a clip from.
  broadcastID: ID
  # The ID of the broadcaster that the broadcast or video belongs to.
  broadcasterID: ID!
  # The number of seconds into the broadcast or video to create the clip from.
  offsetSeconds: Float!
  # The ID of the video to create a clip from.
  videoID: ID
}

# CreateClipPayload returns the created clip or any error that prevented the clip creation.
type CreateClipPayload {
  # The created clip has all fields execpt for durationSeconds and viewCount.
  clip: Clip
  # The error when a clip fails to create.
  error: CreateClipError
}

# Inputs for creating a new collection.
input CreateCollectionInput {
  # A description of the collection being created.
  description: String
  # The id of the user who will own the collection.
  ownerID: ID!
  # The title of the collection being created.
  title: String!
}

# The response from creating a new collection.
type CreateCollectionPayload {
  # The newly created collection.
  collection: Collection
}

# Create community goal error.
type CreateCommunityPointsCommunityGoalError {
  # The error code.
  code: CreateCommunityPointsCommunityGoalErrorCode!
}

# Create community goal error code.
enum CreateCommunityPointsCommunityGoalErrorCode {
  # Goal already exists.
  DUPLICATE_GOAL
  # Goal title failed automod.
  TITLE_AUTOMOD_FAILED
  # Goal title is invalid.
  TITLE_INVALID
  # Goal description failed automod.
  DESCRIPTION_AUTOMOD_FAILED
  # Goal description is invalid.
  DESCRIPTION_INVALID
  # Goal amount is invalid.
  GOAL_AMOUNT_INVALID
  # Goal duration is invalid.
  DURATION_INVALID
  # Goal background color is invalid.
  BACKGROUND_COLOR_INVALID
  # Too many goals already exists.
  TOO_MANY_GOALS
  # The current user is not allowed to create goals for this channel.
  FORBIDDEN
  # An unknown error occurred.
  UNKNOWN
}

# Create community goal input.
input CreateCommunityPointsCommunityGoalInput {
  # The amount of community points that this goal needs to succeed.
  amountNeeded: Int!
  # The background color of this goal.
  backgroundColor: String!
  # The channel.
  channelID: ID!
  # The description of this goal.
  description: String
  # The *initial* duration the streamer set for the goal.
  # Only really used during the UNSTARTED state; once the goal is started
  # the endedAt timestamp is populated (and updated for extended deadlines).
  durationDays: Int!
  # The title of this goal.
  title: String!
}

# Create community goal payload.
type CreateCommunityPointsCommunityGoalPayload {
  # The error, if any.
  error: CreateCommunityPointsCommunityGoalError
  # The community goal that was created.
  goal: CommunityPointsCommunityGoal
}

# An error from creating a custom Community Points reward in a channel.
type CreateCommunityPointsCustomRewardError {
  # An identifier for the error that occurred.
  code: CreateCommunityPointsCustomRewardErrorCode!
  # On TOO_MANY_REWARDS, the most custom rewards a channel can have.
  maxRewards: Int
}

# The possible reasons creating a custom Community Points reward in a channel could fail.
enum CreateCommunityPointsCustomRewardErrorCode {
  # An unexpected error occurred.
  UNKNOWN
  # The current user is not allowed to create a reward in this channel.
  FORBIDDEN
  # The title failed AutoMod.
  TITLE_AUTOMOD_FAILED
  # The prompt failed AutoMod.
  PROMPT_AUTOMOD_FAILED
  # The cost is invalid. Costs must be greater than 0.
  COST_INVALID
  # The maxPerStream is invalid. maxPerStream must be greater than 0.
  MAX_PER_STREAM_INVALID
  # The channel has too many rewards. An existing reward must be deleted before you can create a new reward.
  TOO_MANY_REWARDS
  # The title is invalid. Titles must not be empty and must be at most 45 characters long.
  TITLE_INVALID
  # A reward with the provided title already exists. Custom reward titles must be unique.
  DUPLICATE_REWARD
  # The background color is invalid. Backgrounds must be a valid hex color, for example "FF0000".
  BACKGROUND_COLOR_INVALID
  # The template id provided is invalid. Template id must be the id for a valid template or null.
  TEMPLATE_INVALID
  # The maxPerUserPerStream is invalid. maxPerUserPerStream must be greater than 0.
  MAX_PER_USER_PER_STREAM_INVALID
  # The globalCooldown is invalid. globalCooldown must be greater tham 0.
  GLOBAL_COOLDOWN_INVALID
}

# Input for creating a custom Community Points reward in a channel.
input CreateCommunityPointsCustomRewardInput {
  # The optional custom background color for this reward.
  # Should be a hex color string, for example "FF0000".
  backgroundColor: String
  # The channel ID that the reward is being created in.
  channelID: ID!
  # The point cost of this reward.
  cost: Int!
  # The length of the global cooldown applied to rewards redeemed of this type.
  globalCooldownSetting: CommunityPointsCustomRewardGlobalCooldownSettingInput
  # Whether only subscribers are allowed to redeem this reward in this channel.
  isSubOnly: Boolean!
  # Whether this reward requires users to enter text input.
  isUserInputRequired: Boolean!
  # The most rewards of this type that can be redeemed per stream.
  maxPerStreamSetting: CommunityPointsCustomRewardMaxPerStreamSettingInput
  # The most rewards of this type that can be redeemed per user per stream.
  maxPerUserPerStreamSetting: CommunityPointsCustomRewardMaxPerUserPerStreamSettingInput
  # The optional user-facing prompt for this reward.
  prompt: String
  # Optional boolean for whether redemptions for this reward should skip the broadcaster's
  # request queue and get automatically fulfilled. Defaults to false.
  shouldRedemptionsSkipRequestQueue: Boolean = false
  # The id for the CustomRewardTemplate this reward is being created from. Null if a template wasn't used.
  templateID: ID
  # The short title displayed for this reward.
  title: String!
}

# The response from creating a custom Community Points reward in a channel.
type CreateCommunityPointsCustomRewardPayload {
  # An error that occurred while creating a custom Community Points reward in a channel.
  error: CreateCommunityPointsCustomRewardError
  # The newly created reward.
  reward: CommunityPointsCustomReward
}

# An error from generating upload info for Community Points images.
type CreateCommunityPointsImageUploadInfoError {
  # An identifier for the error that occurred.
  code: CreateCommunityPointsImageUploadInfoErrorCode
}

# The possible reasons generating upload info for Community Points images could fail.
enum CreateCommunityPointsImageUploadInfoErrorCode {
  # The current user is not allowed to upload images for this channel.
  FORBIDDEN
  # More than one image type was specified in the request.
  MORE_THAN_ONE_TYPE
  # Your provided custom reward ID was not found.
  CUSTOM_REWARD_NOT_FOUND
}

# Input for generating upload info (urls and upload IDs) for uploading Community Points images.
# Channel ID is required. Only one of the other three fields should be set, to indicate what the image is being uploaded for.
input CreateCommunityPointsImageUploadInfoInput {
  # If set, this request is for uploading new images for the given automatic reward.
  automaticRewardType: CommunityPointsAutomaticRewardType
  # The channel ID to upload images for.
  channelID: ID!
  # If set, this request is for uploading new images for the given custom reward.
  customRewardID: ID
  # If set, this request is for uploading new images for the given community goal.
  goalID: ID
  # If set, this request is for uploading new images for the channel Community Points icon.
  icon: Boolean
}

# The response from generating upload info for Community Points images.
type CreateCommunityPointsImageUploadInfoPayload {
  # An error that occurred retrieving upload info for Community Points.
  error: CreateCommunityPointsImageUploadInfoError
  # The upload info (url and upload ID) for the large version of the image.
  uploadInfoLarge: CommunityPointsImageUploadInfo
  # The upload info (url and upload ID) for the medium version of the image.
  uploadInfoMedium: CommunityPointsImageUploadInfo
  # The upload info (url and upload ID) for the small version of the image.
  uploadInfoSmall: CommunityPointsImageUploadInfo
}

# The competition contact info for creates.
input CreateCompetitionContactInfoInput {
  # Link to Discord server for competition contact purposes.
  discordURL: String
  # Email address point of contact for the competition.
  email: String
}

# Create a Competition.
input CreateCompetitionInput {
  # Banner image for the competition event page.
  bannerImageURL: String
  # This is the amount of time (in minutes) available for participants to check-in once competition startAt has passed.
  checkInDurationMinutes: Int!
  # Long form description of the competition.
  description: String
  # The time the competition is scheduled to end.
  endAt: Time!
  # The competition format type (i.e. enum values of LEADERBOARD, ROUND_ROBIN, SINGLE_ELIM etc.).
  formatType: FormatType!
  # The game_id of the game being played in the competition.
  gameID: ID!
  # Primary artwork for the competition.
  imageURL: String
  # The required inputs for leaderboard format.
  leaderboardDetails: CreateCompetitionLeaderboardDetailsInput
  # The name of the competition.
  name: String!
  # Owner of the Competition, or filled in as user making the request.
  ownerID: ID
  # The participant-facing points of contact for the competition that only registered players can see.
  participantOnlyContactInfo: CreateCompetitionContactInfoInput
  # The type of participant for the competition. e.g. SOLO, TEAM, ...
  participantType: CompetitionParticipantType!
  # Long form text block description that explains the prizing for the competition
  # and will be converted to Markdown client-side.
  prizeDescription: String
  # The public points of contact for the competition that anyone can see.
  publicContactInfo: CreateCompetitionContactInfoInput
  # The time the competition is scheduled to end registration.
  registrationEndAt: Time!
  # The maximum number of players in a REGISTERED state. A default value will be set if none is provided.
  registrationLimit: Int = 100
  # The type of a registration for the competition. e.g. OPEN, INVITATIONAL, ...
  registrationType: RegistrationType!
  # Long form text block description that explains the rules for the competition
  # and will be converted to Markdown client-side.
  rulesDescription: String
  # The time the competition is scheduled to start.
  startAt: Time!
  # The state the Competition. Defaults to the UPCOMING state if not specified.
  state: CompetitionState
  # The number of players within a single team entity. Must be 1 for solo-type competitions.
  teamSize: Int!
  # Link URL to any additional terms and conditions.
  termsURL: String
}

# The required inputs for leaderboard format.
input CreateCompetitionLeaderboardDetailsInput {
  # The max participant count for a lobby in phase. Valid values are 1-100.
  lobbyMaxSize: Int!
  # The number of phases to be created for the competition. Valid values are 1-20.
  phaseCount: Int!
  # A label for additional points to resolve a tie.
  tiebreakerLabel: TiebreakerLabel
}

# Data that was mutated after the competition was created.
type CreateCompetitionPayload {
  # The competition that was created.
  competition: Competition
  # Used for competition mutation errors.
  error: CompetitionError
}

# Create new tags associated with CLIP, STREAM, or VOD with contentID.
input CreateContentTagsInput {
  # ID of the channel owning the content.
  authorID: ID!
  # ID of content: Channel ID for Streams, Slugs for Clips, and VOD ids for VODs.
  contentID: ID!
  # Type of content being returned. Can only be of values CLIP, STREAM, or VOD.
  contentType: ContentType!
  # List of tag IDs to be added to the content.
  tagIDs: [ID!]!
}

# Result of mutation is the updated tags.
type CreateContentTagsPayload {
  # Content which tags have been added to.
  content: TaggedContent
}

# An error returned from the createCrowdChant mutation.
type CreateCrowdChantError {
  # Code describing the error.
  code: CreateCrowdChantErrorCode!
}

# Possible error codes from the createCrowdChant mutation.
enum CreateCrowdChantErrorCode {
  # There is already an active chant on the channel. The chant must end before a new
  # Crowd Chant can be created.
  CHANT_ALREADY_ACTIVE
  # The channel is currently not eligible for Crowd Chant participation.
  NOT_ELIGIBLE
  # The current user is not allowed to create a chant in this channel.
  FORBIDDEN
  # User attempted to create a Crowd Chant with restricted content.
  AUTOMOD_FAILED
  # The user's message contained a blocked phrase.
  CHANNEL_SETTINGS
  # The user's message was rejected for another reason- possibly intentionally hidden, such as IP block.
  MESSAGE_REJECTED
  # An unexpected error occurred.
  UNKNOWN
}

# Input for creating a crowd chant in a channel.
input CreateCrowdChantInput {
  # The channel ID that the crowd chant is being created in.
  channelID: ID!
  # The body of the chant.
  text: String!
}

# Payload for creating a crowd chant.
type CreateCrowdChantPayload {
  # If present, there was an error with the request.
  error: CreateCrowdChantError
  # The newly created chant.
  chant: CrowdChant
}

# Error codes for issues that may occur when trying to create a
# new Mosaic layout.
enum CreateDashboardViewMosaicLayoutErrorCode {
  # An unhandled error.
  UNKNOWN
  # User has reached a limit of layouts they can store.
  CUSTOM_LIMIT_EXCEEDED
  # The name argument is required.
  INVALID_ARGUMENT_NAME
  # The userID argument is required.
  INVALID_ARGUMENT_USERID
  # The provided type argument is invalid.
  INVALID_ARGUMENT_TYPE
  # The layout argument is required.
  INVALID_ARGUMENT_LAYOUT
  # The version argument is required.
  INVALID_ARGUMENT_VERSION
  # The channelID argument is required.
  INVALID_ARGUMENT_CHANNELID
  # One or more unspecified aguments are invalid. These are not
  # user-actionable, but might indicate a logic error.
  INVALID_ARGUMENT
}

# Input parameters for creating a new custom mosaic layout,
# such as for Stream Manager, Twitch Studio, etc.
# Requires at least the type and id to be specified.
input CreateDashboardViewMosaicLayoutInput {
  # The channel for which to create a new Mosaic layout.
  channelID: ID!
  # The Mosaic data blob (in string form) representing the new Mosaic layout.
  data: MosaicData!
  # The display name of the new Mosaic layout.
  name: String!
  # The type of Mosaic layout being modified, such as for Twitch Studio,
  # Stream Manager, etc.
  type: ChannelDashboardViewType!
  # The version tag for a Mosaic layout, which can be used for deprecation.
  version: String!
}

# Result of the createDashboardViewMosaicLayout mutation.
type CreateDashboardViewMosaicLayoutPayload {
  # Represents an error when attempting to create a layout, if applicable.
  errorCode: CreateDashboardViewMosaicLayoutErrorCode
  # The the layout that was created.
  layout: ChannelDashboardLayout
}

# CreateDropBenefitInput has fields required to create a drop benefit.
input CreateDropBenefitInput {
  # The redirect URL where a user can link their account.
  accountLinkURL: String!
  # The ID of this benefit object.
  benefitID: ID!
  # The display name of this benefit object.
  benefitName: String!
  # The global limit of how often this benefit can be entitled to a user.
  entitlementLimit: Int!
  # The game that awarded the Drop.
  gameID: ID!
  # Specifies if this reward is considered for a game that is available on iOS.
  isIosAvailable: Boolean
  # The RBAC organization ID of the owner.
  ownerID: ID!
}

# CreateDropBenefitPayload returns the result of the creation.
type CreateDropBenefitPayload {
  # Returns the created Benefit.
  dropBenefit: DropBenefit
  # A mapped error returned by the drops management service.
  error: DropsError
}

# CreateDropCampaignInput has the fields necessary to create a campaign for an RBAC organization.
input CreateDropCampaignInput {
  # The redirect URL where a user can link their account.
  accountLinkURL: String!
  # The type of a campaign defines what type of drops are allowed to be added to the campaign.
  campaignType: CampaignType
  # The description of this campaign.
  description: String!
  # The URL that links to the details / marketing page for this drop.
  detailsURL: String!
  # The date at which this campaign ends and all contained drops end at the latest.
  endAt: Time!
  # The game associated with this campaign.
  gameID: ID!
  # The name of the campaign.
  name: String!
  # This is the Organization ID (RBAC) to determine access / ownership of the campaign and attached drops.
  ownerID: ID!
  # The date at which this campaign starts and all contained drops start the earliest.
  startAt: Time!
}

# CreateDropCampaignyPayload returns the newly created campaign.
type CreateDropCampaignPayload {
  # Returns the created Campaign.
  dropCampaign: DropCampaign
  # error, if there was one.
  # A mapped error returned by the drops management service.
  error: DropsError
}

# Possible errors from CreateDropImageUploadURL.
enum CreateDropImageUploadURLErrorCode {
  # The user does not have permissions to create this type of image for this service.
  USER_UNAUTHORIZED
    @deprecated(
      reason: "Drops 1.0 is deprecated, use Drops 2.0/DropImageUpload instead."
    )
  # There was an issue calling a dependency of this call.
  SERVICE_DEPENDENCY_FAILURE
    @deprecated(
      reason: "Drops 1.0 is deprecated, use Drops 2.0/DropImageUpload instead."
    )
  # An issue not matching any other specific error code.
  UNKNOWN
    @deprecated(
      reason: "Drops 1.0 is deprecated, use Drops 2.0/DropImageUpload instead."
    )
}

# Information needed to generate a URL to upload a drop image to.
input CreateDropImageUploadURLInput {
  # The campaign this image is for if it's of type LINK_NOTIFICATION.
  campaignID: ID
  # The type of image this is.
  imageType: DropImageType!
  # The item ID this image is for if it's of type ITEM.
  itemID: ID
  # The drop service this image will be created for.
  serviceID: ID!
  # The JWT used to verify the request.
  token: String!
}

# Returned information about image upload including URL to upload the image to.
type CreateDropImageUploadURLPayload {
  # Error (if any) from trying to create the upload URL.
  error: CreateDropImageUploadURLErrorCode
    @deprecated(
      reason: "Drops 1.0 is deprecated, use Drops 2.0/DropImageUpload instead."
    )
  # Unique identifier for the generated URL.
  uploadID: ID
    @deprecated(
      reason: "Drops 1.0 is deprecated, use Drops 2.0/DropImageUpload instead."
    )
  # The actual URL to be used by the client to upload the image.
  url: String
    @deprecated(
      reason: "Drops 1.0 is deprecated, use Drops 2.0/DropImageUpload instead."
    )
}

# CreateExtensionClientError is an error associated with the createExtensionClient mutation.
enum CreateExtensionClientError {
  # The specified name was invalid.
  INVALID_NAME
  # The specified name is already taken by another extension or app.
  NAME_IN_USE
}

# CreateExtensionClientInput creates an extension with a given name.
input CreateExtensionClientInput {
  # name is the name of the extension client ID.
  name: String!
  # organizationID is the organization ID that the extension will be binded with in RBAC.
  organizationID: ID
  # redirectURI is the URI that can be used for OAuth login using the extension's client ID.
  redirectURI: String!
}

# CreateExtensionClientPayload returns the created extension ID.
type CreateExtensionClientPayload {
  # The created extension client.
  client: ExtensionClient
  # The error when the mutation fails to create an extension client.
  error: CreateExtensionClientError
}

# CreateExtensionImageUploadInfoError is wrapper for error associated with the createExtensionImageUploadInfo mutation.
type CreateExtensionImageUploadInfoError {
  # Error code.
  code: CreateExtensionImageUploadInfoErrorCode!
  # On TOO_MANY_UPLOAD_DISCOVERY_IMAGE, TOO_MANY_UPLOAD_LOGO_IMAGE
  # ,TOO_MANY_UPLOAD_SCREENSHOT_IMAGE, TOO_MANY_UPLOAD_TASKBAR_IMAGE, the maximum
  # number of specific image allowed (existing + incoming).
  maximum: Int
  # On NOT_ENOUGH_UPLOAD_DISCOVERY_IMAGE, NOT_ENOUGH_UPLOAD_LOGO_IMAGE
  # ,NOT_ENOUGH_UPLOAD_SCREENSHOT_IMAGE, NOT_ENOUGH_UPLOAD_TASKBAR_IMAGE, the
  # minimum number of screenshots allowed (existing + incoming).
  minimum: Int
}

# CreateExtensionImageUploadInfoErrorCode is an error code associated with CreateExtensionImageUploadInfoError.
enum CreateExtensionImageUploadInfoErrorCode {
  # User is unable to make modifications to the extension.
  UNAUTHORIZED
  # Version specified is invalid.
  INVALID_VERSION
  # Not enough discovery image to upload. Must >= 0.
  NOT_ENOUGH_UPLOAD_DISCOVERY_IMAGE
  # Not enough logo image to upload. Must >= 0.
  NOT_ENOUGH_UPLOAD_LOGO_IMAGE
  # Not enough screenshot image to upload. Must >= 0.
  NOT_ENOUGH_UPLOAD_SCREENSHOT_IMAGE
  # Not enough taskbar image to upload. Must >= 0.
  NOT_ENOUGH_UPLOAD_TASKBAR_IMAGE
  # Too many discovery image to upload. Must <= 1.
  TOO_MANY_UPLOAD_DISCOVERY_IMAGE
  # Too many logo image to upload. Must <= 1.
  TOO_MANY_UPLOAD_LOGO_IMAGE
  # Too many screenshot image to upload. Must <= 1.
  TOO_MANY_UPLOAD_SCREENSHOT_IMAGE
  # Too many taskbar image to upload. Must <= 1.
  TOO_MANY_UPLOAD_TASKBAR_IMAGE
}

# Information needed to generate a URL and UploadId to upload extension images to.
input CreateExtensionImageUploadInfoInput {
  # Whether to upload new discovery image.
  discovery: Boolean
  # The extension:version the images are for.
  extensionID: ID!
  # Whether to upload new logo image.
  logo: Boolean
  # Amount of new screenshot image to be uploaded.
  screenshots: Int
  # Whether to upload new taskbar image.
  taskbar: Boolean
}

# Returned information about images upload including URL to upload the image to.
type CreateExtensionImageUploadInfoPayload {
  # Url and UploadId for discovery.
  discovery: ExtensionImageUploadResponse
  # The error when the mutation fails to create upload information.
  error: CreateExtensionImageUploadInfoError
  # Url and UploadId for logo.
  logo: ExtensionImageUploadResponse
  # Urls and UploadIds for screenshots.
  screenshots: [ExtensionImageUploadResponse]
  # Url and UploadId for taskbar.
  taskbar: ExtensionImageUploadResponse
}

# CreateExtensionZipUploadInfoError is an error associated with the createExtensionZipUploadInfo mutation.
enum CreateExtensionZipUploadInfoError {
  # User is unable to make modifications to the extension.
  UNAUTHORIZED
  # Version specified is invalid.
  INVALID_VERSION
}

# Information needed to generate a URL and UploadId to upload extension zip file to.
input CreateExtensionZipUploadInfoInput {
  # The extension:version the zip file is for.
  extensionID: ID!
  # The file name of the zip file.
  filename: String
}

# Returned information about zip file upload including URL to upload the zip to.
type CreateExtensionZipUploadInfoPayload {
  # The error when the mutation fails to upload a zip file.
  error: CreateExtensionZipUploadInfoError
  # Url and UploadId for zip file.
  response: ExtensionZipUploadResponse
}

# Errors for creating follower emotes.
type CreateFollowerEmoteError {
  # The associated error code.
  code: CreateFollowerEmoteErrorCode!
}

# Possible error codes returned for creating follower emotes.
enum CreateFollowerEmoteErrorCode {
  # The user cannot own any more emotes of this type.
  USER_OWNED_EMOTE_LIMIT_REACHED
  # Only the channel owner is allowed to upload follower emotes.
  INVALID_OWNER
  # The emote code submitted is unacceptable (contains offensive, banned, or "bad" words, which violates guidelines).
  EMOTE_CODE_UNACCEPTABLE
  # Data for least one of the image sizes is not provided or invalid.
  INCOMPLETE_EMOTE_IMAGE_DATA
  # The emote code suffix submitted contains invalid characters.
  INVALID_CODE_SUFFIX
  # The upload emote image could not be parsed.
  INVALID_IMAGE_UPLOAD
  # The uploaded emote image could not be found.
  EMOTE_IMAGE_NOT_FOUND
  # There were not enough image assets supplied for the selected asset type.
  NOT_ENOUGH_EMOTE_IMAGE_ASSETS
  # There were more image assets supplied than required for the selected asset type.
  TOO_MANY_EMOTE_IMAGE_ASSETS
  # The selected emote asset type was invalid.
  INVALID_EMOTE_ASSET_TYPE
  # The selected emote state was invalid.
  INVALID_EMOTE_STATE
  # There were more emote groups supplied than required for the emote state.
  TOO_MANY_EMOTE_GROUPS
  # A static image asset was not supplied, but is required for the selected asset type.
  EMOTE_MISSING_STATIC_ASSET
  # An animated image asset was not supplied, but is required for the selected asset type.
  EMOTE_MISSING_ANIMATED_ASSET
  # Other errors returned from the service.
  UNKNOWN_ERROR
}

# The data needed to finalize the creation of a follower Emote.
input CreateFollowerEmoteInput {
  # The type of image asset for the emote.
  assetType: EmoteAssetType
  # The group IDs for the follower emote.  Should initially be an array of length
  # 1, but could span multiple groups in the future.
  groupIDs: [ID!]!
  # The channel's emote prefix and the codeSuffix of the emote put together. This is how the emote is invoked in chat.
  code: String!
  # The custom suffix of the emote code. When appended to the channel's emote prefix this will form the full emote code.
  codeSuffix: String!
  # A list containing the image IDs for all assets needed for the emote.
  imageAssets: [EmoteImageAssetInput!]!
}

# Results of the create follower emote publish.
type CreateFollowerEmotePayload {
  # The newly created emote if successful.
  emote: Emote
  # Service error, if any.
  error: CreateFollowerEmoteError
}

input CreateFriendRequestInput {
  # The authenticated user will send a friend request to the user with an ID equal to targetID.
  targetID: ID!
}

type CreateFriendRequestPayload {
  # The user who is the target of the friend request.
  user: User
}

# Error associated with mutation CreateGameApplication.
type CreateGameApplicationError {
  # Error code.
  code: CreateGameApplicationErrorCode
}

# Client error code.
enum CreateGameApplicationErrorCode {
  # The game has already been owned by another company.
  GAME_HAS_ALREADY_BEEN_OWNED
  # Sumbitting user does not have authorization to create a game application for the organization.
  PERMISSION_DENIED
  # Internal error.
  INTERNAL_ERROR
}

# Input to the CreateGameApplication mutation.
input CreateGameApplicationInput {
  # Company ID.
  companyID: ID!
  # Game ID.
  gameID: ID!
}

# Output from the CreateGameApplication mutation.
type CreateGameApplicationPayload {
  # The possible error returned from service.
  error: CreateGameApplicationError
  # The game application.
  gameApplication: GameApplication
}

# GameID that needs to upload a box art image.
input CreateGameBoxArtUploadURLInput {
  # Game identifier.
  gameID: ID!
}

# URL info that can be used to upload the image.
type CreateGameBoxArtUploadURLPayload {
  # response with non-nullable data.
  response: CreateGameBoxArtUploadURLResponse
}

# URL info that can be used to upload the image.
type CreateGameBoxArtUploadURLResponse {
  # Upload id to be used on the upload request.
  uploadID: ID!
  # URL to be used by the client, to upload the image.
  # NOTE: The image that is uploaded later must be a 600x800px, no larger than 1 MB, JPEG.
  url: String!
}

# CreateLoyaltyBadge creates a new badge with these settings.
input CreateLoyaltyBadgeInput {
  # The channel ID where the badge will be uploaded.
  channelID: ID!
  # The S3 ID of the 1x sized badge.
  image1xID: ID!
  # The S3 ID of the 2x sized badge.
  image2xID: ID!
  # The S3 ID of the 4x sized badge.
  image4xID: ID!
  # The number of months of the badge.
  requiredTenureMonths: Int!
}

# CreateLoyaltyBadgePayload returns the created badge.
type CreateLoyaltyBadgePayload {
  # The created badge.
  badge: LoyaltyBadge
  # A code indicating why the create call failed, if it did.
  errorCode: CreateLoyaltyBadgeResponseCode
}

# A code indicating why the create call failed, if it did.
enum CreateLoyaltyBadgeResponseCode {
  # Only eligible users can create a badge.
  ERR_INVALID_USER
  # The badge image 1x submitted was not valid.
  ERR_INVALID_BADGE_IMAGE_1X_ID
  # The badge image 2x submitted was not valid.
  ERR_INVALID_BADGE_IMAGE_2X_ID
  # The badge image 4x submitted was not valid.
  ERR_INVALID_BADGE_IMAGE_4X_ID
  # The badge tenure submitted was not valid.
  ERR_INVALID_BADGE_REQUIRED_TENURE_MONTHS
  # Badge already exists for this tenure.
  ERR_BADGE_EXISTS
  # User is timed out of badge creation.
  ERR_BADGE_TIMEOUT
  # Unknown error occurred, most likely a server error.
  ERR_UNKNOWN
}

# CreateLoyaltyBadgeUploadConfig creates a config with URL to upload the badge image to.
input CreateLoyaltyBadgeUploadConfigInput {
  # The channel ID where the badge will be uploaded.
  channelID: ID!
  # The size of the badge.
  size: Int!
}

# CreateLoyaltyBadgeUploadConfigPayload returns the badge upload config.
type CreateLoyaltyBadgeUploadConfigPayload {
  # A code indicating why the config call failed, if it did.
  errorCode: CreateLoyaltyBadgeUploadConfigResponseCode
  # The badge upload config.
  uploadConfig: LoyaltyBadgeUploadConfig
}

# A code indicating why the config call failed, if it did.
enum CreateLoyaltyBadgeUploadConfigResponseCode {
  # Only eligible users can create a badge upload config.
  ERR_INVALID_USER
  # The badge submitted was not valid.
  ERR_INVALID_BADGE_SIZE
  # Unknown error occurred, most likely a server error.
  ERR_UNKNOWN
}

# The required input to create a moderator comment on a channel.
input CreateModeratorCommentInput {
  # The channel where the moderator comment was created.
  channelID: ID!
  # The target of the moderator comment.
  targetID: ID!
  # The body of the comment.
  text: String!
}

# Result of a createModeratorComment mutation.
type CreateModeratorCommentPayload {
  # The moderator comment created.
  comment: ModLogsComment
}

# Input for creating a new highlight with multi-segment support.
input CreateMultiVideoHighlightInput {
  # Metadata used to create the highlight.
  metadata: CreateMultiVideoHighlightMetadata!
}

# Metadata to describe the requested highlight to be created.
input CreateMultiVideoHighlightMetadata {
  # The ID of the user who created this highlight.
  creatorID: ID!
  # The long form description of the Highlight content.
  description: String!
  # The primary game featured in the highlight, if any.
  game: ID
  # List of ordered time ranges from the source VOD used to create the highlight.
  highlightRanges: [HighlightRange!]!
  # The language the highlight content is in.
  language: String!
  # Discovery tags to associate with the Highlight.
  tags: [String!]!
  # The title of the the highlight.
  title: String!
}

# Response of highlight creation, the new highlight entering the creation process.
type CreateMultiVideoHighlightPayload {
  # The created Video representing the Highlight.
  highlight: Video
}

# Contains the channel ID to create new image upload URL for.
input CreateMultiviewContentAttributeImageUploadConfigInput {
  # The channel for which the content attribute belongs to.
  channelID: ID!
}

# Payload contains the upload ID and URL, as well as the URL to access the uploaded image.
type CreateMultiviewContentAttributeImageUploadConfigPayload {
  # The channel for which the content attribute belongs to.
  channel: Channel
  # The URL to access this image once uploaded.
  imageURL: String!
  # Generated unique identifier for this upload.
  uploadID: ID!
  # Generated unique URL to upload the image to.
  uploadURL: String!
}

# Contains a list of new content attributes to be created.
input CreateMultiviewContentAttributesInput {
  # params is a list of multi-view content attribute params for creating new records.
  params: [MultiviewContentAttributeParams!]!
}

# Contains the results from the create request.
type CreateMultiviewContentAttributesPayload {
  # Unprocessed content attributes.
  failedCreates: [MultiviewContentAttribute!]!
  # Processed content attributes.
  succeededCreates: [MultiviewContentAttribute!]!
}

# Error associated with mutation CreateGameApplication.
type CreateOrganizationApplicationError {
  # Error code.
  code: CreateOrganizationApplicationErrorCode
}

# Client error code.
enum CreateOrganizationApplicationErrorCode {
  # Internal error.
  INTERNAL_ERROR
  # Invalid Argument.
  INVALID_ARGUMENT
  # Organization already exists.
  ALREADY_EXISTS
}

# Input to the CreateOrganizationApplication mutation.
input CreateOrganizationApplicationInput {
  # City the applying Organization is located in. e.g. San Fransico.
  city: String
  # Email of the person creating the application.
  # Deprecated as we are no longer collecting contact email. Using TwitchID and Dart to send notifications instead.
  contactEmail: String
  # First Name of person creating the application.
  contactFirstName: String!
  # Last Name of the person creating the application.
  contactLastName: String!
  # Title of the person creating the application. e.g. Director of Sales.
  contactTitle: String!
  # Country the applying organization is located in. e.g. US.
  country: String!
  # List of game IDs that belong to the applying organization.
  gameIDs: [ID!]
  # Industry the applying organization is operating in e.g. e-sports, gaming, health care, energy.
  industry: String!
  # Reason for wanting to add the organization.
  joinReason: String
  # The name of applying organization.
  organizationName: String!
  # Indicate which Twitch products the organization wants to manage; e.g. creating
  # Drops, managing game box art, accessing game Insights.
  productInterest: String
  # Estimated size of the applying organization. e.g. 1-5, 6-20, 21-50, 51-100, 101-1000, and 1000+.
  size: String!
  # State the applying organization is located in. e.g. CA.
  state: String
  # The type of work the applying organization does.
  type: OrganizationType!
  # The Twitch ID for the user submitting the applicaton.
  # Deprecated as the userID now comes off the authenticated user.
  userID: ID
  # The website address for the applying organization.
  website: String!
}

# Output from the CreateGameApplication mutation.
type CreateOrganizationApplicationPayload {
  # The organization application id.
  applicationID: ID
  # The possible error returned from service.
  error: CreateOrganizationApplicationError
}

# CreateOrganizationInviteError is the error associated with a CreateOrganizationInvite.
type CreateOrganizationInviteError {
  # The associated error code.
  code: CreateOrganizationInviteErrorCode!
}

# CreateOrganizationInviteErrorCode defines a client error that occurred while creating an organization Invite.
enum CreateOrganizationInviteErrorCode {
  # Internal error.
  INTERNAL_ERROR
  # Invalid Argument.
  INVALID_ARGUMENT
  # Organization Invite already exists.
  ALREADY_EXISTS
  # User does not have permission to perform action.
  PERMISSION_DENIED
  # The user does not exist.
  USER_NOT_FOUND
  # The user doesn't meet the requirements to have this role. For example, when trying to assign the
  # "BILLING_MANAGER" role, but the user doesn't have 2FA enabled or completed Extension Monetization Onboarding.
  MEMBER_INELIGIBLE
}

# Inputs to the CreateOrganizationInvite mutation.
input CreateOrganizationInviteInput {
  # The Twitch ID of user being invited to join the organization.
  inviteeTwitchID: ID!
  # The Twitch ID of user being doing the inviting and is already a member of the organization.
  inviterTwitchID: ID!
  # The ID of the organization.
  organizationID: ID!
  # The Role a Invite has in an organization.
  role: OrganizationMemberRole!
}

# Outputs from the CreateOrganizationInvite mutation.
type CreateOrganizationInvitePayload {
  # The possible error returned from the service.
  error: CreateOrganizationInviteError
  # The created invite. returned on successful creation.
  invite: OrganizationInvite
}

# CreateOrganizationJWTError is the error associated with a CreateOrganizationJWT.
type CreateOrganizationJWTError {
  # The associated error code.
  code: CreateOrganizationJWTErrorCode!
}

# CreateOrganizationJWTErrorCode defines a client error that occurred while creating Organization JWT.
enum CreateOrganizationJWTErrorCode {
  # User does not have permission to create the JWT for this operation and company.
  PERMISSION_DENIED
  # The operation passed in was invalid.
  INVALID_ARGUMENT
}

# Inputs to the CreateOrganizationJWT mutation.
input CreateOrganizationJWTInput {
  # Operation to be used in drops to get a jwt for.
  operation: String!
  # Organization id for which to generate the jwt.
  organizationID: ID!
}

# Outputs from the CreateOrganizationJWT mutation.
type CreateOrganizationJWTPayload {
  # The possible error returned from the service.
  error: CreateOrganizationJWTError
  # The new orgnizationJWT.
  jwt: String
}

# CreateOrganizationMemberError is the error associated with a CreateOrganizationMember.
type CreateOrganizationMemberError {
  # The associated error code.
  code: CreateOrganizationMemberErrorCode!
}

# CreateOrganizationMemberErrorCode defines a client error that occurred while creating an organization member.
enum CreateOrganizationMemberErrorCode {
  # Organization Member already exists.
  ALREADY_EXISTS
  # User does not have permission to perform action.
  PERMISSION_DENIED
  # The user does not exist.
  USER_NOT_FOUND
  # The user doesn't meet the requirements to have this role. For example, when trying to assign the
  # "BILLING_MANAGER" role, but the user doesn't have 2FA enabled or completed Extension Monetization Onboarding.
  MEMBER_INELIGIBLE
}

# Inputs to the CreateOrganizationMember mutation.
input CreateOrganizationMemberInput {
  # Users email.
  email: String!
  # Users first name.
  firstName: String!
  # Users last name.
  lastName: String!
  # The ID of the organization.
  organizationID: ID!
  # The Role a member has in an organization.
  role: OrganizationMemberRole!
  # Users title.
  title: String!
  # The user's Twitch ID.
  userID: ID!
}

# Outputs from the CreateOrganizationMember mutation.
type CreateOrganizationMemberPayload {
  # The possible error returned from the service.
  error: CreateOrganizationMemberError
  # The new orgnizationMember.
  organizationMember: OrganizationMember
}

# The upload info struct that is returned from AWS.
type CreatePanelImageUploadInfo {
  # A unique identifier for the generated URL.
  uploadID: ID!
  # The actual URL to be used by the client to upload the image.
  url: String!
}

# Information required to generate a URL to upload a panel image to.
input CreatePanelImageUploadInfoInput {
  # The channel the panel belongs to.
  channelID: ID!
  # The cropped height of the image.
  height: Int!
  # The left edge of the cropped image.
  left: Int!
  # The top edge of the cropped image.
  top: Int!
  # The cropped width of the image.
  width: Int!
}

# The response resulting from a successful panel image URL creation.
type CreatePanelImageUploadInfoPayload {
  # The upload info struct that is returned from AWS.
  uploadInfo: CreatePanelImageUploadInfo
}

# CreatePanelInput contains a panel with created data
# The schema here has arguments for both extension panels and default panels
# each panel needs a PanelType, and channelID it corresponds to,
# but each panel does not need the other arguments
# extension panels can have a slotID
# default panels can have a title, image, link, and/or description.
input CreatePanelInput {
  channelID: ID!
  description: String
  imageURL: String
  linkURL: String
  slotID: String
  title: String
  type: PanelType!
}

# CreatePanelPayload contains the panel data after the create succeeds.
type CreatePanelPayload {
  panel: Panel!
}

# CreatePartnershipApplication accepts a userID and other parameters to create the partnership application of a given user.
# The required input for a createPartnershipApplicationInput mutation.
input CreatePartnershipApplicationInput {
  # Broadcast category (selected by the applicant).
  # eg: gaming, creative.
  category: String!
  # Country from where the applicant belongs (selected by the applicant).
  # eg: US, NZ, UK.
  country: String!
  # Description why the applicant wants to be a partner.
  description: String!
  # First and last name of the applicant.
  fullName: String!
  # Broadcast language (selected by the applicant).
  language: String!
}

# Whether or not the partnership application submission to was successful.
# The result of a createPartnershipApplicationInput mutation.
type CreatePartnershipApplicationPayload {
  # A successful creation returns the partnership application.
  # A failed creation returns null.
  partnershipApplication: PartnershipApplication
}

# Inputs for creating a choice.
input CreatePollChoiceInput {
  # Title of the choice.
  title: String!
}

# Vote in poll error.
type CreatePollError {
  # Code describing the error.
  code: CreatePollErrorCode!
}

# Vote in poll error code.
enum CreatePollErrorCode {
  # User attempted to create poll with restricted content.
  AUTOMOD_FAILED
  # User attempted to create poll when a poll was already active.
  POLL_ALREADY_ACTIVE
  # User attempted to create poll with bits on a channel where bits are not enabled.
  CHANNEL_NOT_BITS_ENABLED
  # An unknown error occurred.
  UNKNOWN
}

# Inputs for creating a new poll.
input CreatePollInput {
  # The cost in bits for casting a vote.
  bitsCost: Int = 0
  # Denotes if votes can be cast with bits.
  bitsVoting: Boolean = false
  # Choices that can be voted for in the poll.
  choices: [CreatePollChoiceInput!]!
  # The cost in Community Points for casting a vote.
  communityPointsCost: Int = 0
  # Duration of the poll in seconds.
  durationSeconds: Int!
  # Denotes if votes can be cast with Community Points.
  isCommunityPointsVotingEnabled: Boolean = false
  # Denotes if the poll allows voting for multiple options.
  multichoiceEnabled: Boolean = true
  # Id of the channel this poll is owned by.
  ownedBy: ID!
  # Denotes if subscribers receives bonus votes.
  # Deprecated: Subscriber multipliers are no longer supported.
  subscriberMultiplier: Boolean = false
  # Denotes if the poll is only open to subscribers.
  # Deprecated: Subscriber-only polls are no longer supported.
  subscriberOnly: Boolean = false
  # Title of the poll.
  title: String!
}

# Outputs from the create poll mutation.
type CreatePollPayload {
  # If present, there was an error with the request.
  error: CreatePollError
  # The created poll.
  poll: Poll
}

input CreatePostInput {
  body: String!
  channelID: ID!
  embedURLs: [String!]
  postToTwitter: Boolean
}

type CreatePostPayload {
  post: Post
  tweet: String
  tweetStatus: Int!
}

# An error returned from the createPredictionEvent mutation.
type CreatePredictionEventError {
  # Code describing the error.
  code: CreatePredictionEventErrorCode!
  # If the error code is TOO_MANY_OUTCOMES, this will be the maximum number of Outcomes.
  maxOutcomes: Int
  # If the error code is INVALID_PREDICTION_WINDOW, this will be the maximum Prediction Window in seconds.
  maxPredictionWindowSeconds: Int
}

# Possible error codes from the createPredictionEvent mutation.
enum CreatePredictionEventErrorCode {
  # The current user is forbidden from creating Prediction Events on the specified channel.
  FORBIDDEN
  # User attempted to create a Prediction Event with restricted content.
  AUTOMOD_FAILED
  # There is already an active or pending Prediction Event on the channel. The Event must be resolved before a new
  # Prediction Event can be created.
  EVENT_ALREADY_ACTIVE
  # Channel Points are not enabled on this channel.
  CHANNEL_POINTS_NOT_ENABLED
  # The colors chosen for each Option must be unique.
  COLORS_NOT_UNIQUE
  # Events must have at least 2 Outcomes.
  NOT_ENOUGH_OUTCOMES
  # Events have a maximum number of Outcomes.
  TOO_MANY_OUTCOMES
  # The specified Prediction Window is invalid. Prediction window must be positive. Prediction window has a maximum.
  INVALID_PREDICTION_WINDOW
  # An unknown error occurred.
  UNKNOWN
}

# Input for creating a Prediction Event.
input CreatePredictionEventInput {
  # The channel to create the Prediction Event on.
  channelID: ID!
  # Outcomes that can be chosen in the Prediction Event.
  outcomes: [CreatePredictionOutcomeInput!]!
  # The duration of the Prediction Window, in seconds.
  predictionWindowSeconds: Int!
  # The intended title of the Prediction Event.
  title: String!
}

# Payload for creating a prediction event.
type CreatePredictionEventPayload {
  # If present, there was an error with the request.
  error: CreatePredictionEventError
  # The created Prediction Event.
  predictionEvent: PredictionEvent
}

# Input for creating a Prediction Outcome.
input CreatePredictionOutcomeInput {
  # Color of the Outcome.
  color: PredictionOutcomeColor!
  # Title of the Outcome.
  title: String!
}

# CreateRaidError is the error associated with a createRaid.
type CreateRaidError {
  # The associated error code.
  code: CreateRaidErrorCode!
}

# CreateRaidErrorCode are the possible errors that this mutation returns.
enum CreateRaidErrorCode {
  # The user is already raiding another channel.
  ALREADY_RAIDING
  # The user tries to raid themselves.
  CANNOT_RAID_YOURSELF
  # The user tries to raid an unraidable channel.
  CANNOT_RAID_THIS_CHANNEL
  # The request is missing valid channel parameters.
  INVALID_CHANNEL
  # The user tries to raid with too many viewers.
  TOO_MANY_VIEWERS_TO_RAID
}

# Inputs to the createRaid mutation.
input CreateRaidInput {
  # Caller is expected to be a channel owner, editor, or staff.
  # User ID of the source channel hosting the raid.
  sourceID: ID!
  # User ID of the target channel.
  targetID: ID!
}

# Outputs from the createRaid mutation.
type CreateRaidPayload {
  # The possible error returned from the service.
  error: CreateRaidError
  # The created raid.
  raid: Raid
}

# Inputs to the createRewardedVideo mutation.
input CreateRewardedVideoTokenInput {
  # userID requesting the rewarded video token.
  userID: ID!
}

# Outputs from the createRewardedVideo mutation.
type CreateRewardedVideoTokenPayload {
  # token used to initialize the truex client application.
  token: String
}

type CreateRoomError {
  code: CreateRoomErrorCode!
  # On MAX_ROOMS_LIMIT_EXCEEDED: Maximum number of rooms user can create.
  maxAllowedRooms: Int
  # On NAME_LENGTH_INVALID, TOPIC_LENGTH_INVALID: Maximum number of characters.
  maxLength: Int
  # On NAME_LENGTH_INVALID, TOPIC_LENGTH_INVALID: Minimum number of characters.
  minLength: Int
}

enum CreateRoomErrorCode {
  # Name too short or too long.
  NAME_LENGTH_INVALID
  # Name contains invalid characters (e.g. spaces).
  NAME_CONTAINS_INVALID_CHARACTERS
  # Name failed automod check.
  NAME_INAPPROPRIATE
  # Name was not unique to channel.
  NAME_NOT_UNIQUE
  # Topic too short or too long.
  TOPIC_LENGTH_INVALID
  # Topic failed automod check.
  TOPIC_INAPPROPRIATE
  # User cannot create any more rooms.
  MAX_ROOMS_LIMIT_EXCEEDED
  # Invalid roles specified (e.g. a more permissive role for send than read).
  ROLES_INVALID
}

input CreateRoomInput {
  # Deprecated. Use minimumReadMessagesRole instead.
  isPreviewable: Boolean
  # Deprecated. Use minimumReadMessagesRole and minimumSendMessagesRole instead.
  minimumAllowedRole: RoomRole
  # Minimum role required to read messages in the room.
  minimumReadMessagesRole: RoomRole
  # Minimum role required to send messages in the room.
  minimumSendMessagesRole: RoomRole
  # The name of the room.
  name: String!
  # The topic for the room.
  topic: String!
}

type CreateRoomPayload {
  error: CreateRoomError
  room: Room
}

# The possible errors.
enum CreateScheduleError {
  # Channel already has a schedule.
  ALREADY_EXISTS
  # Cannot create a schedule for this channel.
  PERMISSION_DENIED
}

# The input to create a schedule.
input CreateScheduleInput {
  # The channel ID the schedule belongs to.
  channelID: ID!
}

# The payload returned after creating a schedule.
type CreateSchedulePayload {
  # The channel with the new schedule.
  channel: Channel
  # The possible error.
  error: CreateScheduleError
}

# CreateScheduleSegmentError is a wrapper for error associated with the CreateScheduleSegment mutation.
type CreateScheduleSegmentError {
  # Error code.
  code: CreateScheduleSegmentErrorCode!
  # If the error is related to overlapping segments, provide the existing segment causing a conflict.
  conflictingSegment: ScheduleSegment
  # If the error is related to an input out of service-defined bounds, provide the maximum allowed value.
  maximum: Int
  # If the error is related to an input out of service-defined bounds, provide the minimum allowed value.
  minimum: Int
}

# The possible errors when creating a schedule segment.
enum CreateScheduleSegmentErrorCode {
  # Not authorized to edit this user schedule.
  PERMISSION_DENIED
  # The schedule to create a segment for was not found.
  NOT_FOUND
  # The number of categories is invalid. Refer to the error for min and max acceptable values.
  INVALID_CATEGORY_COUNT
  # The segment time overlaps with another segment time.
  OVERLAPPING_SEGMENTS
  # The title length is invalid. Refer to the error for min and max acceptable values.
  INVALID_TITLE
  # The title failed the moderation check.
  TITLE_FAILED_MODERATION
  # The timezone is not valid.
  INVALID_TIMEZONE
  # The category is not valid.
  INVALID_CATEGORIES
  # The the start day is not valid.
  INVALID_START_DAY
  # The start hour is not valid.
  INVALID_START_HOUR
  # The start minute is not valid.
  INVALID_START_MINUTE
  # The duration is invalid. Refer to the error for min and max acceptable values.
  INVALID_DURATION
  # The segment is invalid.
  INVALID_SEGMENT
  # The input is not valid.
  INVALID_ARGUMENT
  # The number of segments is invalid. Refer to the error for min and max acceptable values.
  INVALID_SEGMENT_COUNT
  # The count for the number of times segment should repeat is invalid. The value must be 0 or greater.
  REPEAT_ENDS_AFTER_COUNT_INVALID
  # The segment first occurrence date is set in the past.
  FIRST_OCCURRENCE_DATE_IN_PAST
}

# The input to create a new schedule segment.
input CreateScheduleSegmentInput {
  # The categories of the new segment.
  categories: [ID!]!
  # The duration of the segment in minutes.
  durationMinutes: Int
  # The start date and time of the first occurrence of the segment.
  firstOccurrenceDate: Time
  # The number of times the segment should repeat. If 1, this is a single segment.
  repeatEndsAfterCount: Int
  # The ID of the schedule.
  scheduleID: ID!
  # The start time of the new segment. Ignored for single segments.
  start: SegmentStartTimeInput
  # The geographic timezone of the new segment defined by IANA; i.e. "America/Los_Angeles".
  timezone: String!
  # The title of the new segment.
  title: String
}

# The payload returned when creating a new schedule segment.
type CreateScheduleSegmentPayload {
  # The possible error.
  error: CreateScheduleSegmentError
  # The updated schedule with the created segment.
  schedule: Schedule
}

# CreateSocialMediaError is a user error while creating a social media.
enum CreateSocialMediaError {
  # The title failed moderation.
  FAILED_TITLE_MODERATION
  # The provided title was too long.
  TITLE_TOO_LONG
  # The provided url is invalid.
  INVALID_URL
  # Maximun number of social medias reached.
  TOO_MANY
}

# CreateSocialMediaInput creates social media under the given channelID.
input CreateSocialMediaInput {
  # The ID of the channel the social media should belong to.
  channelID: ID!
  # The visible text of the social media item.
  title: String!
  # The web address of the social media item.
  url: String!
}

# CreateSocialMediaPayload returns the new social medias that were created.
type CreateSocialMediaPayload {
  # The channel of the social media that was created.
  channel: Channel
  # The potential error when creating a social media.
  error: CreateSocialMediaError
}

# CreateSquadStreamInvitationError is the error associated with a createSquadStreamInvitation.
type CreateSquadStreamInvitationError {
  # The associated error code.
  code: CreateSquadStreamInvitationErrorCode!
}

# CreateSquadStreamInvitationErrorCode are the possible errors that this mutation returns.
enum CreateSquadStreamInvitationErrorCode {
  # The squad is already full.
  SQUAD_FULL
  # The recipient does not have access to squad streams.
  USER_CANNOT_ACCESS_SQUADS
  # The recipient is already in the squad.
  USER_ALREADY_IN_SQUAD
  # The recipient is already invited to the squad.
  INVITATION_ALREADY_EXISTS
  # The sender does not have permission to invite the recipient.
  INVITATION_BLOCKED
  # The invitation is not valid (e.g. the user is inviting themselves).
  INVITATION_INVALID
  # The user is not authorized to invite members to the squad.
  UNAUTHORIZED
}

# Inputs to the createSquadStreamInvitation mutation.
input CreateSquadStreamInvitationInput {
  # The user ID of the broadcaster that should be invited to join the squad stream.
  recipientUserID: ID!
  # The user ID of the broadcaster that is sending the invitation to join the squad stream.
  senderUserID: ID!
}

# Outputs from the createSquadStreamInvitation mutation.
type CreateSquadStreamInvitationPayload {
  # The possible error returned from the service.
  error: CreateSquadStreamInvitationError
  # The updated squad stream.
  squadStream: SquadStream
}

# Inputs to creating a stucco.
input CreateStuccoInput {
  # ID of the channel this stucco belongs to.
  channelID: ID!
  # Description representing the stucco, should be the words contained in the stucco, used by screen readers.
  description: String!
  # Base64 encoded binary data of the 92x28px stucco ("1x") image asset.
  imageData1x: String!
  # Base64 encoded binary data of the 182x56px stucco ("2x") image asset.
  imageData2x: String!
  # Base64 encoded binary data of the 368x112px stucco ("4x") image asset.
  imageData4x: String!
  # Text code representing the stucco without any prefixes (prefixes are added in the backend).
  suffix: String!
}

# Inputs for creating a new stucco pack.
input CreateStuccoPackInput {
  # Id of the channel this pack is part of.
  channelID: ID!
  # Updated list of stuccos for this pack.
  stuccos: [CreateStuccoPackItemInput!]
}

# Single item in a stuccopack, as part of the create stucco pack call, representing one stucco to be used in a certain slot.
input CreateStuccoPackItemInput {
  # Slot index in the pack (used for ordering).
  slotIndex: Int!
  # Id of the stucco.
  stuccoID: ID!
}

# Outputs from the create stucco pack mutation.
type CreateStuccoPackPayload {
  # The created stucco pack.
  stuccoPack: StuccoPack
}

# The output for the create update stucco mutation.
type CreateStuccoPayload {
  # The created or updated stucco.
  stucco: Stucco
}

# Error from create unban request mutation.
type CreateUnbanRequestError {
  # Error code from create unban request mutation.
  code: CreateUnbanRequestErrorCode!
}

# Error codes from create unban request mutation.
enum CreateUnbanRequestErrorCode {
  # User already has a request for the current ban.
  ALREADY_CREATED
  # User is not banned in the channel.
  NOT_BANNED
  # User is attempting to create a request too since their ban. Must wait for cooldown period to end.
  TOO_SOON_SINCE_BAN
  # Channel is not receiving unban requests.
  UNBAN_REQUESTS_DISABLED
  # Unknown error.
  UNKNOWN
}

# Required input to create an unban request on a channel.
input CreateUnbanRequestInput {
  # Channel on which requester is requesting an unban.
  channelID: ID!
  # Custom message from unban requester to attach to unban request.
  requesterMessage: String!
}

# Result of a createUnbanRequest mutation.
type CreateUnbanRequestPayload {
  # Error from attempting to create unban request.
  error: CreateUnbanRequestError
  # The newly created unban request.
  unbanRequest: UnbanRequest
}

# CreateVideoAppealInput details needed to create a video appeal.
input CreateVideoAppealInput {
  # city is the appeal city.
  city: String!
  # country is the appeal country.
  country: String!
  # fullName is the appeal full name.
  fullName: String!
  # state is the appeal state.
  state: String!
  # streetAddress1 is the appeal street address 1.
  streetAddress1: String!
  # streetAddress2 is the appeal street address 2.
  streetAddress2: String
  # trackAppeals is list of tracks that are being appealed.
  trackAppeals: [TrackAppealRequestInput!]!
  # videoID is the id of the vod that this appeal is for.
  videoID: ID!
  # zipcode is the appeal zipcode.
  zipcode: String!
}

# CreateVideoAppealPayload the ID of the video for the appeal made.
type CreateVideoAppealPayload {
  # The ID of the Vod this appeal was created for.
  videoID: ID
}

# CreateVideoBookmarkError is the error associated with a createVideoBookmark.
type CreateVideoBookmarkError {
  # The associated error code.
  code: CreateVideoBookmarkErrorCode
}

# CreateVideoBookmarkErrorCode are the possible errors that this mutation returns.
enum CreateVideoBookmarkErrorCode {
  # The broadcaster is not live.
  BROADCASTER_NOT_LIVE
  # Archives are disabled for the channel.
  ARCHIVES_DISABLED
  # The rerun broadcast format is unsupported..
  BROADCAST_FORMAT_INVALID_RERUN
  # The premiere broadcast format is unsupported.
  BROADCAST_FORMAT_INVALID_PREMIERE
  # The VOD for the associated broadcast is not yet ready.
  VOD_NOT_READY
  # An unexpected internal server error occurred.
  INTERNAL_SERVER_ERROR
  # The user is unauthorized to create the bookmark.
  USER_UNAUTHORIZED
  # The description length has exceeded the max length.
  MAX_DESCRIPTION_LENGTH_EXCEEDED
}

# Input for creating a new bookmark.
input CreateVideoBookmarkInput {
  # ID of the broadcast the bookmark is made for.
  broadcastID: ID
  # Channel ID of the channel the bookmark is made for.
  channelID: ID
  # A description for the bookmark.
  description: String
  # The medium where the request came from.
  # e.g. "popout_chat", "chat", "live_dashboard_button", "live_dashboard_hotkey", "live_dashboard_chat".
  medium: String!
  # The platform where the request came from.
  # e.g."web", "android", "ios".
  platform: String!
}

# Response for creating a bookmark, the bookmark that was created.
type CreateVideoBookmarkPayload {
  # Error of the create video bookmark request.
  error: CreateVideoBookmarkError
  # The bookmark that was created.
  videoBookmark: VideoBookmark
}

input CreateVideoCommentInput {
  # The id of the parent video comment when you reply.
  commentID: ID
  # Position of the video where this comment will be added.
  contentOffsetSeconds: Int!
  # The message of the comment.
  message: String!
  # The id of the video this comment belongs to.
  videoID: ID!
}

type CreateVideoCommentPayload {
  # The comment that was created.
  comment: VideoComment!
}

input CreateVideoHighlightInput {
  # The time in the source Archive type video that the Highlight will end at.
  endOffsetSeconds: Int!
  # Metadata to set for the highlight.
  metadata: CreateVideoHighlightMetadata!
  # The id of the Archive type video to create the Highlight from.
  sourceVideoID: ID!
  # The time in the source Archive type video that the Highlight will begin at.
  startOffsetSeconds: Int!
}

input CreateVideoHighlightMetadata {
  # The long form description of the Highlight content.
  description: String!
  # The primary game featured in the highlight, if any.
  game: ID
  # The language the highlight content is in.
  language: String!
  # Discovery tags to associate with the Highlight.
  tags: [String!]!
  # The title of the the highlight.
  title: String!
}

type CreateVideoHighlightPayload {
  # The created Video representing the Highlight.
  highlight: Video!
}

# Input to CreateVideoThumbnailUploadRequest mutation.
input CreateVideoThumbnailUploadRequestInput {
  # Crop height of the thumbnail.
  cropH: Int!
  # Crop width of the thumbnail.
  cropW: Int!
  # Crop X of the thumbnail.
  cropX: Int!
  # Crop Y of the thumbnail.
  cropY: Int!
  # ID of the video being updated.
  videoID: ID!
}

# Output from CreateVideoThumbnailUploadRequest mutation.
type CreateVideoThumbnailUploadRequestPayload {
  # The created thumbnail upload request url.
  url: String
}

# Data pertaining to a creator's badge flair for their own channel.
type CreatorBadgeFlair {
  # The creator's setting for which badge flair, if any, can be displayed.
  setting: CreatorBadgeFlairSetting
  # The set of badge flair assets for each tier.
  assets: [CreatorBadgeFlairAsset!]
}

# A set of URLs where clients can find the badge flair asset for a given creator at a given tier
type CreatorBadgeFlairAsset {
  # The tier to which these flair assets correspond to, as determined by the creator at time of upload.
  tier: CreatorBadgeFlairTier!
  # The "1x" dimension (18x18) image URL.
  image1xURL: String!
  # The "2x" dimension (36x36) image URL.
  image2xURL: String!
  # The "4x" dimension (72x72) image URL.
  image4xURL: String!
}

# Setting for a user's channel that indicates what type of badge flair, if any,
# is available for eligible subscribers to select.
enum CreatorBadgeFlairSetting {
  # Indicates no badge flair is available.
  NONE
  # Indicates badge flair using the default Twitch-provided flair asset is available.
  DEFAULT
  # Indicates badge flair using a custom user-provided flair asset is available.
  CUSTOM
}

# Valid subscription tiers that custom badge flair can be associated to.
enum CreatorBadgeFlairTier {
  # Tier 2 subscriptions (sometimes represented with string "2000").
  TIER_2
  # Tier 3 subscriptions (sometimes represented with string "3000").
  TIER_3
}

# A CreatorCampArticle is a represenation of an article from
# https://www.twitch.tv/creatorcamp.
type CreatorCampArticle {
  # The ID of the article is also a human readable "slug" e.g. "twitch-101".
  id: ID!
  # The locale associated with this article's translations.
  locale: String!
  # A URL pointing to an image associated with this article.
  previewImage: String
  # A short introduction for the article.
  previewText: String
  # The localized title of the article.
  title: String!
  # The cannonical location of this article on the CreatorCamp site.
  url: String!
  # The length of the article's video in seconds.
  videoDurationSeconds: Int
  # A URL pointing to the embedded video in this article. Most
  # CreatorCamp articles have an assoicated video.
  videoURL: String
}

# A CreatorCampCategory is a grouping of CreatorCamp articles.
# https://www.twitch.tv/creatorcamp.
type CreatorCampCategory {
  # A list of CreatorCamp articles in this category.
  articles: [CreatorCampArticle!]!
  # The ID of the category is also a human-readable "slug" e.g. "learn-the-basics".
  id: ID!
  # The localized title of the category.
  title: String!
}

# Creator Dashboard shown in twilight.
type CreatorDashboard {
  # Channel Analytics query for the Channel Analytics Tab in the Creator Dashboard.
  channelAnalytics: ChannelAnalytics
}

# The container for creator gifts the creator has. This will be null if the creator
# does not have this feature enabled.
type CreatorGifting {
  # The identifier for the creator gifting type. This is the user's ID.
  id: ID!
  # The balance of gift subscriptions the creator has to give. These subscriptions do not pay out to the creator.
  subscriptionsBalance: Int
}

# Top level Creator Home object, includes data for clusters and panels.
type CreatorHome {
  # Id for caching.
  id: ID!
  # Clusters for layout information.
  clusters: [CreatorHomeCluster!]
  # Panels containing Creator Home cards.
  panels: [CreatorHomePanel!]
}

# Interface defining the base requirements for Creator Home Cards.
interface CreatorHomeCard {
  # The type of the card, i.e. "STAT_FOLLOWERS_CARD".
  type: String!
}

# Predefined clusters for creators.
type CreatorHomeCluster {
  # Unique identifier for the cluster, i.e. "FAR_FROM_AFFILIATE".
  id: ID!
}

# Predefined panels containing dynamic cards.
type CreatorHomePanel {
  # Predefined identifier for the panel.
  type: CreatorHomePanelType!
  # List of ordered cards to display.
  cards: [CreatorHomeCard!]!
}

# Types of Creator Home panels.
enum CreatorHomePanelType {
  # Top panel section with intro and insights.
  HERO
  # Panel displaying stream related shortcuts.
  SHORTCUTS
  # Right panel displaying creator action items.
  ACTIONS
  # Panel displaying the tip of the day.
  TIPS
}

# Creator metrics for the given time period.
type CreatorMetricsByInterval {
  # Creator metrics aggregated and broken up by the interval length.
  items: [CreatorMetricsByIntervalItem]
}

# Creator metrics for the given time period.
type CreatorMetricsByIntervalItem {
  # Ad breaks in seconds for the time period.
  adBreaksInSecondsString: String!
  # Ad seconds per hour for the time period.
  adSecondsPerHour: Float!
  # Average viewers for the time period.
  averageViewers: Float!
  # Clips views for the time period.
  clipViewsString: String!
  # Clips created for the time period.
  clipsCreatedString: String!
  # Number of follows for the time period.
  followsString: String!
  # Host raids percentage for the time period.
  hostRaidsPercentage: Float!
  # Live views for the time period.
  liveViewsString: String!
  # Max viewers for the time period.
  maxViewersString: String!
  # Time streamed (in minutes) for the time period.
  minutesStreamedString: String!
  # Minutes watched for the time period.
  minutesWatchedString: String!
  # New subscriptions for the time period.
  newSubscriptionsString: String!
  # Promotion clicks for the time period.
  promotionClickString: String!
  # Promotion displays for the time period.
  promotionDisplayString: String!
  # Starting timestamp for the time period.
  timestamp: Time!
  # Total chat messages for the time period.
  totalChatMessagesString: String!
  # Total chatters for the time period.
  totalChattersString: String!
  # Unique viewers for the time period.
  uniqueViewersString: String!
}

# Onboarding content and tips that are shown during the streamer onboarding experience.
type CreatorOnboardingContent {
  # The time when the onboarding content was first shown to the user.
  firstSeenAt: Time
  # The id of the creator onboarding content.
  id: ID!
}

# A url to be shared by a creator to gain referrals, and associated metadata.
type CreatorReferralLink {
  # The body text that will show on social media when the associated url is shared -- og:description.
  description: String!
  # The ID of the referral link.
  id: ID!
  # The image that will show on social media when the associated url is shared -- og:image.
  imageURL: String!
  # The title text that will show on social media when the associated url is shared -- og:title.
  title: String!
  # The url of the referral link.
  url: String!
}

# A paginated list of creator referral links.
type CreatorReferralLinkConnection {
  # The list edges contain CreatorReferralLink with pagination information.
  edges: [CreatorReferralLinkEdge!]!
  # Information about this page of creator referral links.
  pageInfo: PageInfo!
}

# An element in a paginated list of creator referral links.
type CreatorReferralLinkEdge {
  # Cursor represents the position of the current edge/node.
  cursor: Cursor!
  # Node represents the creator referral link for the current edge.
  node: CreatorReferralLink!
}

# Contains a reference to the link object and the number of referrals from that link.
type CreatorReferralLinkStat {
  # The reference to the link that caused the associated number of referrals.
  link: CreatorReferralLink!
  # The number of referred users for the given link.
  referralCount: Int!
}

# Contains the statistics summary for creator referral link.
type CreatorReferralSummary {
  # Average referrals per day in the given date range.
  averageReferrals: Int!
  # List of data points in the summary.
  days: [CreatorReferralSummaryDay!]!
  # Total referrals in the given date range.
  totalReferrals: Int!
  # Trend of the referrals per day in the given date range, when compared to the previous date range of the same length.
  trend: CreatorReferralTrend!
}

# Each data point contains date and list of links with number of referred users.
type CreatorReferralSummaryDay {
  # The date for the enclosed data.
  date: Time!
  # List of CreatorReferralLinkStat objects on the given date.
  linkStats: [CreatorReferralLinkStat!]!
  # The total number of referred users on the given date.
  referralCountSum: Int!
}

# Specifies the general trend of this data set vs the previous data set.
enum CreatorReferralTrend {
  # The new data set has increased relative to the previous data set.
  POSITIVE
  # The new data set has not changed relative to the previous data set.
  NEUTRAL
  # The new data set has decreased relative to the previous data set.
  NEGATIVE
}

# Single item of stats for the time series.
type CreatorTimeseriesItem {
  # Streamed duration (in minutes).
  minutesStreamed: Int
  # Timestamp of the broken down time series.
  timestamp: Time!
  # Value at the timestamp.
  value: Float!
}

# List of timestamp, value metric pairs and total for that metric.
type CreatorTimeseriesMetric {
  # CreatorTimeseries data (timestamp, value) associated with this metric.
  items: [CreatorTimeseriesItem!]
  # Total (sum) of all CreatorTimeseriesMetrics values.
  total: Int!
}

# Metrics within a time frame broken down by granularity.
# This is used for per team stats, per channel stats use "TimeseriesStats".
type CreatorTimeseriesMetrics {
  # Seconds of ads played per time chunk.
  adBreaksInSeconds: CreatorTimeseriesMetric!
  # Ad time (in seconds) per hour per time chunk.
  adTimePerHour: CreatorTimeseriesMetric!
  # Average number of viewers per time chunk.
  averageViewers: CreatorTimeseriesMetric!
  # Number of chat messages per time chunk.
  chatMessages: CreatorTimeseriesMetric!
  # Number of clip views per time chunk.
  clipViews: CreatorTimeseriesMetric!
  # Number of clips created per time chunk.
  clipsCreated: CreatorTimeseriesMetric!
  # Number of follows during this timestamp.
  follows: CreatorTimeseriesMetric!
  # Granularity of the time series, default unit is five minutes.
  granularity: Granularity!
  # Host/Raid viewers per time chunk.
  hostRaidViewers: CreatorTimeseriesMetric!
  # Live number of views per time chunk.
  liveViews: CreatorTimeseriesMetric!
  # Max viewers per time chunk.
  maxViewers: CreatorTimeseriesMetric!
  # Minutes watched per time chunk.
  minutesWatched: CreatorTimeseriesMetric!
  # Number of subscriptions per time chunk.
  newSubscriptions: CreatorTimeseriesMetric!
  # Promotion clicks for the time period.
  promotionClick: CreatorTimeseriesMetric!
  # Promotion displays for the time period.
  promotionDisplay: CreatorTimeseriesMetric!
  # Time streamed per time chunk.
  timeStreamed: CreatorTimeseriesMetric!
  # Number of people chatting per time chunk.
  uniqueChatters: CreatorTimeseriesMetric!
  # Number of unique people watching per time chunk.
  uniqueViewers: CreatorTimeseriesMetric!
}

# CreditChargeModel defines a charge model using non-FIAT currencies.
type CreditChargeModel {
  # The value of the credit.
  amount: Int!
  # The type of credit.
  creditType: CreditType!
}

# Types of non-fiat currencies.
enum CreditType {
  # Indicates that there is no specific type of Credit in this model.
  NO_CREDIT_TYPE
  # A sub token type.
  SUB_TOKEN
}

# A Crowd Chant on a channel.
type CrowdChant {
  # The timestamp of when the chant was created.
  createdAt: Time!
  # The creator of the chant.
  createdBy: User!
  # The timestamp of when the chant will end.
  endsAt: Time!
  # Unique identifier of the chant.
  id: ID!
  # The uuid of the chant's chat message sent on behalf of the user creating the chant.
  chatMessageID: ID!
  # The body of the chant.
  text: String!
}

# Details about crowd chants in the channel.
type CrowdChants {
  # The channel's settings for crowd chants.
  settings: ChannelCrowdChantSettings
  # The channel's active chant.
  activeChant: CrowdChant
}

# Possible values of actionPrompted in SubmitCSATFeedbackInput.
enum CSATActionPrompted {
  # The user registers their client app (i.e. save information for an app), in their personal console.
  CLIENT_APP_REGISTER
  # The user creates a new drop campaign.
  DROP_CREATE_CAMPAIGN
  # The user moves a drop's state to active.
  DROP_MOVE_STATE_TO_ACTIVE
  # The user move's a drop's state to testing.
  DROP_MOVE_STATE_TO_TESTING
  # The user creates a new extension.
  EXTENSION_CREATE
  # The user changes the state of an extension.
  EXTENSION_STATE_CHANGE
  # The user views the analytics page of their game.
  GAMES_VIEW_ANALYTICS
  # The user submits box art for their game.
  GAMES_SUBMIT_BOX_ART
  # The user creates a new organization.
  ORGANIZATION_CREATE
  # The user adds another user to their organization.
  ORGANIZATION_ADD_USER
}

# Possible ratings that the user can submit as part of their feedback.
enum CSATRating {
  # The user selects "Very Dissatisfied".
  VERY_DISSATISFIED
  # The user selects "Somewhat Dissatisfied".
  SOMEWHAT_DISSATISFIED
  # The user selects "Neutral".
  NEUTRAL
  # The user selects "Somewhat Satisfied".
  SOMEWHAT_SATISFIED
  # The user selects "Very Satisfied".
  VERY_SATISFIED
}

# An enumeration of ISO 4217 currencies accepted by the API.
enum Currency {
  # Afghani currency.
  AFN
  # Euro currency.
  EUR
  # Lek currency.
  ALL
  # Algerian Dinar currency.
  DZD
  # US Dollar currency.
  USD
  # Kwanza currency.
  AOA
  # East Caribbean Dollar currency.
  XCD
  # Argentine Peso currency.
  ARS
  # Armenian Dram currency.
  AMD
  # Aruban Florin currency.
  AWG
  # Australian Dollar currency.
  AUD
  # Azerbaijan Manat currency.
  AZN
  # Bahamian Dollar currency.
  BSD
  # Bahraini Dinar currency.
  BHD
  # Taka currency.
  BDT
  # Barbados Dollar currency.
  BBD
  # Belarusian Ruble currency.
  BYN
  # Belize Dollar currency.
  BZD
  # CFA Franc BCEAO currency.
  XOF
  # Bermudian Dollar currency.
  BMD
  # Indian Rupee currency.
  INR
  # Ngultrum currency.
  BTN
  # Boliviano currency.
  BOB
  # Mvdol currency.
  BOV
  # Convertible Mark currency.
  BAM
  # Pula currency.
  BWP
  # Norwegian Krone currency.
  NOK
  # Brazilian Real currency.
  BRL
  # Brunei Dollar currency.
  BND
  # Bulgarian Lev currency.
  BGN
  # Burundi Franc currency.
  BIF
  # Cabo Verde Escudo currency.
  CVE
  # Riel currency.
  KHR
  # CFA Franc BEAC currency.
  XAF
  # Canadian Dollar currency.
  CAD
  # Cayman Islands Dollar currency.
  KYD
  # Chilean Peso currency.
  CLP
  # Unidad de Fomento currency.
  CLF
  # Yuan Renminbi currency.
  CNY
  # Colombian Peso currency.
  COP
  # Unidad de Valor Real currency.
  COU
  # Comorian Franc currency.
  KMF
  # Congolese Franc currency.
  CDF
  # New Zealand Dollar currency.
  NZD
  # Costa Rican Colon currency.
  CRC
  # Kuna currency.
  HRK
  # Cuban Peso currency.
  CUP
  # Peso Convertible currency.
  CUC
  # Netherlands Antillean Guilder currency.
  ANG
  # Czech Koruna currency.
  CZK
  # Danish Krone currency.
  DKK
  # Djibouti Franc currency.
  DJF
  # Dominican Peso currency.
  DOP
  # Egyptian Pound currency.
  EGP
  # El Salvador Colon currency.
  SVC
  # Nakfa currency.
  ERN
  # Ethiopian Birr currency.
  ETB
  # Falkland Islands Pound currency.
  FKP
  # Fiji Dollar currency.
  FJD
  # CFP Franc currency.
  XPF
  # Dalasi currency.
  GMD
  # Lari currency.
  GEL
  # Ghana Cedi currency.
  GHS
  # Gibraltar Pound currency.
  GIP
  # Quetzal currency.
  GTQ
  # Pound Sterling currency.
  GBP
  # Guinean Franc currency.
  GNF
  # Guyana Dollar currency.
  GYD
  # Gourde currency.
  HTG
  # Lempira currency.
  HNL
  # Hong Kong Dollar currency.
  HKD
  # Forint currency.
  HUF
  # Iceland Krona currency.
  ISK
  # Rupiah currency.
  IDR
  # Iranian Rial currency.
  IRR
  # Iraqi Dinar currency.
  IQD
  # New Israeli Sheqel currency.
  ILS
  # Jamaican Dollar currency.
  JMD
  # Yen currency.
  JPY
  # Jordanian Dinar currency.
  JOD
  # Tenge currency.
  KZT
  # Kenyan Shilling currency.
  KES
  # Won currency.
  KRW
  # Kuwaiti Dinar currency.
  KWD
  # Som currency.
  KGS
  # Lao Kip currency.
  LAK
  # Lebanese Pound currency.
  LBP
  # Loti currency.
  LSL
  # Rand currency.
  ZAR
  # Liberian Dollar currency.
  LRD
  # Libyan Dinar currency.
  LYD
  # Swiss Franc currency.
  CHF
  # Pataca currency.
  MOP
  # Denar currency.
  MKD
  # Malagasy Ariary currency.
  MGA
  # Malawi Kwacha currency.
  MWK
  # Malaysian Ringgit currency.
  MYR
  # Rufiyaa currency.
  MVR
  # Ouguiya currency.
  MRU
  # Mauritius Rupee currency.
  MUR
  # ADB Unit of Account currency.
  XUA
  # Mexican Peso currency.
  MXN
  # Mexican Unidad de Inversion (UDI) currency.
  MXV
  # Moldovan Leu currency.
  MDL
  # Tugrik currency.
  MNT
  # Moroccan Dirham currency.
  MAD
  # Mozambique Metical currency.
  MZN
  # Kyat currency.
  MMK
  # Namibia Dollar currency.
  NAD
  # Nepalese Rupee currency.
  NPR
  # Cordoba Oro currency.
  NIO
  # Naira currency.
  NGN
  # Rial Omani currency.
  OMR
  # Pakistan Rupee currency.
  PKR
  # Balboa currency.
  PAB
  # Kina currency.
  PGK
  # Guarani currency.
  PYG
  # Sol currency.
  PEN
  # Philippine Peso currency.
  PHP
  # Zloty currency.
  PLN
  # Qatari Rial currency.
  QAR
  # Romanian Leu currency.
  RON
  # Russian Ruble currency.
  RUB
  # Rwanda Franc currency.
  RWF
  # Saint Helena Pound currency.
  SHP
  # Tala currency.
  WST
  # Dobra currency.
  STN
  # Saudi Riyal currency.
  SAR
  # Serbian Dinar currency.
  RSD
  # Seychelles Rupee currency.
  SCR
  # Leone currency.
  SLL
  # Singapore Dollar currency.
  SGD
  # Sucre currency.
  XSU
  # Solomon Islands Dollar currency.
  SBD
  # Somali Shilling currency.
  SOS
  # South Sudanese Pound currency.
  SSP
  # Sri Lanka Rupee currency.
  LKR
  # Sudanese Pound currency.
  SDG
  # Surinam Dollar currency.
  SRD
  # Lilangeni currency.
  SZL
  # Swedish Krona currency.
  SEK
  # WIR Euro currency.
  CHE
  # WIR Franc currency.
  CHW
  # New Taiwan Dollar currency.
  TWD
  # Somoni currency.
  TJS
  # Tanzanian Shilling currency.
  TZS
  # Baht currency.
  THB
  # Paâ€™anga currency.
  TOP
  # Trinidad and Tobago Dollar currency.
  TTD
  # Tunisian Dinar currency.
  TND
  # Turkish Lira currency.
  TRY
  # Turkmenistan New Manat currency.
  TMT
  # Uganda Shilling currency.
  UGX
  # Hryvnia currency.
  UAH
  # UAE Dirham currency.
  AED
  # Peso Uruguayo currency.
  UYU
  # Uruguay Peso en Unidades Indexadas (UI) currency.
  UYI
  # Unidad Previsional currency.
  UYW
  # Uzbekistan Sum currency.
  UZS
  # Vatu currency.
  VUV
  # BolÃ­var Soberano currency.
  VES
  # Dong currency.
  VND
  # Yemeni Rial currency.
  YER
  # Zambian Kwacha currency.
  ZMW
  # Zimbabwe Dollar currency.
  ZWL
}

# CurrentPrimePayout is the detail breakdown of the payout that will be made in this specific payout cycle.
type CurrentPrimePayout {
  # pastCyclePayoutAmount is the part of the payout that was earned in previous payout cycle(s).
  pastCyclePayoutAmount: Int!
  # thisCyclePayoutAmount is the part of the payout that was earned in this payout cycle itself.
  thisCyclePayoutAmount: Int!
  # totalPayoutAmount is the total amount for this payout.
  totalPayoutAmount: Int!
}

# An opaque identifier for a connection edge. Used for pagination.
#
# This is part of the Relay Cursor Connections Specification:
# https://facebook.github.io/relay/graphql/connections.htm.
scalar Cursor

# An action (and metadata about the action) which occurred for a channel's Dashboard Activity Feed.
interface DashboardActivityFeedActivity {
  # Status of the corresponding alert.
  alertStatus: DashboardActivityFeedActivityAlertStatus
  # Unique identifier for this activity.
  id: ID!
  # When this activity occurred.
  timestamp: Time!
}

# DashboardActivityFeedActivityAlertStatus are the possible alert statuses that an activity's corresponding alert can have.
enum DashboardActivityFeedActivityAlertStatus {
  # The alert failed to be published.
  FAILED
  # The alert was received when the channel was offline.
  OFFLINE
  # The alert has been played and will not be seen again.
  PLAYED
  # The alert is currently being displayed.
  PLAYING
  # The alert is in the alert queue, but yet to be seen.
  QUEUED
  # The alert was not queued and will not be displayed.
  REJECTED
  # The alert was being displayed, but was skipped by the broadcaster.
  SKIPPED
  # The alert was purged from the alert queue by the broadcaster, after being queued originally.
  PURGED
}

# When a user AutoHosts a channel.
type DashboardActivityFeedActivityAutoHosting implements DashboardActivityFeedActivity {
  # Status of the corresponding alert.
  alertStatus: DashboardActivityFeedActivityAlertStatus
  # User/Channel who is now AutoHosting the channel.
  host: User
  # Unique identifier for this AutoHosting action.
  id: ID!
  # When the host initiated the AutoHosting session.
  timestamp: Time!
  # Number of viewers from the host channel.
  viewerCount: Int!
}

# When a user uses Bits for or sends Bits to a channel.
type DashboardActivityFeedActivityBitsUsage implements DashboardActivityFeedActivity {
  # Status of the corresponding alert.
  alertStatus: DashboardActivityFeedActivityAlertStatus
  # Bits spent.
  amount: Int!
  # Unique identifier for this Bits usage.
  id: ID!
  # Whether the Cheer was anonymized to other users.
  # If true, then `user` is guaranteed to be null.
  isAnonymous: Boolean!
  # When the Bits were used.
  timestamp: Time!
  # Bits spender.
  user: User
}

# When a Boost completes for the given user.
type DashboardActivityFeedActivityBoostComplete implements DashboardActivityFeedActivity {
  # Status of the corresponding alert.
  alertStatus: DashboardActivityFeedActivityAlertStatus
  # The progress made toward the goalTarget.
  goalProgress: Int!
  # The target size for the boost order.
  goalTarget: Int!
  # Unique identifier for this Boost event.
  id: ID!
  # The user who purchased the boost order.
  purchaser: User
  # The number of boosts in the order.
  quantity: Int!
  # When this Boost event occurred.
  timestamp: Time!
}

# When a Boost starts for the given user.
type DashboardActivityFeedActivityBoostStart implements DashboardActivityFeedActivity {
  # Status of the corresponding alert.
  alertStatus: DashboardActivityFeedActivityAlertStatus
  # The progress made toward the goalTarget.
  goalProgress: Int!
  # The target size for the boost order.
  goalTarget: Int!
  # Unique identifier for this Boost event.
  id: ID!
  # The user who purchased the boost order.
  purchaser: User
  # The number of boosts in the order.
  quantity: Int!
  # When this Boost event occurred.
  timestamp: Time!
}

# When a Celebration event occurs for the given user.
type DashboardActivityFeedActivityCelebrationPurchaseEvent implements DashboardActivityFeedActivity {
  # Status of the corresponding alert.
  alertStatus: DashboardActivityFeedActivityAlertStatus
  # The effect used for the celebration.
  effect: CelebrationEffect!
  # Unique identifier for this Celebration event.
  id: ID!
  # The intensity of the celebration.
  intensity: CelebrationIntensity!
  # The user who purchased the celebration.
  purchasingUser: User
  # When this Celebration event occurred.
  timestamp: Time!
}

# When a user redeems a community points reward on a channel.
type DashboardActivityFeedActivityCommunityPointsReward implements DashboardActivityFeedActivity {
  # Status of the corresponding alert.
  alertStatus: DashboardActivityFeedActivityAlertStatus
  # Unique identifier for this redemption.
  id: ID!
  # The user that redeemed the reward.
  redeemingUser: User
  # The redemption object itself.
  redemption: CommunityPointsCustomRewardRedemption
  # When the reward was redeemed.
  timestamp: Time!
  # The title of the reward.
  title: String!
  # The user's text input, if provided.
  userInput: String
}

# When a user gifts subscriptions to a community for a channel.
type DashboardActivityFeedActivityCommunitySubscriptionGifting implements DashboardActivityFeedActivity {
  # Status of the corresponding alert.
  alertStatus: DashboardActivityFeedActivityAlertStatus
  # Total subscriptions gifted by the gifter.
  giftQuantity: Int!
  # Total number of months the gifted subscription lasts for.
  giftedMonths: Int!
  # Subscription purchaser & gifter.
  gifter: User
  # Unique identifier for this gifting action.
  id: ID!
  # Whether the subscription gifting was anonymized to other users.
  # If true, then `gifter` is guaranteed to be null.
  isAnonymous: Boolean!
  # Users who received the gift.
  # Maximum count is currently 100.
  recipients: [User!]
    @deprecated(reason: "Use giftQuantity for total subscriptions")
  # The gifted subscription's tier.
  tier: SubscriptionTier!
  # When the subscriptions were gifted.
  timestamp: Time!
}

# Paginated list of past activities for a channel's Dashboard Activity Feed.
type DashboardActivityFeedActivityConnection {
  # Activity elements of the list.
  edges: [DashboardActivityFeedActivityEdge!]!
  # Information about this page.
  pageInfo: PageInfo!
}

# When a Community Goal ends for the channel.
type DashboardActivityFeedActivityCopoGoalEnd implements DashboardActivityFeedActivity {
  # Status of the corresponding alert.
  alertStatus: DashboardActivityFeedActivityAlertStatus
  # The target number of points for the goal that has ended.
  goalAmount: Int!
  # The id of the goal that has ended.
  goalID: ID!
  # The current status of the goal that has ended.
  goalStatus: CommunityPointsCommunityGoalStatus!
  # The title of the goal that has ended.
  goalTitle: String!
  # The type of the goal that has ended.
  goalType: CommunityPointsCommunityGoalType!
  # Unique identifier for this goal end event.
  id: ID!
  # The number of points contributed towards the goal.
  pointsContributed: Int!
  # The name of the community points on the channel.
  pointsName: String
  # When this goal end event occurred.
  timestamp: Time!
}

# When a creator completes a drop quest and a drop can now be claimed by users/viewers.
type DashboardActivityFeedActivityDropClaimWindowOpen implements DashboardActivityFeedActivity {
  # Status of the corresponding alert.
  alertStatus: DashboardActivityFeedActivityAlertStatus
  # The community claimable drop which has been activated.
  drop: DropObject!
  # Unique identifier for this drop activity.
  id: ID!
  # When the quest was completed.
  timestamp: Time!
}

# Activity element in a list of past activities of a channel's Dashboard Activity Feed.
type DashboardActivityFeedActivityEdge {
  # Opaque cursor describing this edge's position in the paginated list.
  cursor: Cursor!
  # Activity that occurred.
  node: DashboardActivityFeedActivity!
}

# When a user newly follows or refollows a channel.
type DashboardActivityFeedActivityFollowing implements DashboardActivityFeedActivity {
  # Status of the corresponding alert.
  alertStatus: DashboardActivityFeedActivityAlertStatus
  # User who is now following the channel.
  follower: User
  # Unique identifier for this follow action.
  id: ID!
  # When the user followed the channel.
  timestamp: Time!
}

# When a user hosts a channel.
type DashboardActivityFeedActivityHosting implements DashboardActivityFeedActivity {
  # Status of the corresponding alert.
  alertStatus: DashboardActivityFeedActivityAlertStatus
  # User/Channel who is now hosting the channel.
  host: User
  # Unique identifier for this hosting action.
  id: ID!
  # When the host initiated the hosting session.
  timestamp: Time!
  # Number of viewers from the host channel.
  viewerCount: Int
}

# When a HypeTrain event occurs for the given user.
type DashboardActivityFeedActivityHypeTrainEvent implements DashboardActivityFeedActivity {
  # Status of the corresponding alert.
  alertStatus: DashboardActivityFeedActivityAlertStatus
  # The highest level completed on this HypeTrain.
  completedLevel: Int
  # Unique identifier of the Hype Train.
  hypeTrainID: ID!
  # Unique identifier for this HypeTrain event.
  id: ID!
  # When this HypeTrain event occurred.
  timestamp: Time!
  # The total amount of Bits contributed on this HypeTrain.
  totalBitsAmount: Int
  # The total count of subs and sub gifts contributed on this HypeTrain.
  totalSubsCount: Int
  # The type of this HypeTrain event.
  type: HypeTrainEventType!
}

# When a user gifts a single subscription to another individual user for a channel.
type DashboardActivityFeedActivityIndividualSubscriptionGifting implements DashboardActivityFeedActivity {
  # Status of the corresponding alert.
  alertStatus: DashboardActivityFeedActivityAlertStatus
  # Total number of months the gifted subscription lasts for.
  giftedMonths: Int!
  # Subscription purchaser & gifter.
  gifter: User
  # Unique identifier for this gifting action.
  id: ID!
  # Whether the subscription gifting was anonymized to other users.
  # If true, then `gifter` is guaranteed to be null.
  isAnonymous: Boolean!
  # User that received the gift.
  recipient: User
  # The gifted subscription's tier.
  tier: SubscriptionTier!
  # When the subscription was gifted.
  timestamp: Time!
}

# When an ingest session begins.
# Deprecated type: no longer exists in activity feed.
type DashboardActivityFeedActivityIngestSessionStarting implements DashboardActivityFeedActivity {
  # Status of the corresponding alert.
  alertStatus: DashboardActivityFeedActivityAlertStatus
    @deprecated(reason: "ingest start has been removed from activity feed")
  # Unique identifier for the start of this ingest session.
  id: ID!
    @deprecated(reason: "ingest start has been removed from activity feed")
  # Start time of the ingest session.
  timestamp: Time!
    @deprecated(reason: "ingest start has been removed from activity feed")
}

# When a user resubscribes via Twitch Prime to a channel.
type DashboardActivityFeedActivityPrimeResubscribing implements DashboardActivityFeedActivity {
  # Status of the corresponding alert.
  alertStatus: DashboardActivityFeedActivityAlertStatus
  # Duration of the subscription.
  durationMonths: Int!
  # Unique identifier for the act of renewing the subscription.
  id: ID!
  # Custom message submitted by the resubscribing user to share in chat.
  message: String
    @deprecated(reason: "Use messageContent's fragments for enriching the text")
  # Custom message submitted by the resubscribing user to share in chat.
  # Message is filtered for moderation and emotes are extracted as message fragments.
  messageContent: MessageContent
  # User who is renewing the subscription.
  resubscriber: User
  # When the subscription was renewed.
  timestamp: Time!
}

# When a user subscribes for the first time via Twitch Prime to a channel.
type DashboardActivityFeedActivityPrimeSubscribing implements DashboardActivityFeedActivity {
  # Status of the corresponding alert.
  alertStatus: DashboardActivityFeedActivityAlertStatus
  # Unique identifier for the act of subscribing.
  id: ID!
  # User who made the subscription.
  subscriber: User
  # When the subscription was made.
  timestamp: Time!
}

# When a user raids a channel.
type DashboardActivityFeedActivityRaiding implements DashboardActivityFeedActivity {
  # Status of the corresponding alert.
  alertStatus: DashboardActivityFeedActivityAlertStatus
  # Unique identifier for this raiding action.
  id: ID!
  # Number of users who participated in the raid.
  partySize: Int! @deprecated(reason: "Renamed to viewerCount")
  # User/Channel who is now raiding the channel.
  raider: User
  # When the raid was initiated.
  timestamp: Time!
  # Number of users who participated in the raid.
  viewerCount: Int!
}

# When a user resubscribes (NOT via Twitch Prime) to a channel.
type DashboardActivityFeedActivityResubscribing implements DashboardActivityFeedActivity {
  # Status of the corresponding alert.
  alertStatus: DashboardActivityFeedActivityAlertStatus
  # Duration of the subscription.
  durationMonths: Int!
  # Unique identifier for the act of renewing the subscription.
  id: ID!
  # Custom message submitted by the resubscribing user to share in chat.
  message: String
    @deprecated(reason: "Use messageContent's fragments for enriching the text")
  # Custom message submitted by the resubscribing user to share in chat.
  # Message is filtered for moderation and emotes are extracted as message fragments.
  messageContent: MessageContent
  # Duration of the multi month subscription.
  multiMonthDuration: Int!
  # Tenure of the user's current multi month subscription.
  multiMonthTenure: Int!
  # User who is renewing the subscription.
  resubscriber: User
  # Subscription tier.
  tier: SubscriptionTier!
  # When the subscription was renewed.
  timestamp: Time!
}

# When a user subscribes for the first time (NOT via Twitch Prime) to a channel.
type DashboardActivityFeedActivitySubscribing implements DashboardActivityFeedActivity {
  # Status of the corresponding alert.
  alertStatus: DashboardActivityFeedActivityAlertStatus
  # Unique identifier for the act of subscribing.
  id: ID!
  # Duration of the multi month subscription.
  multiMonthDuration: Int!
  # Tenure of the user's current multi month subscription.
  multiMonthTenure: Int!
  # User who made the subscription.
  subscriber: User
  # Subscription tier.
  tier: SubscriptionTier!
  # When the subscription was made.
  timestamp: Time!
}

# Paginated list of past activities for a channel's Dashboard Alert Queue.
type DashboardAlertQueueActivityConnection {
  # Activity elements of the list.
  edges: [DashboardAlertQueueActivityEdge!]!
  # Information about this page.
  pageInfo: PageInfo!
}

# Activity element in a list of past activities of a channel's Dashboard Alert Queue.
type DashboardAlertQueueActivityEdge {
  # Opaque cursor describing this edge's position in the paginated list.
  cursor: Cursor!
  # Activity that occurred.
  node: DashboardActivityFeedActivity!
}

# Preferences of a user controlling the types of dashboard alerts to be published.
type DashboardAlertQueuePreferences {
  # If true, cannot publish alerts to the user.
  isDNDModeEnabled: Boolean!
  # When the preferences were last modified.
  lastModified: Time
  # If true, cannot publish bits alerts to the user.
  shouldHideBits: Boolean!
  # If true, cannot publish follows alerts to the user.
  shouldHideFollows: Boolean!
  # If true, cannot publish subscription gift alerts to the user.
  shouldHideGiftSubscriptions: Boolean!
  # If true, cannot publish hosts alerts to the user.
  shouldHideHosts: Boolean!
  # If true, cannot publish raids alerts to the user.
  shouldHideRaids: Boolean!
  # If true, cannot publish regular subscriptions alerts to the user (gift subs are still shown).
  shouldHideSubscriptions: Boolean!
}

# A shelf title token type that contains a date with various formatters.
type DateToken {
  # The date to display for this token.
  time: Time!
}

# The required input for a deactivateExtension mutation.
input DeactivateExtensionInput {
  # The composite ID of an extension installation <extensionID:version:channelID>.
  extensionInstallationID: ID!
}

# The resulting payload after a deactivateExtension mutation.
type DeactivateExtensionPayload {
  # The resulting extension installation record from the deactivate.
  installedExtension: ExtensionInstallation!
}

# Error associated with mutation DeclineOrganizationInvite.
type DeclineOrganizationInviteError {
  # Error code.
  code: DeclineOrganizationInviteErrorCode!
}

# Client error code.
enum DeclineOrganizationInviteErrorCode {
  # Internal error.
  INTERNAL_ERROR
  # Invitation not found.
  NOT_FOUND
  # Permission Denied.
  PERMISSION_DENIED
}

# Input to the DeclineOrganiztaionInvite mutation.
input DeclineOrganizationInviteInput {
  # ID of the invite to decline.
  organizationInviteID: ID!
}

# Output from the DeclineOrganizationInvite mutation.
type DeclineOrganizationInvitePayload {
  # The possible error returned from service.
  error: DeclineOrganizationInviteError
}

# DefaultPanel is the normal panel type that displays text and images.
type DefaultPanel implements Panel {
  # description is markdown-formatted text to be displayed below the title and image.
  # If the panel doesn't have a description this will be null.
  description: String
  # id is a unique identifier for the panel.
  id: ID!
  # imageURL is a URL to an image to be displayed at the top of the panel (but below the header).
  # If the panel doesn't use an image this will be null.
  imageURL: String
  # linkURL is the URL to navigate to when a user clicks on the image.
  # If the panel's image doesn't link anywhere this will be null.
  linkURL: String
  # title is the header text to display in the panel.
  # If the panel doesn't have a title this will return null.
  title: String
  # type is `PanelType.DEFAULT`.
  type: PanelType!
}

# DeferredPrimePayout is the earning that has been deferred to future payout cycles.
type DeferredPrimePayout {
  # totalPayoutAmount is the total amount for this payout.
  totalPayoutAmount: Int!
}

# Inputs for deleting all videos by channel id mutation.
input DeleteAllChannelVideosInput {
  # The ID of the channel to delete all videos from.
  channelID: ID!
}

# The returned payload from the DeleteAllChannelVideos mutation.
type DeleteAllChannelVideosPayload {
  # The status for this mutation.
  status: DeleteAllChannelVideosStatus
}

# Status associated with mutation DeleteAllChannelVideos.
type DeleteAllChannelVideosStatus {
  # Error code.
  code: DeleteAllChannelVideosStatusCode!
}

# The status codes for this mutation.
enum DeleteAllChannelVideosStatusCode {
  # Deletion job was successful started.
  SUCCESS
  # User does not have permission to delete videos.
  FORBIDDEN
  # Internal error.
  INTERNAL_ERROR
  # Invalid Argument.
  INVALID_ARGUMENT
  # Unknown Error.
  UNKNOWN
}

# The input for delete bits badge tier emoticon.
input DeleteBitsBadgeTierEmoticonInput {
  # channelID is the owner of the emoticon being deleted.
  channelID: ID!
  # emoteID is the unique identifier for the emote.
  emoteID: ID!
  # The visual representation of the emote.
  # For example, "O_o" instead of "(O|o)_(o|O)".
  text: String!
  # threshold is the badge tier threshold associated with this emoticon.
  threshold: Int!
}

# Result of delete bits badge tier emoticon.
type DeleteBitsBadgeTierEmoticonPayload {
  # Time that the emoticon got deleted.
  deletedAt: Time
}

# Inputs for deleting a celebration.
input DeleteCelebrationInput {
  # ID of celebration to delete.
  celebrationID: ID!
  # ID of channel where the celebration to delete exists.
  channelID: ID!
}

# Outputs from the create celebration mutation.
type DeleteCelebrationPayload {
  # If present, there was an error with the request.
  error: CelebrationError
}

# Inputs for the mutation. channel ID and a list of phrases to be deleted.
input DeleteChannelBlockedTermByIDInput {
  # channelID is the owner of the term being deleted.
  channelID: ID!
  # id of the term to be deleted.
  id: ID!
}

# The returned payload from the mutation.
type DeleteChannelBlockedTermByIDPayload {
  # Mutation error caused by the user input.
  error: DeleteChannelBlockedTermError
}

# Errors that the mutation returns.
type DeleteChannelBlockedTermError {
  # The error code that the mutation returned.
  code: DeleteChannelBlockedTermErrorCode!
}

# The errors returned from this mutation.
enum DeleteChannelBlockedTermErrorCode {
  # User does not have permission to delete blocked term in channel.
  NO_PERMISSIONS
}

# Inputs for the deleting a channel's clip.
input DeleteChannelClipsInput {
  # channelID is the channel's ID.
  channelID: ID!
}

# The returned payload from the mutation.
type DeleteChannelClipsPayload {
  # channelID is the channel's ID.
  channelID: ID!
}

# Inputs for the mutation. channel ID and a list of phrases to be deleted.
input DeleteChannelPermittedTermByIDInput {
  # channelID is the ID of the owner of the permitted term being deleted.
  channelID: ID!
  # the ID of the term to be deleted.
  id: ID!
}

# Returned payload of the mutation.
type DeleteChannelPermittedTermByIDPayload {
  # Mutation error caused by the user input.
  error: DeleteChannelPermittedTermError
}

# The errors returned from this mutation.
type DeleteChannelPermittedTermError {
  # Error code that was returned.
  code: DeleteChannelPermittedTermErrorCode!
}

# The possible error types returned from this mutation.
enum DeleteChannelPermittedTermErrorCode {
  # User does not have permission to delete Permitted term in channel.
  NO_PERMISSIONS
}

# The input for deleteChatMessage.
input DeleteChatMessageInput {
  # The channel the message was sent in.
  channelID: ID!
  # The UUID of the message to be deleted.
  messageID: ID!
}

# The returned payload for deleteChatMessage.
type DeleteChatMessagePayload {
  # The returned message.
  message: DeletedMessage
  # The response codes for this mutation.
  responseCode: DeleteChatMessageStatusCode!
}

# The response codes for this mutation.
enum DeleteChatMessageStatusCode {
  # Deletion was successful.
  SUCCESS
  # Deletion was successful. Target user is staff.
  SUCCESS_STAFF
  # User does not have permission to delete messages.
  FORBIDDEN
  # Target is the broadcaster.
  TARGET_IS_BROADCASTER
  # Target is another moderator.
  TARGET_IS_MODERATOR
}

# Error returned after attempting to delete a cheermote tier.
type DeleteCheermoteTierError {
  # The error code associated with this error.
  code: DeleteCheermoteTierErrorCode!
}

# Possible error codes for DeleteCheermoteTierError.
enum DeleteCheermoteTierErrorCode {
  # The user is not allowed to delete this cheermote tier.
  PERMISSION_DENIED
  # Unknown error.
  UNKNOWN
}

# The input for delete cheermote tier.
input DeleteCheermoteTierInput {
  # Threshold of the cheermote tier to be deleted.
  tierThreshold: CheermoteTierThreshold!
  # ID of the owner of the cheermote tier being deleted.
  userID: ID!
}

# Result of delete cheermote tier.
type DeleteCheermoteTierPayload {
  # Time that the cheermote tier got deleted.
  deletedAt: Time
  # Error returned after attempting to delete a cheermote tier.
  error: DeleteCheermoteTierError
}

# DeleteClipsInput accepts either a list of slugs, a video id, or a broadcast id
# to determine the clips to delete.
input DeleteClipsInput {
  # The id of the broadcast to delete clips from.
  broadcastID: ID
  # The list of clip slugs to be deleted.
  slugs: [ID!]
  # The id of the video to delete clips from.
  videoID: ID
}

# DeleteClipsPayload returns the deleted clips. Only the slug and id can be accessed
# from the returned list of deleted clips.
type DeleteClipsPayload {
  # The clips that were deleted. Only Slug and ID can be accessed.
  clips: [Clip]!
  # The amount of clips that were deleted.
  count: Int!
}

# DeleteCollectionInput accepts a collection ID to delete a collection.
input DeleteCollectionInput {
  # The id of the collection to be deleted.
  collectionID: ID!
}

# DeleteCollectionPayload resolves the deleted collection.
type DeleteCollectionPayload {
  # The collection that was just deleted.
  collection: Collection!
}

# Delete community goal error.
type DeleteCommunityPointsCommunityGoalError {
  # The error code.
  code: DeleteCommunityPointsCommunityGoalErrorCode!
}

# Delete community goal error code.
enum DeleteCommunityPointsCommunityGoalErrorCode {
  # The goal was not found.
  NOT_FOUND
  # The current user is not allowed to delete community goals for this channel.
  FORBIDDEN
  # An unknown error occurred.
  UNKNOWN
}

# Delete community goal input.
input DeleteCommunityPointsCommunityGoalInput {
  # The channel.
  channelID: ID!
  # The community goal.
  goalID: ID!
}

# Delete community goal payload.
type DeleteCommunityPointsCommunityGoalPayload {
  # The error, if any.
  error: DeleteCommunityPointsCommunityGoalError
  # The community goal that was deleted.
  goal: CommunityPointsCommunityGoal
}

# An error from deleting a custom Community Points reward in a channel.
type DeleteCommunityPointsCustomRewardError {
  # An identifier for the error that occurred.
  code: DeleteCommunityPointsCustomRewardErrorCode!
}

# The possible reasons deleting a custom Community Points reward in a channel could fail.
enum DeleteCommunityPointsCustomRewardErrorCode {
  # An unexpected error occurred.
  UNKNOWN
  # The current user is not allowed to delete a reward in this channel.
  FORBIDDEN
  # The reward was not found.
  NOT_FOUND
}

# Input for deleting a custom Community Points reward in a channel.
input DeleteCommunityPointsCustomRewardInput {
  # The channel ID that the reward is being deleted in.
  channelID: ID!
  # The ID of the reward being deleted.
  rewardID: ID!
  # Rewards cannot be deleted while they have unfulfilled redemptions.
  # All unfulfilled redemptions will be set to this new state asynchronously after the reward is deleted.
  unfulfilledRedemptionsNewStatus: CommunityPointsCustomRewardRedemptionStatus = FULFILLED
}

# The response from deleting a custom Community Points reward in a channel.
type DeleteCommunityPointsCustomRewardPayload {
  # An error that occurred while deleting a custom Community Points reward in a channel.
  error: DeleteCommunityPointsCustomRewardError
  # The now deleted reward.
  reward: CommunityPointsCustomReward
}

# Delete a Competition.
input DeleteCompetitionInput {
  # Unique Competition Id.
  id: ID!
}

# Result of the remove operation.
type DeleteCompetitionPayload {
  # The deleted competition.
  competition: Competition
  # Used for competition mutation errors.
  error: CompetitionError
}

# Delete tags associated with CLIP, STREAM, or VOD with contentID.
input DeleteContentTagsInput {
  # ID of the channel owning the content.
  authorID: ID!
  # ID of content: Channel ID for Streams, Slugs for Clips, and VOD ids for VODs.
  contentID: ID!
  # Type of content being returned. Can only be of values CLIP, STREAM, or VOD.
  contentType: ContentType!
  # List of tag IDs to be deleted from the content.
  tagIDs: [ID!]!
}

# Result of mutation is the contentID.
type DeleteContentTagsPayload {
  # Content which tags have been deleted from.
  content: TaggedContent
}

# Error codes for issues that may occur when trying to delete a layout.
enum DeleteDashboardViewErrorCode {
  # An unhandled error.
  UNKNOWN
  # The layoutID argument is required.
  INVALID_ARGUMENT_LAYOUTID
  # The userID argument is required.
  INVALID_ARGUMENT_USERID
  # One or more unspecified arguments are invalid. These are not
  # user-actionable, but might indicate a logic error.
  INVALID_ARGUMENT
}

# Deletes a layout with the specified id
# Input for updating properties of an existing Mosaic layout.
# Must specify the id of the layout, which is validated based
# on the current userID.
# Input for deleting the existing layout.
input DeleteDashboardViewInput {
  # The id of the specific layout to be deleted. This identifies a combination of
  # type and channel for this user, and has an additional unique component to
  # distinguish it from other layouts for this type and channel.
  id: ID!
}

# Result of the deleteDashboardView mutation.
type DeleteDashboardViewPayload {
  # Represents an error when attempting to delete a layout.
  errorCode: DeleteDashboardViewErrorCode
}

# The input required when making a request to delete a user's default payment method for a given provider.
input DeleteDefaultPaymentMethodInput {
  # The payment provider we're deleting the payment method on.
  provider: PaymentProvider!
  # The user to delete default payment method for.
  userID: ID!
}

# Payload returned after deleting a default payment method for a given provider.
type DeleteDefaultPaymentMethodPayload {
  # Time when payment method was deleted.
  updatedAt: Time
  # User who had their default payment method deleted.
  user: User
}

# DeleteDeviceTokenInput accepts a token and user ID and deletes that pair from the database.
input DeleteDeviceTokenInput {
  # The token to be deleted.
  deviceToken: ID!
  # ID for the user associated with the device token.
  userID: ID!
}

# The response from deleting a push notification token from a user.
type DeleteDeviceTokenPayload {
  # The ID of the token that was deleted.
  deviceToken: ID!
}

# A deleted message sent by a user to a stream chat.
type DeletedMessage {
  # Content of the deleted message.
  content: RoomMessageContent!
  # UUID of the deleted message.
  id: ID!
  # Sender of the message.
  sender: User
}

# DeletedMessageDisplaySetting represents the possible settings for how deleted messages should be displayed.
enum DeletedMessageDisplaySetting {
  # LEGACY hides deleted messages behind a clickable '<message_deleted>' chat line.
  LEGACY
  # BRIEF removes all deleted messages and inserts a system message that reports the number of deleted messages.
  BRIEF
  # DETAILED the deleted message is readable but strikethrough and grayed out.
  DETAILED
}

# DeleteDropCampaignInput has fields required to delete a campaign.
input DeleteDropCampaignInput {
  # The id of the Drop campaign to be deleted.
  campaignID: ID!
}

# DeleteDropCampaignPayload returns the result of the deletion.
type DeleteDropCampaignPayload {
  # A potential error being thrown.
  # A mapped error returned by the drops management service.
  error: DropsError
}

# DeleteDropInput has fields required to delete a drop.
input DeleteDropInput {
  # The id of the Drop to be deleted.
  dropID: ID!
}

# DeleteDropPayload returns the result of the deletion.
type DeleteDropPayload {
  # A potential error being thrown.
  # A mapped error returned by the drops management service.
  error: DropsError
}

# Error returned after attempting to delete an emote.
type DeleteEmoteError {
  # The error code associated with this error.
  code: DeleteEmoteErrorCode!
}

# Possible error codes for DeleteEmoteError.
enum DeleteEmoteErrorCode {
  # The specified emote does not exist.
  EMOTE_NOT_FOUND
  # The user is not allowed to delete this emote.
  PERMISSION_DENIED
  # Unknown error.
  UNKNOWN
}

# The input for delete emote.
input DeleteEmoteInput {
  # ID of the emote to be deleted.
  id: ID!
}

# Result of delete emote.
type DeleteEmotePayload {
  # Error returned after attempting to delete an emote.
  error: DeleteEmoteError
}

# Error types returned for the deleteExtension mutation.
enum DeleteExtensionError {
  # Returned when the extension id was not specified.
  MISSING_EXTENSION_ID
  # Returned when the id specified could not be found.
  EXTENSION_NOT_FOUND
  # Returned when the calling user does not have access to delete the extension.
  UNAUTHORIZED
}

# DeleteExtensionImageError is an error associated with the deleteExtensionImage mutation.
enum DeleteExtensionImageError {
  # User is unable to make modifications to the extension.
  UNAUTHORIZED
  # Version specified is invalid.
  INVALID_VERSION
  # Cannot find url in the manifest.
  CANNOT_FIND_URL_IN_MANIFEST
  # Invalid image url.
  INVALID_IMAGE_URL
}

# Information needed to delete images on extension.
input DeleteExtensionImageInput {
  # The extension:version the images are for.
  extensionID: ID!
  # Urls to be deleted.
  urls: [String!]!
}

# DeleteExtensionImagePayload returns the update Extension manifest.
type DeleteExtensionImagePayload {
  # The error when the mutation fails to update an extension.
  error: DeleteExtensionImageError
  # The updated extension manifest.
  manifest: ExtensionManifest
}

# Inputs for the deleteExtension mutation.
input DeleteExtensionInput {
  # ID for the extension being deleted.
  id: ID!
}

# The returned payload from the deleteExtension mutation.
type DeleteExtensionPayload {
  # Error response from the deleteExtension mutation.
  # null if the delete was successful.
  error: DeleteExtensionError
}

# DeleteExtensionImageError is an error associated with the deleteExtensionSecrets mutation.
enum DeleteExtensionSecretsError {
  # User is unable to delete the extension secrets.
  UNAUTHORIZED
}

# The information we need to delete the extension's secrets.
input DeleteExtensionSecretsInput {
  # The extensionID whose secrets should be removed.
  extensionID: ID!
}

# Returns nothing but an error, should one occur.
type DeleteExtensionSecretsPayload {
  # An useful error for the user.
  error: DeleteExtensionSecretsError
}

# Inputs for the mutation. Loyalty Badge to be deleted by channelID, badgeID, and channelTenureMethodID.
input DeleteLoyaltyBadgeInput {
  # badgeID correlated to the badge being deleted.
  badgeID: ID!
  # channelID correlated to the badge being deleted.
  channelID: ID!
  # channelTenureMethodID uniquely identifies the badge being deleted.
  channelTenureMethodID: ID!
}

# The returned payload from the mutation for Deleting a Loyalty Badge.
type DeleteLoyaltyBadgePayload {
  # LoyaltyBadge object that was deleted.
  badge: LoyaltyBadge
}

# Output from the DeleteModeratorComment mutation.
input DeleteModeratorCommentInput {
  # ID of the comment to be deleted.
  ID: ID!
}

# Output from the DeleteModeratorComment mutation.
type DeleteModeratorCommentPayload {
  # The deleted comment.
  comment: ModLogsComment
}

# Contains a list of IDs of content attributes that are to be deleted.
input DeleteMultiviewContentAttributesInput {
  # A list of content attribute IDs.
  IDs: [ID!]!
}

# Contains the results from the delete request.
type DeleteMultiviewContentAttributesPayload {
  # Unprocessed content attributes.
  failedDeletes: [MultiviewContentAttribute!]!
  # Processed content attributes.
  succeededDeletes: [MultiviewContentAttribute!]!
}

input DeleteNotificationInput {
  # The notification to delete.
  id: ID!
}

type DeleteNotificationPayload {
  # The notification that was deleted. Only the ID is accessible.
  notification: OnsiteNotification!
}

input DeletePanelInput {
  id: ID!
}

type DeletePanelPayload {
  panel: Panel!
}

input DeletePostInput {
  postID: ID!
}

type DeletePostPayload {
  post: Post
}

# Data required to delete recommendation feedback.
input DeleteRecommendationFeedbackInput {
  # The id of the feedback.
  feedbackID: ID!
  # The page this event was fired from.
  sourceItemPage: String!
}

# Returns the created feedback item back to the client.
type DeleteRecommendationFeedbackPayload {
  # The id of the feedback you just deleted.
  feedbackID: ID!
}

input DeleteRoomInput {
  roomID: ID!
}

input DeleteRoomMessageInput {
  messageID: ID!
  roomID: ID!
}

type DeleteRoomMessagePayload {
  message: RoomMessage
}

type DeleteRoomPayload {
  room: Room
}

# The possible errors when deleting a schedule.
enum DeleteScheduleError {
  # Not authorized to delete this user schedule.
  PERMISSION_DENIED
}

# The input to delete a schedule.
input DeleteScheduleInput {
  # The channel ID.
  channelID: ID!
  # The schedule ID.
  scheduleID: ID!
}

# The payload returned after deleting a schedule.
type DeleteSchedulePayload {
  # The channel with the deleted schedule.
  channel: Channel
  # The possible error.
  error: DeleteScheduleError
}

# The possible errors when deleting a schedule segment.
enum DeleteScheduleSegmentError {
  # Not authorized to delete this segment.
  PERMISSION_DENIED
}

# The input to delete a schedule segment.
input DeleteScheduleSegmentInput {
  # The schedule id.
  scheduleID: ID!
  # The segment id to delete.
  segmentID: ID!
}

# The returned payload when deleting a schedule segment.
type DeleteScheduleSegmentPayload {
  # The possible error.
  error: DeleteScheduleSegmentError
  # The updated schedule without the deleted segment.
  schedule: Schedule
}

# Mutation input to delete a social media item by ID under the given channelID.
input DeleteSocialMediaInput {
  # The ID of the channel the social media belongs to.
  channelID: ID!
  # The ID of the social media item.
  id: ID!
}

# DeleteSocialMediaPayload returns an error, if any.
type DeleteSocialMediaPayload {
  # The channel of the social media that was deleted.
  channel: Channel
}

# Errors from deleteSquadStreamInvitation mutation.
type DeleteSquadStreamInvitationError {
  # Error from request to delete invitation.
  code: DeleteSquadStreamInvitationErrorCode!
}

# Possible errors that this mutation returns.
enum DeleteSquadStreamInvitationErrorCode {
  # Invitation to be deleted does not exist.
  INVITATION_NOT_FOUND
  # Squad associated with the invitation does not exist.
  SQUAD_NOT_FOUND
  # User does not have permissions to delete invitation.
  UNAUTHORIZED
  # Invitation not in pending or rejected state cannot be deleted.
  INVITATION_CANNOT_BE_DELETED
}

# Inputs to the deleteSquadStreamInvitation mutation.
input DeleteSquadStreamInvitationInput {
  # ID of the invitation to be deleted.
  invitationID: ID!
}

# Outputs from the deleteSquadStreamInvitation mutation.
type DeleteSquadStreamInvitationPayload {
  # Error from mutation if exists.
  error: DeleteSquadStreamInvitationError
  # The deleted invitation.
  invitation: SquadStreamInvitation
}

# Error that may be returned by the DeleteStreamAuthorizedUser mutation.
type DeleteStreamAuthorizedUserError {
  # Type of mutation error.
  code: DeleteStreamAuthorizedUserErrorCode!
}

# DeleteStreamAuthorizedUserErrorCode is the client error type that occurred during the DeleteStreamAuthorizedUser mutation.
enum DeleteStreamAuthorizedUserErrorCode {
  # Unable to assign the Targeted user to stream on behalf of the broadcaster.
  TARGET_USER_UNRETURNABLE
  # The broadcaster is not found.
  CHANNEL_NOT_FOUND
  # Maximum limit for adding authorized user is reached.
  MAX_ACCOUNT_LIMIT
  # Permission denied to add an authorized user.
  PERMISSION_DENIED
  # Invalid argument to add an authorized user.
  INVALID_ARGUMENT
}

# DeleteStreamAuthorizedUserInput contains the channelID for the broadcaster and the authorized userID.
input DeleteStreamAuthorizedUserInput {
  # authorizedUserID for an authorized user who was allowed to stream on behalf of broadcaster.
  authorizedUserID: ID!
  # channelID of the broadcaster.
  channelID: ID!
}

# DeleteStreamAuthorizedUserPayload contains the VideoStreamSettings with updated authorized users.
type DeleteStreamAuthorizedUserPayload {
  # The updated channel of broadcaster.
  channel: Channel
  # Error code.
  error: AddStreamAuthorizedUserError
}

# Inputs for the deleting clips made by user.
input DeleteUserClipsInput {
  # userID is the user's ID.
  userID: ID!
}

# The returned payload from the mutation.
type DeleteUserClipsPayload {
  # userID is the user's ID.
  userID: ID!
}

# Inputs for the DeleteUserColors mutation.
input DeleteUserColorsInput {
  # The ID of the user whose creator color is being deleted.
  userID: ID!
}

# The returned payload from the DeleteUserColors mutation.
type DeleteUserColorsPayload {
  # The modified user.
  user: User
}

type DeleteVideoCommentPayload {
  # The comment that was deleted.
  comment: VideoComment!
}

# Inputs for the deleting videos by id mutation.
input DeleteVideosInput {
  # The IDs of the videos to be deleted.
  videoIDs: [ID!]!
}

# The returned payload from the DeleteVideos mutation.
type DeleteVideosPayload {
  # The list of videos deleted.
  videos: [Video!]
}

# Input information for deleting a thumbnail from a video.
input DeleteVideoThumbnailInput {
  # The thumbnail url path.
  path: String!
  # ID of the video the thumbnail will be deleted from.
  videoID: ID!
}

# Response to a request to delete a video thumbnail.
type DeleteVideoThumbnailPayload {
  # Video representing the video from which a thumbnail was deleted.
  video: Video
}

# Defines ads management attributes for channel.
type Density {
  # Ad schedule for ads management.
  adSchedule: [AdSlot!]
  # Duration of auto ads.
  autoAdLengthSeconds: Int
  # Period inbetween each auto ad.
  autoAdPeriodMinutes: Int
  # If channel is a custom contract partner.
  isCCP: Boolean!
  # Minutes elapsed since stream started.
  minutesElapsed: Int
  # If contract is enforced on this channel.
  shouldEnforceContract: Boolean!
  # Ad density target for a specific channel.
  targetAdMinutes: Int
  # Total amount of ad time.
  totalAdSeconds: Int
  # If channel has ad schedule enabled.
  isAdScheduleEnabled: Boolean!
  # The number of seconds between each ad.
  interval: AdScheduleConfig!
  # How long the ad is in seconds.
  duration: AdScheduleConfig!
  # How long into the stream before ad begins.
  startDelay: AdScheduleConfig!
  # Configuration for reminder functionality.
  reminder: AdReminderConfig!
  # Configuration for snooze functionality.
  snooze: AdSnoozeConfig!
}

input DenyRejectedChatMessageInput {
  id: ID!
}

type DenyRejectedChatMessagePayload {
  message: RejectedChatMessage
}

# Input to the denyRejectedCheer mutation.
input DenyRejectedCheerInput {
  # Client-generated unique ID used to prevent a cheer from being re-sent (thus spending double bits).
  # The server will reject any request with an ID that has already been used.
  id: ID!
  # ID of the user whose message is automodded.
  targetUserID: ID!
}

# Payload from the denyRejectedCheer mutation.
type DenyRejectedCheerPayload {
  # Client-generated unique ID used to prevent a cheer from being re-sent (thus spending double bits).
  # The server will reject any request with an ID that has already been used.
  id: ID!
}

# Required input to deny an unban request on a channel.
input DenyUnbanRequestInput {
  # ID of the unban request to be resolved.
  id: ID!
  # Optional message from the resolver to be shown to the unban requester.
  resolverMessage: String
}

# Result of denying an unban request.
type DenyUnbanRequestPayload {
  # Used for errors arising from resolving unban request.
  error: UnbanRequestError
  # The resolved unban request.
  unbanRequest: UnbanRequest
}

# Inputs for deselecting a channel badge.
input DeselectChannelBadgeInput {
  # ID of the channel this badge is selected on.
  channelID: ID!
}

# The output for the deselect channel badge mutation.
type DeselectChannelBadgePayload {
  # The channel (user object of channel) this badge is deselected on.
  user: User
}

# The output for the deselect global badge mutation.
type DeselectGlobalBadgePayload {
  # The user (contains the badge status).
  user: User
}

# Defines AutoMod category levels for a Channel.
type DetailedAutoModConfiguration {
  # This field will be a value between 0 and 4, inclusive.
  ableismLevel: Int
  # This field will be a value between 0 and 4, inclusive.
  aggressionLevel: Int
  # This field will be a value between 0 and 4, inclusive.
  homophobiaLevel: Int
  # This field will be a value between 0 and 4, inclusive.
  misogynyLevel: Int
  # This field will be a value between 0 and 4, inclusive.
  nameCallingLevel: Int
  # This field will be a value between 0 and 4, inclusive.
  profanityLevel: Int
  # This field will be a value between 0 and 4, inclusive.
  racismLevel: Int
  # This field will be a value between 0 and 4, inclusive.
  sexualityLevel: Int
  # DEPRECATED: nWordLevel is the level of "nWord" category. Will be deprecated when inference is upgraded to V4.
  nWordLevel: Int @deprecated
  # DEPRECATED: whiteNationalistLevel is the level of "whiteNationalist" category.
  # Will be deprecated when inference is upgraded to V4.
  whiteNationalistLevel: Int @deprecated
}

# Defines AutoMod category levels for a Channel.
input DetailedAutoModLevelsInput {
  # This field will be a value between 0 and 4, inclusive.
  ableismLevel: Int
  # This field will be a value between 0 and 4, inclusive.
  aggressionLevel: Int
  # This field will be a value between 0 and 4, inclusive.
  homophobiaLevel: Int
  # This field will be a value between 0 and 4, inclusive.
  misogynyLevel: Int
  # This field will be a value between 0 and 4, inclusive.
  nameCallingLevel: Int
  # This field will be a value between 0 and 4, inclusive.
  profanityLevel: Int
  # This field will be a value between 0 and 4, inclusive.
  racismLevel: Int
  # This field will be a value between 0 and 4, inclusive.
  sexualityLevel: Int
}

# A Directory is a container of content â€“ Streams, Videos, and Clips â€“ on Twitch.
interface Directory {
  # URL to an avatar image.
  # The image dimensions are specifiable via the `height` and `width` parameters.
  #
  # If `height` or `width` are not specified, the URL will contain
  # the template strings `{height}
` and/or `{width}
` in their respective places.
  avatarURL(width: Int, height: Int): String
  # Number of broadcasters currently broadcasting in this directory.
  broadcastersCount: Int
  # URL to a cover image.
  # The image dimensions are specifiable via the `height` and `width` parameters.
  #
  # If `height` or `width` are not specified, the URL will contain
  # the template strings `{height}
` and/or `{width}
` in their respective places.
  coverURL(width: Int, height: Int): String
  # The type of directory â€“ community or game.
  directoryType: DirectoryType
  # The name to display for the directory.
  displayName: String!
  # Number of users that follow this directory.
  followersCount: Int
  # The directory's unique Twitch identifier.
  id: ID!
  # The canonical name of the directory.
  name: String!
  # Get a page of live streams broadcasting in this directory.
  # If no language filters are provided all languages will be returned.
  # Tags are an array of tag ID as optional filters for streams.
  streams(
    first: Int = 10
    after: Cursor
    languages: [String!]
    tags: [String!]
  ): StreamConnection
  # Number of viewers currently watching a stream which is in this directory.
  viewersCount: Int
}

# Paginated list of Directories.
# Implements the Relay cursor connections specification.
# See: https://facebook.github.io/relay/graphql/connections.htm.
type DirectoryConnection {
  edges: [DirectoryEdge]!
  pageInfo: PageInfo!
}

# Contains information about a Directory's relationship to a given page (connection),
# and the Directory itself.
type DirectoryEdge {
  cursor: Cursor
  node: Directory
}

# The set of types of directory.
enum DirectoryType {
  # A game.
  GAME
}

# Disable Prerolls Ability contains the properties used by the Disable Prerolls Feature.
type DisablePrerollsAbility {
  # DisablePrerollsFreeTime define relation of midroll-length:preroll-free-time-earned on this channel.
  disablePrerollsTimeEarned: [DisablePrerollsFreeTime!]
  # If "disable prerolls for midrolls" feature is accessible on this channel.
  hasDisablePrerollsAbilityAccess: Boolean
  # If "disable prerolls for midrolls" feature is enabled on this channel.
  hasDisablePrerollsAbilityEnabled: Boolean
  # If disable preroll notifications are enabled on this channel.
  hasDisablePrerollsNotificationsEnabled: Boolean
  # Maximum amount of preroll-free time (in seconds) that can be accumulated on this channel.
  maxDisablePrerollsCapacity: Int
}

# Disable Prerolls Free Time maps the relationship between a specific midroll
# length and amount of preroll-free time earned for a channel.
type DisablePrerollsFreeTime {
  # The length (in seconds) of a midroll ad.
  midrollLengthSeconds: Int!
  # The amount of preroll-free time (in seconds) earned on this channel for running midroll of related length.
  prerollFreeTimeSeconds: Int!
}

# Error returned during a invalid user request.
type DisableTwoFactorError {
  # Error code returned by the backend.
  code: DisableTwoFactorErrorCode!
  # The localized external error message.
  message: String!
}

# The possible error enums returned while trying to disable two factor authentication.
enum DisableTwoFactorErrorCode {
  # The user needs to re-authenticate to perform this operation.
  REAUTH_NEEDED
  # Something unexpected occured.
  UNKNOWN_ERROR
}

# The required input for a disableTwoFactor mutation.
input DisableTwoFactorInput {
  # The ID of the user that is requesting to disable two factor authentication.
  userID: ID!
}

# The result of a disableTwoFactorPayload mutation.
type DisableTwoFactorPayload {
  # error code and localized error.
  error: DisableTwoFactorError
}

# Error type that DisableUserAccountPayload returns.
type DisableUserAccountError {
  # Error Code, see DisableUserAccountErrorCode.
  code: DisableUserAccountErrorCode!
}

# DisableUserAccountErrorCode is an error while deleting a user.
enum DisableUserAccountErrorCode {
  # User ID is invalid.
  INVALID_USER_ID
  # Requester is not authorized to make the requested change.
  UNAUTHORIZED
}

# Inputs to the disableUserAccount mutation.
input DisableUserAccountInput {
  # Reason for a user to disable their account.
  description: String
  # Permanently delete account.
  # false means account will be disabled and can be reenabled in the future.
  # true means the account will be disabled and will be permanently deleted after a period of time.
  # default is false.
  isDelete: Boolean
  # The ID of the user to disable or delete.
  # Only the requester's user ID is allowed.
  userID: ID!
}

# Output from the disableUserAccount mutation.
type DisableUserAccountPayload {
  # Error if operation failed from user error.
  error: DisableUserAccountError
  # User that has been deleted or disabled.
  user: User
}

# DiscountBreakdown shows discounted pricing for a promotional offer.
type DiscountBreakdown {
  # The numerical price of a discounted offer.
  price: Int!
  # The localized tax rate of a offer.
  tax: Int!
  # The total discounted price given price and tax.
  total: Int!
}

# DEPRECATED: to be replaced by SubscriptionPromotionDiscountType.
# Valid discount types for subscription products.
enum DiscountType {
  # Percent discount type, eg. "50%".
  PERCENT_OFF
}

input DismissFriendRecommendationInput {
  # The recommendation to the authenticated user to become friends with a user with ID targetID will be removed.
  targetID: ID!
}

type DismissFriendRecommendationPayload {
  # The user who was previously a friend recommendation to the target user.
  user: User
}

type DismissRitualTokenError {
  code: DismissRitualTokenErrorCode!
}

enum DismissRitualTokenErrorCode {
  # Token is not in a status that can be dismissed.
  TOKEN_NOT_AVAILABLE
  # Token does not exist.
  TOKEN_NOT_FOUND
}

# DismissRitualTokenInput is the input when dismissing a ritual token.
input DismissRitualTokenInput {
  # The channel to dismiss the ritual token in.
  channelID: ID!
  # The type of ritual token to dismiss.
  type: RitualTokenType!
}

# DismissRitualTokenPayload is the response when dismissing a ritual token.
type DismissRitualTokenPayload {
  error: DismissRitualTokenError
  token: RitualToken
}

# Input for dismissing a video's suggested highlight.
input DismissVideoSuggestedHighlightInput {
  # VideoID of the video whos automated highlight suggestions were dismissed.
  videoID: ID!
}

# Ouput for dismissing a video's suggested highlight.
type DismissVideoSuggestedHighlightPayload {
  # Video whos automated highlight suggestions were dismissed.
  video: Video
}

# Contains all of the information about a Drop awarded to a user.
type Drop {
  # The game that awarded the Drop.
  game: Game @deprecated
  # The assigned ID of this drop.
  id: ID! @deprecated
  # The image URL of the Drop. Images are 80x80 pixels.
  imageURL: String! @deprecated
  # The developer-provided name of the Drop.
  name: String! @deprecated
}

# A mapping of the client ID set to determine whether a user has set up account linking for the game.
type DropAccountLink {
  # The associated clientID for a game used to determine if users have an account link
  # created between tuid and in-game userID.
  clientID: ID!
  # The date when this clientID was first added.
  updatedAt: Time!
}

# Contains all of the information about a Drop's action stating what happens when a drop is triggered. //To be deprecated.
type DropAction {
  # The time in seconds a user has to claim a drop after occurence.
  claimDurationSeconds: Int! @deprecated
  # The description of this drop's action.
  description: String! @deprecated
  # The Action ID.
  id: ID! @deprecated
  # The type of action happening when a drop is triggered.
  type: DropActionType! @deprecated
}

# A list of all supported Action types. //To be deprecated.
enum DropActionType {
  # Returned in case the action type cannot be identified.
  UNKNOWN_ACTION_TYPE @deprecated
  # Returned in case the action starts a user claim flow.
  USER_CLAIM_FLOW @deprecated
}

# Data about the award of a drop to a user. // deprecated.
type DropAward {
  # The timestamp when the Drop was awarded to the user.
  awardedAt: Time @deprecated
  # The drop that was awarded to the user.
  node: Drop @deprecated
  # The reason the Drop was awarded.
  reason: String @deprecated
}

# Contains all of the information about a Drop awarded to a user.
type DropBenefit {
  # The redirect URL where a user can link their account.
  accountLinkURL: String!
  # The time the benefit was created.
  createdAt: Time!
  # The display description of this award object. //To be deprecated.
  description: String! @deprecated
  # The limit of how often this benefit can globally be awarded to a user. Set to
  # -1 if the drop can be entitled unlimited amounts.
  # The per drop entitlementLimit of a reward is on DropObject.Drop2BenefitObject.
  entitlementLimit: Int!
  # The game that awarded the Drop.
  game: Game
  # The ID of this reward object.
  id: ID!
  # An image asset for this reward object.
  imageAssetURL: String!
  # Specifies if this benefit is considered for a game that is available on iOS.
  isIosAvailable: Boolean!
  # The display name of this award object.
  name: String!
  # The ID of the owner of the item for this reward.
  owner: User! @deprecated(reason: "Use DropBenefit.ownerOrganization instead")
  # The (RBAC) Organization that owns the drop benefit.
  ownerOrganization: Organization
}

# The DropBenefitEdge links a drop with a benefit and describes how many times that benefit
# can be granted by this drop. A benefit can be granted multiple times by event based drops.
# For example, a benefit could be granted every time the broadcaster gets a kill streak, up to
# 3 times.
type DropBenefitEdge {
  # The benefit description.
  benefit: DropBenefit!
  # The number of times a benefit has been claimed.
  claimCount: Int
  # A restriction of the benefit on how often it can be claimed within a drop.
  entitlementLimit: Int!
}

# A campaign a developer is running to give drops away to viewers of their game
# To be considered live, a campaign must be enabled with the current time
# being after the start but before the end times
# To apply to a particular channel a campaign must be live and additionally
# the channel must be playing an applicable game and either must be one of the
# applicable channels or the campaign must have an empty applicable channel list
# (where an empty list specifically means all channels are eligible).
type DropCampaign {
  # The URL users who aren't linked should click on to create a link that will
  # allow them create an account link for the developer of the game(s)
  # this campaign is for.
  accountLinkURL: String!
  # The only channels allowed to be eligible for the drop campaign.
  allow: DropCampaignACL
  # If isAvailableToAllChannels is false, applicableChannels is the list of
  # what channels this campaign is targeted to.  If the flag is true but the
  # list is empty, that means that all whitelisted users cannot be loaded.
  # An applicable channel must also be playing an applicable game for the
  # campaign to apply to the channel.
  applicableChannels: [User!] @deprecated
  # The games that this campaign is enabled on
  # A channel playing one of these games must be in the applicable channels
  # list or list must be empty for the campaign to apply to the channel.
  applicableGames: [Game!] @deprecated
  # The drops this campaign can award.
  awardableDrops: [Drop!] @deprecated
  # The channels blocked from being eligible for the drop campaign.
  block: DropCampaignACL
  # The URL users who aren't linked should click on to create a link that will
  # allow them create an account link for the developer of the game(s)
  # this campaign is for.
  connectionURL: String! @deprecated(reason: "Use accountLinkURL instead")
  # The description contains the full details about the campaign.
  description: String!
  # The URL that links to the details / marketing page for this campaign.
  detailsURL: String!
  # The time this campaign ends
  # To be considered live, a campaign must be enabled with the current time
  # being after the start but before the end times.
  endAt: Time!
  # Drops triggered by in-game events.
  eventBasedDrops: [EventBasedDrop!]
  # The Game associated with this campaign.
  game: Game
  # GUID identifying this campaign.
  id: ID!
  # An image asset for this campaign no larger than 160 x 160 pixels.
  imageURL: String!
  # Indicates if this campaign is available to all channels or if only some.
  # If false, applicableChannels should contain the channels where the campaign
  # is available.
  isAvailableToAllChannels: Boolean! @deprecated
  # If this campaign is enabled
  # To be considered live, a campaign must be enabled with the current time
  # being after the start but before the end times.
  isEnabled: Boolean! @deprecated
  # Drops that can be triggered by manual events.
  manualTriggerBasedDrops: [ManualTriggerBasedDrop!]
  # The name of the campaign.
  name: String!
  # This is the Organization (RBAC) that has ownership of the campaign and attached drops.
  owner: Organization
  # User specific data for the campaign.
  self: DropCampaignSelfEdge!
  # The time this campaign starts
  # To be considered live, a campaign must be enabled with the current time
  # being after the start but before the end times.
  startAt: Time!
  # The current status of the campaign.
  status: DropCampaignStatus!
  # Test viewers can participate in campaigns while the campaign is in the test status.
  testViewers: [User!]
  # Drops triggered by accumulating minutes watched on a game.
  timeBasedDrops: [TimeBasedDrop!]
  # The type of a campaign defines what type of drops are allowed to be added to the campaign.
  type: CampaignType!
}

# A toggleable access control list of channels given certain access to drop campaigns.
type DropCampaignACL {
  # The channels that are either granted or denied access.
  channels: [Channel!]
  # Whether the access list is currently in use.
  isEnabled: Boolean!
}

# DropCampaignSelfEdge returns user specific information about the drops campaign.
type DropCampaignSelfEdge {
  # Has the user linked their game account with the campaign.
  isAccountConnected: Boolean!
}

# Possible status of a drops campaign.
enum DropCampaignStatus {
  # Drop campaign is currently active.
  ACTIVE
  # The drop campaign is past its end date.
  EXPIRED
  # The drop campaign is currently in testing mode.
  TEST
  # The drop campaign is live but not yet past the start date.
  UPCOMING
  # The drop campaign has been turned off.
  DISABLED
}

# Contains all of the information about the channel seetings for a Drop.
type DropChannelSetting {
  # UserAccountConnected is a boolean specifying if a streamer has a connected
  # account link to the game required for the game developers to send drop related
  # game data for this user.
  isUserAccountConnected: Boolean!
}

# The drop that is closest to completing for the current user that is actively earning progress.
type DropCurrentSession {
  # The channelID where Progresso is currently tracking progress.
  channel: Channel
  # The number of minutes that the user has accrued toward completing the drop.
  currentMinutesWatched: Int!
  # The ID for the Drop that we're currently tracking (not surfaced; used for fulfillment).
  dropID: ID!
  # The Game name that we're tracking for the currently-tracked drop.
  game: Game
  # The total number of minutes required in order to complete the drop.
  requiredMinutesWatched: Int!
}

# Contains all of the information about a Drop awarded to a user.
type DropEligibility {
  # The remaining time in which this reward can be claimed.
  claimSecondsRemaining: Int!
  # Summary information for the drop the reward is claimed of.
  drop: DropObject!
    @deprecated(reason: "No longer supported. Use dropType instead.")
  # The unique ID of this drop instance.
  dropInstanceID: ID!
  # A single Drop. This could be either an event or time based drop.
  dropType: DropType!
  # Rewards available to the user for this drop and their statuses.
  rewards: [DropReward!]!
  # User eligibility for this drop instance.
  status: DropInstanceEligibilityStatus!
}

# Defines a condition that must be met for an in game event to trigger a drop.
type DropEventCondition {
  # Specifies the event to look for in the event payload.
  key: String!
  # The comparator of the value to the event payload.
  operator: DropEventConditionOperator!
  # Specifies the value to compare the event payload to.
  value: String!
}

# A measurement against an in-game event to determine whether the drop should trigger.
input DropEventConditionInput {
  # The key of the in-game event that can trigger the drop.
  key: String!
  # The operator to apply to the event.
  operator: DropEventConditionOperator!
  # The value of the in-game event that the operator is compared to.
  value: String!
}

# The operator used to compare the in-game event.
enum DropEventConditionOperator {
  # An unknown operator, only possible before the drop condition has been set.
  UNKNOWN
  # Less than.
  SMALLER
  # Less than or equal.
  SMALLER_EQUAL
  # Equal.
  EQUAL
  # Greater than.
  GREATER
  # Greater than or equal.
  GREATER_EQUAL
}

# DropImageType is the list of possible uses that an image can have for drops.
enum DropImageType {
  # Image for telling viewers that drops are available if they link accounts.
  LINK_NOTIFICATION
  # Image for showing a viewer what item a developer awarded as a drop.
  ITEM
}

# DropImageUploadInput has the fields required to upload a drop's image asset.
input DropImageUploadInput {
  # The ownerID of the content owner.
  ownerID: ID!
  # The ID for the referenced scope item.
  referenceID: ID!
  # The scope of what the image gets uploaded for.
  scope: Scope!
}

# SetDropCampaignStatusPayload returns the result of the creation/update.
type DropImageUploadPayload {
  # The ID of the image once uploaded.
  uploadID: ID
  # The URL to upload the image to.
  uploadURL: String
}

# Status enums for a drop instance.
enum DropInstanceEligibilityStatus {
  # User can claim all rewards.
  ELIGIBLE_FOR_ALL
  # User can claim some rewards.
  LIMITED
  # User can not claim any of the rewards in this drop instance.
  ENTITLEMENT_LIMIT_REACHED
  # User has already claimed this drop instance.
  DROP_INSTANCE_ALREADY_CLAIMED
  # The claim duration has expired and user can no longer claim this drop instance.
  EXPIRED
  # Unknown is returned if a status is returned from the backend that was not expected.
  UNKNOWN
}

# Contains all of the information about a Drop awardable to a user. // deprecated
# in favor of EventBasedDrop and TimeBasedDrop.
type DropObject {
  # The redirect URL where a user can link their account.
  accountLinkURL: String! @deprecated
  # The actions defining what happens after a drop is triggered.
  actions: [DropAction!]! @deprecated
  # The description of this drop.
  description: String! @deprecated
  # The URL that links to the details / marketing page for this drop.
  detailsURL: String! @deprecated
  # The date at which this drop can no longer occur.
  endDate: Time! @deprecated
  # The game associated with this drop.
  game: Game! @deprecated
  # The Drops ID.
  id: ID! @deprecated
  # An image asset for this drop.
  imageURL: String! @deprecated
  # The friendly name of this drop.
  name: String! @deprecated
  # The OrganizationID of the owner of this drop.
  ownerID: ID! @deprecated
  # The friendly name of the owner of this drop.
  ownerName: String! @deprecated
  # The Quest name for this specific Drop.
  questName: String! @deprecated
  # The rules defining what needs to happen to trigger this drop.
  rules: [DropRule!]! @deprecated
  # The date at which this drop can start to occur.
  startDate: Time! @deprecated
}

# DropPrecondition is the tuple of DropID and the DropPreconditionID, which is the drop that must be attained first.
input DropPrecondition {
  # The drop that can be claimed once the preconditions are met.
  dropID: ID!
  # The drop that must have been claimed before you can make progress on this drop.
  dropPreconditionID: ID!
}

# Contains all of the information about a Drop awarded to a user.
type DropReward {
  # The URL where a user can link their account for this reward.
  accountLinkURL: String! @deprecated(reason: "use benefit.accountLinkURL")
  # An availability enum for this reward.
  availability: DropRewardAvailability!
  # The DropBenefit that a user is claiming or get verified to.
  benefit: DropBenefit!
  # The display description of this award object.
  description: String! @deprecated(reason: "no longer used")
  # The ID of this reward object.
  id: ID! @deprecated(reason: "use benefit.id")
  # An image asset for this reward object.
  imageAssetURL: String! @deprecated(reason: "use benefit.imageAssetURL")
  # Specifies if this reward is considered for a game that is available on iOS.
  isIosAvailable: Boolean! @deprecated(reason: "use benefit.isIosAvailable")
  # The display name of this award object.
  name: String! @deprecated(reason: "use benefit.name")
  # The ID of the owner of the item for this reward.
  ownerID: ID! @deprecated(reason: "use benefit.ownerOrganization.id")
  # The display name of item owner for this drop.
  ownerName: String! @deprecated(reason: "use benefit.ownerOrganization.name")
}

# Availability enum for Drop Rewards.
enum DropRewardAvailability {
  # User can claim this item.
  AVAILABLE
  # User has claimed this item already the maximum number of times.
  LIMIT_REACHED
  # Unknown is returned when an unexpected status is received from the backend.
  UNKNOWN
}

# Contains all of the information about a Drop's rule stating what a broadcaster
# has to do to trigger a drop. //To be deprecated.
type DropRule {
  # The description of this drop's rule.
  description: String! @deprecated
  # The Rule ID.
  id: ID! @deprecated
}

# The type of drop rule you're creating. Event vs Minutes Watched.
enum DropRuleType {
  # A drop that is triggered by an in-game event.
  EVENT_BASED
  # A drop that is granted based on the user's minutes-watched of the drop's game.
  TIME_BASED
  # A drop that is triggered by an manual triggered event.
  MANUAL_TRIGGER_BASED
}

# An error that has been mapped from a DropsManagementService twirp error. Can sometimes include messages.
type DropsError {
  # The error code.
  code: DropsErrorCode!
  # The error message string.
  message: String
}

# Enum for Drops2 errors.
enum DropsErrorCode {
  # The error code is unknown.
  UNKNOWN
  # The user is either not authenticated or not authorized to perform the request.
  UNAUTHORIZED
  # A request field either was not present or did not meet validation requirements.
  INVALID_ARGUMENT
  # The drops2 object is not in the right state to perform this operation.
  FAILED_PRECONDITION
  # The object you wish to query / modify is not found.
  NOT_FOUND
  # The object you're trying to create, already exists.
  ALREADY_EXISTS
}

# An interface to handle shared Drop data. The `Drop` type is already in use (although deprecated) so we can't use that name.
interface DropType {
  # The rewards for this drop and how often those rewards can be awarded.
  benefitEdges: [DropBenefitEdge!]
  # The campaign this drop belongs to.
  campaign: DropCampaign!
  # The time this drop becomes unavailable.
  endAt: Time!
  # A unique identifier.
  id: ID!
  # The name of this drop.
  name: String!
  # The time this drop becomes available.
  startAt: Time!
}

# A possibly signed sequence of decimal numbers, each with optional fraction
# and a unit suffix, such as "300ms", "-1.5h" or "2h45m".
# Valid time units are "ns", "us" (or "Âµs"), "ms", "s", "m", "h".
scalar Duration

# Paginated list of channels a user is an editor for.
type EditableChannelConnection {
  # The elements of the list.
  edges: [EditableChannelEdge!]!
  # Information about this page.
  pageInfo: PageInfo!
}

# Points to a editable channel with the editor.
type EditableChannelEdge {
  # Opaque cursor describing this edge's position in the paginated list.
  cursor: Cursor!
  # The user whose channel has the editor.
  node: User
}

# Paginated list of editors of a channel.
type EditorConnection {
  # The elements of the list.
  edges: [EditorEdge!]!
  # Information about this page.
  pageInfo: PageInfo!
}

# Points to a user with the editor status, with metadata regarding the relationship.
type EditorEdge {
  # Opaque cursor describing this edge's position in the paginated list.
  cursor: Cursor!
  # Timestamp of when the editor status was granted.
  grantedAt: Time!
  # The user who has the editor status.
  node: User
}

input EditRoomMessageInput {
  message: String!
  messageID: ID!
  roomID: ID!
}

type EditRoomMessagePayload {
  message: RoomMessage
}

# The list of payment methods that are supported for web checkout for a user.
type EligiblePaymentMethod {
  # Availability status of the underlying payment gateway.
  availabilityStatus: PaymentMethodAvailabilityStatus!
  # Name of the payment method.
  name: EligiblePaymentMethodName!
}

# The list of names of payment methods that are supported for web checkout.
enum EligiblePaymentMethodName {
  # Amazon Pay payment method.
  AMAZON_PAY
  # Paypal payment method.
  PAYPAL
  # Credit card payment method.
  CREDIT_CARD
  # Xsolla payment method.
  XSOLLA
  # Twitch Wallet balance payment method.
  WALLET
  # Direct Debit payment method.
  DIRECT_DEBIT
}

# EmbeddedEmote is an encoding format used to describe an emote embedded in a string of text.
#
# Example:
#   body = "hey KappaHD"
#   from = 4
#   to = 10
#
#   "KappaHD" will be replaced with the KappaHD emote image.
type EmbeddedEmote {
  # The emote's identifier, for example "115847" -> KappaHD.
  emoteID: ID
  # from is the utf-8 index of the string where replacement starts.
  from: Int
  id: ID
  # setID is the identifier of the set this emote is in.
  setID: ID
  # to is the index of the string where replacement ends.
  to: Int
}

# EmitCampaignDiscoveryEventInput contains the campaign objective type of the event being emitted
# and the channelID from which this event is born.
input EmitCampaignDiscoveryEventInput {
  # The channelID from the channel this event is taking place on.
  channelID: ID!
  # The campaign objective type of the event.
  discoveryType: CampaignDiscoveryEventType!
}

# EmitCampaignDiscoveryEventPayload is the success response for emitting a campaign discovery event.
type EmitCampaignDiscoveryEventPayload {
  # Whether the call succeeded or not.
  isSuccess: Boolean!
}

type Emote {
  # The type of image asset of the emote (static, animated, etc.).
  assetType: EmoteAssetType
  # The Bits Badge Tier metadata associated with this Bits Badge Tier Emote. Nil for other emote types.
  bitsBadgeTierSummary: EmoteBitsBadgeTierSummary
  # The timestamp at which this emote was created.
  createdAt: Time
  # The emote's identifier.
  # For example, "115847".
  id: ID
  # The list of modifiers a user is entitled to use for an emote.
  modifiers: [EmoteModifier!]
  # A priority order for displaying this emote among others in the same group.
  order: Int
  # The user who owns the subscription product that this emote belongs to.
  owner: User
  # Identifies which set this emote belongs to.
  setID: ID
  # The state of an emote. Can be either active or pending.
  state: EmoteState!
  # The subscription product this emote belongs to. Nil for globals.
  subscriptionProduct: SubscriptionProduct
  # The subscription info for this emote (if the emote is obtainable via subscription).
  subscriptionSummaries: [SubscriptionSummary!]
  # This is very sparsely populated at present (only when subscription summaries are populated).
  # This is subscription tier that is associated with this emote (if one exists)
  # and if the emote and subscription shares an owner.
  subscriptionTier: SubscriptionSummaryTier
  # For subscription and bits badge tier emotes, this is the user generated suffix.
  # For example, for "lirikLUL" suffix would be "LUL".
  suffix: String
  # The visual representation of the emote.
  # For example, "O_o" instead of "(O|o)_(o|O)".
  text: String
  # The text token of the emote.
  # For example, "KappaHD".
  token: String
  # The type of emote that this is.
  # For example, a global emote, a turbo emote, a prime emote, a sub emote, etc.
  type: EmoteType
}

# The asset type of the emote (static, animated, etc.).
enum EmoteAssetType {
  # The emote's asset is animated (e.g. GIF).
  ANIMATED
  # The emote's asset is static (e.g. PNG).
  STATIC
  # The emote's asset type is unknown.
  UNKNOWN
}

# Bits Badges Tier metadata for emotes.
type EmoteBitsBadgeTierSummary {
  # The Bits Badge Tier Summary data that is user-dependent.
  self: EmoteBitsBadgeTierSummarySelfEdge
  # The amount of bits any user must cheer to achieve this tier.
  threshold: Int!
}

# The Bits Badge Tier Summary data that is user-dependent.
type EmoteBitsBadgeTierSummarySelfEdge {
  # Is true if the user has unlocked this emote.
  isUnlocked: Boolean!
  # The number of bits that this user must use in order to unlock this emote. 0 if already unlocked.
  numberOfBitsUntilUnlock: Int!
}

# The possible emote group asset types.
enum EmoteGroupAssetType {
  # STATIC type groups only contain static emotes.
  STATIC
  # ANIMATED type groups only contain animated emotes.
  ANIMATED
}

# The ID, Size and AssetType of a previously uploaded emote.
input EmoteImageAssetInput {
  # The asset type of the image.
  assetType: EmoteAssetType!
  # Image ID generated by Mako for image.
  id: ID!
  # Size of the image.
  size: EmoteImageSize!
}

# Enum of supported image sizes.
enum EmoteImageSize {
  # Lowest supported resolution.
  SIZE_1X
  # Resolution used for kinda high density displays.
  SIZE_2X
  # Highest density display support.
  SIZE_4X
  # Original size, used for resizing functionality.
  SIZE_ORIGINAL
}

# Represents the data needed to continue the upload of an emoticon image asset.
type EmoteImageUploadConfiguration {
  # The id used by upload service to publish updates via pubsub about the uploaded image.
  uploadID: ID
  # The url in s3 for where the front-end should post the image asset.
  uploadURL: String
}

# EmoteLimits contains all the emote-related limits for a user.
type EmoteLimits {
  # The maximum number of animated emotes that the user can own.
  maxOwnedAnimated: Int!
  # The maximum number of static emotes that the user can own.
  maxOwnedStatic: Int!
}

# The name of an emote modifier and it's abbreviated code.
type EmoteModifier {
  # The code to use the emote modifier in chat.
  code: String!
  # The name of the emote modifier.
  name: PermanentEmoteModifier!
  # Subscription tier associated with modifier (if known and applicable).
  subscriptionTier: SubscriptionSummaryTier
}

# A set of modifications to apply to a tier of emotes for a creator.
input EmoteModifierGroupInput {
  # The modifiers to set.
  modifiers: [PermanentEmoteModifier!]!
  # The ID of the product to set the modifiers for.
  productID: ID!
}

# A set of modifiers that have been set on a tier of emotes for a creator.
type EmoteModifierGroupPayload {
  # The modifiers that were set.
  modifiers: [PermanentEmoteModifier!]
  # The product the modifiers were set for.
  product: SubscriptionProduct
}

# The new order for the specified emote in a particular emote group.
input EmoteOrder {
  # The ID of this emote.
  emoteID: ID!
  # The ID of the group we are setting this emote's order in. When emotes can exist in multiple groups they may have different
  # order values in each group (as the other emotes in each group will be
  # different) so we must specify which group we are operating on.
  groupID: ID!
  # The new order value for this emote.
  order: Int!
}

# Enum of supported resizing plans.
enum EmoteResizePlan {
  # Resize a provided SIZE_ORIGINAL_IMAGE.
  AUTO_RESIZE
  # Don't resize, use the image as is for 1x, 2x or 4x.
  NO_RESIZE
}

# Represents a group of emotes.
type EmoteSet {
  # The list of emotes which belong to this set.
  emotes: [Emote]
  # The emote set's identifier.
  id: ID
  # The channel associated with the emote set. Nil for emote sets not associated
  # with an owner (prime, fuel, rewards, etc.).
  owner: User
  # The asset type of the emotes within the emote group.
  assetType: EmoteGroupAssetType
}

# Deprecated: Domains that emotes belong to.
enum EmoteSetDomain {
  # Emotes that were granted via Twitch crates.
  CRATE
}

# EmoteSettings contains the full list, settings and limits associated with a channel's emotes.
type EmoteSettings {
  # The emote-related limits associated with a user.
  emoteLimits: EmoteLimits
  # ownedEmotes is the list of emotes owned by this user. This may include
  # archived and pending emotes. This will only resolve if this user is the
  # authenticated user.
  ownedEmotes: [Emote!]
}

# The state of an emote.
enum EmoteState {
  # Emote has been approved and is active.
  ACTIVE
  # Emote has been uploaded and is awaiting approval.
  PENDING
  # Emote is only available in the emote library.
  ARCHIVED
  # Emote has been uploaded into the emote library and is awaiting approval.
  PENDING_ARCHIVED
  # Emote is inactive.
  INACTIVE
  # Emote has an unknown state.
  UNKNOWN
}

# Used to filter emotes by state.
enum EmoteStateFilter {
  # Show all emotes, including active and pending.
  ALL
  # Show only active emotes.
  ACTIVE
}

enum EmoteType {
  # Emote is a channel points reward.
  CHANNEL_POINTS
  # Emote is a bits badge tier reward.
  BITS_BADGE_TIERS
  # Emote is a subscription product benefit.
  SUBSCRIPTIONS
  # Emote is a Twitch Prime benefit.
  PRIME
  # Emote is a Twitch Turbo benefit.
  TURBO
  # Two Factor authorization enabled reward emotes.
  TWO_FACTOR
  # Emote is one of the robot, monkey, or glitch smilies sets.
  SMILIES
  # Emote is a global emote.
  GLOBALS
  # Limited time emotes are from a limited window event like FUEL or Esports (like OWL or Heathstone).
  LIMITED_TIME
  # Limited time emote from a hype train campaign.
  HYPE_TRAIN
  # Limited time emote from a megacommmerce/megacheer campaign.
  MEGA_COMMERCE
  # Emotes which have intentionally been given no associated feature because they are only available in the Emotes Library.
  ARCHIVE
  # Emote is a follower emote.
  FOLLOWER
  # Emote has an unknown type.
  UNKNOWN
}

# Represents an emote that is currently in the process of being uploaded.
type EmoteUploadConfiguration {
  # The relevant metadata for the 1X image asset.
  imageUploadConfig1X: EmoteImageUploadConfiguration
  # The relevant metadata for the 2X image asset.
  imageUploadConfig2X: EmoteImageUploadConfiguration
  # The relevant metadata for the 4X image asset.
  imageUploadConfig4X: EmoteImageUploadConfiguration
}

# Channels have emoticon prefixes.
type EmoticonPrefix {
  # If the prefix can be edited or not.
  isEditable: Boolean!
  # Name of the prefix.
  name: String!
  # If the prefix has been approved or not.
  state: EmoticonPrefixState!
}

# State to track if the emote prefix is approved or not.
enum EmoticonPrefixState {
  # Unknown.
  UNKNOWN
  # No prefix has been submitted.
  UNSET
  # Prefix is approved and active.
  ACTIVE
  # Prefix was rejected by Twitch.
  REJECTED
  # Prefix is waiting moderation by Twitch.
  PENDING
}

# Paginated list of endorsed channels using the Relay cursor specification.
type EndorsedChannelConnection {
  # The endorsed channels.
  edges: [EndorsedChannelEdge!]
  # Pagination information for this connection.
  pageInfo: PageInfo!
}

# Element in a list of endorsed channels.
type EndorsedChannelEdge {
  # Cursor identifying the position of this edge for future queries.
  cursor: Cursor!
  # The information about the endorsed channel.
  node: Channel!
  # Unique id per channel item, used by the client to attribute display/clicks of items.
  trackingID: ID!
}

# The required input for an EndUseBitsInExtension mutation.
input EndUseBitsInExtensionInput {
  # The transaction ID of this bits spend event.
  transactionID: ID!
}

# The result of a EndUseBitsInExtension mutation.
type EndUseBitsInExtensionPayload {
  # The user's new bits balance.
  balance: Int
}

# EnhancedExperiencesClient is an OAuth app that is authorized to use
# the Enhanced Experiences (E2) API for game integrations.
type EnhancedExperiencesClient {
  # The client ID of the OAuth app.
  id: ID!
  # The name of the client.
  name: String!
  # The timestamp when the the client was onboarded to the Enhanced Experiences (E2) API.
  onboardedAt: Time
}

# Episode metadata.
type EpisodeDetails {
  # Total length of the content.
  durationSeconds: Int
  # The episode number.
  episode: Int
  # The season number.
  season: Int
  # The name of the series.
  series: String
}

# EquipHeroAssetsError contains details about an error that occured when equipping assets.
type EquipHeroAssetsError {
  # The type of error that occured when equipping hero assets.
  code: EquipHeroAssetsErrorCode!
}

# EquipHeroAssetsErrorCode defines a client error that occurs when equipping hero assets.
enum EquipHeroAssetsErrorCode {
  # The requesting user did not have permission to equip the assets.
  FORBIDDEN
  # One of the requested asset IDs was not valid.
  INVALID_ASSET_ID
  # Multiple assets were specified in a single asset type.
  MULTIPLE_ASSETS_PER_TYPE
  # Some other unexpected error occured.
  UNKNOWN_ERROR
}

# EquipHeroAssetsInput contains the parameters to equip assets on a hero.
input EquipHeroAssetsInput {
  # The IDs of the assets to equip.
  assetIDs: [ID!]!
}

# EquipHeroAssetsPayload is the response after equipping the assets on the hero.
type EquipHeroAssetsPayload {
  # The error that occured.
  # Null if the operation was successful.
  error: EquipHeroAssetsError
  # The hero after equipping - null if error.
  hero: Hero
}

# ESRBRating for a given game.
enum ESRBRating {
  # Game category that has not set an ESRB Rating.
  UNSET
  # Game category that has ESRB Rating of Rating Pending (RP).
  RP
  # Game category that has ESRB Rating of EC.
  EC
  # Game category that has ESRB Rating of E.
  E
  # Game category that has ESRB Rating of E10.
  E10
  # Game category that has ESRB Rating of T.
  T
  # Game category that has ESRB Rating of M.
  M
  # Game category that has ESRB Rating of AO.
  AO
}

# Drop triggered by an in-game event.
type EventBasedDrop implements DropType {
  # The rewards for this drop and how often those rewards can be awarded.
  benefitEdges: [DropBenefitEdge!]
  # The campaign this drop belongs to.
  campaign: DropCampaign!
  # Amount of time the viewer has to claim the drop after the rule is completed.
  claimDurationSeconds: Int!
  # The event conditions which must be met for this drop to be earned.
  conditions: [DropEventCondition!]!
  # The time this drop becomes unavailable.
  endAt: Time!
  # A unique identifier.
  id: ID!
  # Describes how the event will be accomplished.
  missionDescription: String!
  # Name of the mission a streamer has to achieve.
  missionName: String!
  # The name of this drop.
  name: String!
  # The time this drop becomes available.
  startAt: Time!
}

# Settings for a given event.
type EventNotificationSetting {
  # The setting category.
  category: String!
  # Settings for individual platforms.
  platforms: [PlatformEventSetting!]!
}

# Experimental properties that should NOT be used outside of experiments.
# When your property is no longer in use, please mark as deprecated and then formally delete it.
type Experiment {
  # The selected promoted Stream for placement experiments.
  promotedStream(promoLocation: Int!): Stream
}

# Data about an inactive subscription to a broadcaster.
type ExpiredSubscription {
  # The channel that the expired subscription belongs to.
  channelOwner: User
  # The unique identifier.
  id: ID!
  # Resolves the product that the expired subscription is to.
  product: SubscriptionProduct
  # The total tenure of a user to a broadcaster.
  tenure: SubscriptionTenure!
}

# A paginated list of expired subscriptions.
type ExpiredSubscriptionConnection {
  # The list of expired subscriptions.
  edges: [ExpiredSubscriptionEdge!]
  # Information about this page of expired subs.
  pageInfo: PageInfo!
}

# An element in a paginated list of expired subscriptions.
type ExpiredSubscriptionEdge {
  # Opaque cursor describing this edge's position in the paginated list.
  cursor: Cursor!
  # The element node.
  node: ExpiredSubscription
}

# Input information for exporting a video to Youtube.
input ExportVideoToYoutubeInput {
  # The description of the exported video.
  description: String
  # Determines whether to split the video into smaller segments.
  doSplit: Boolean
  # Determines viewability of the video.
  private: Boolean
  # The tags of the exported video.
  tags: [String!]
  # The title of the exported video.
  title: String
  # ID of the exported video.
  videoID: ID!
}

# Response to a request to export a video to Youtube.
type ExportVideoToYoutubePayload {
  # Video representing the exported video.
  video: Video
}

# Twitch Extension.
type Extension {
  # The anchor point the extension expects to render into on the client.
  anchor: ExtensionAnchor!
  # A list of assets which the extension must have uploaded to the Twitch Extensions CDN.
  assetURLs: [String!]!
  # The author of the extension as specified by the developer's extension manifest.
  authorName: String!
  # The bits support level required by the broadcaster for the extension to operate.
  bitsSupportLevel: ExtensionBitsSupportLevel!
  # The list of categories that the developer has set for the extension.
  categories: [ExtensionCategory!]!
  # A single challenge condition associated with the specified extension.
  challengeCondition(
    input: ExtensionChallengeConditionByIDInput!
  ): ChallengeCondition @deprecated
  # The list of challenge condition participants that are associated with this
  # extension for a particular condition participant owner and condition owner.
  challengeConditionParticipants(
    first: Int = 100
    after: Cursor
    input: ExtensionChallengeConditionParticipantsInput!
  ): ExtensionChallengeConditionParticipantConnection @deprecated
  # The list of challenge conditions that are associated with this extension.
  challengeConditions(
    first: Int = 100
    after: Cursor
    input: ExtensionChallengeConditionsInput!
  ): ExtensionChallengeConditionConnection @deprecated
  # The client ID of the extension. Also used as the non-composite, non-unique ID of an extension internally.
  clientID: ID!
  # The URL which is used to preset the configuration experience of the extension.
  configURL: String!
    @deprecated(
      reason: "configURL should be captured from the config ExtensionView: Extension.views.config.viewerURL"
    )
  # The list of games that an extension is content-matched to. This list is managed internally by Twitch.
  contentMatchedGames: [Game!]
  # The description of the extension specified by the developer's extension manifest
  # (max-length: 1024 characters).
  description: String!
  # The list of games that an extension is associated to. This list is managed by the extension developer.
  games: [Game!]
  # Whether the extension developer has turned on chat support for this extension.
  hasChatSupport: Boolean!
  # Represents whether or not the developer of the extension would like to provide users with
  # the ability to link their identity with the extension.
  hasIdentityLinking: Boolean!
  # The extension icon URLs used to visually represent the extension.
  iconURLs: ExtensionIcons!
  # The extension ID which is a composite form of <clientID>:<version>.
  id: ID!
  # Represents whether or not the extension supports bits monetization.
  isBitsEnabled: Boolean!
  # The URL which is used to preset the live-dashboard experience of the extension.
  liveConfigURL: String!
    @deprecated(
      reason: "liveConfigURL should be captured from the liveConfig ExtensionView: Extension.views.liveConfig.viewerURL"
    )
  # The name of the extension specified by the developer's extension manifest
  # (max-length: 40 characters).
  name: String!
  # The panel height specified by the developer's extension manifest -or- 300.
  panelHeight: Int!
    @deprecated(
      reason: "panelHeight should be captured from the panel ExtensionView: Extension.views.panel.height"
    )
  # The link to the extension's privacy policy as specified by the developer's extension manifest.
  privacyPolicyURL: String!
  # Screenshots of the URL used to showcase the extension on extension details pages.
  screenshotURLs: [String!]!
  # Represents whether the requesting user is able to install the extension.
  self: ExtensionSelfConnection
  # The sku of the extension for monetizable extensions.
  sku: String!
  # The current state of the extension in our approval process.
  state: ExtensionState!
  # The subscription support level required by the broadcaster for the extension to operate.
  subscriptionsSupportLevel: ExtensionSubscriptionsSupportLevel!
  # The summary of the extension specified by the developer's extension manifest
  # (max-length: 140 characters).
  summary: String!
  # The support contact email as specified by the developer's extension manifest.
  supportEmail: String!
  # End-user license agreement terms of service URL.
  termsURL: String!
  # The vendor code of the extension for monetizable extensions.
  vendorCode: String!
  # The current version of the extension specified by the developer's extension manifest.
  version: String!
  # The URL which is used to preset the viewer experience of the extension.
  viewerURL: String!
    @deprecated(
      reason: "viewerURL should be captured from the ExtensionView corresponding with the Extension's specified anchor"
    )
  # The UI configurations of each supported view of the extension.
  views: ExtensionViews!
  # The list of URLs an extension can link to while loaded in the configuration experience.
  whitelistedConfigURLs: [String!]!
  # The list of URLs a panel extension can link to while loaded in the viewer experience.
  whitelistedPanelURLs: [String!]!
}

# The current activation configuration for an installed extension.
type ExtensionActivationConfig {
  # The anchor that the installation has been activated into. If not activated into a slot,
  # the value will be null.
  anchor: ExtensionAnchor
  # The slot that the installation has been activated into. If not activated into a slot,
  # the value will be null.
  slot: String
  # The activation state of the extension installation.
  state: ActivationState!
  # The horizontal positioning of the left side of the component extension from the left side
  # of the visible video space as a fixed-point percentage (ie: 5742 would represent 57.42 percent).
  x: Int
  # The vertical positioning of the top side of the component extension from the top side
  # of the visible video space as a fixed-point percentage (ie: 5742 would represent 57.42 percent).
  y: Int
}

# Represents the action which should be taken on the provided installation ID. If no
# anchor configuration is provided, the installation will be deactivated.
input ExtensionActivationInput {
  # The required activation input to apply activation state to a component anchor.
  component: ComponentActivationInput
  # The installation ID of the component extension you're attempting to activate.
  installationID: ID!
  # The required activation input to apply activation state to a panel anchor.
  panel: PanelActivationInput
  # The required activation input to apply activation state to a video overyla anchor.
  videoOverlay: VideoOverlayActivationInput
}

# The possible values for an Extension Anchor.
enum ExtensionAnchor {
  # Component extension anchor.
  COMPONENT
  # Hidden extensions are used currently for load tests.
  HIDDEN
  # Panel extension anchor.
  PANEL
  # Video overlay extension anchor.
  VIDEO_OVERLAY
}

# ExtensionAssetManifest is data related to the assets of an extension.
type ExtensionAssetManifest {
  # Hash of the asset zip file.
  assetHash: String!
  # Base URI used for extensions out of local test.
  baseURI: String
  # The name of the file that was uploaded.
  fileName: String
  # The size of the file that was uploaded.
  fileSize: String
  # The time that the assets were uploaded.
  uploadedAt: Time
  # The user that uploaded the assets.
  uploader: User
}

# ExtensionAssetManifestInput is data related to the assets of an extension.
input ExtensionAssetManifestInput {
  # Hash of the asset zip file.
  assetHash: String!
}

# The support levels for Bits features.
enum ExtensionBitsSupportLevel {
  # This extension doesn't have any support for bit features.
  NONE
  # This extension has support for bit features but can operate in the event
  # the broadcaster disables the permissions.
  OPTIONAL
  # This extension requires support for bit features and cannot operate in the event
  # the broadcaster disables the permissions.
  REQUIRED
}

# ExtensionCapabilities contains data about what an Extension can do, in general, and at the time of interaction.
type ExtensionCapabilities {
  # The bit support level required by the broadcaster for the extension to operate. Defaults to "NONE".
  bitsSupportLevel: ExtensionBitsSupportLevel!
  # Location of configuration.
  configurationLocation: ExtensionConfigurationLocation!
  # Does this extension use bits.
  hasBitsSupport: Boolean!
  # Does this extension support chat.
  hasChatSupport: Boolean!
  # Required configuration string.
  requiredConfiguration: String!
  # The subscription support level required by the broadcaster for the extension to operate. Defaults to "NONE".
  subscriptionsSupportLevel: ExtensionSubscriptionsSupportLevel!
  # Whitelists for restricting extension access and behavior.
  whitelists: ExtensionWhitelists
  # Will this extension request an identity link.
  willRequestIdentityLink: Boolean!
}

# ExtensionCapabilitiesInput contains data about what an Extension can do, in general, and at the time of interaction.
input ExtensionCapabilitiesInput {
  # The bits support level required by the broadcaster for the extension to operate. Defaults to "NONE".
  bitsSupportLevel: ExtensionBitsSupportLevel = NONE
  # Location of configuration.
  configurationLocation: ExtensionConfigurationLocation!
  # Does this extension use bits.
  hasBitsSupport: Boolean!
  # Does this extension support chat.
  hasChatSupport: Boolean!
  # Required configuration string.
  requiredConfiguration: String!
  # The subscription support level required by the broadcaster for the extension to operate. Defaults to "NONE".
  subscriptionsSupportLevel: ExtensionSubscriptionsSupportLevel
  # Whitelists for restricting extension access and behavior.
  whitelists: ExtensionWhitelistsInput!
  # Will this extension request an identity link.
  willRequestIdentityLink: Boolean!
}

# An extension carousel.
type ExtensionCarousel {
  # List of entries associated with the carousel.
  entries: [ExtensionCarouselEntry!]!
  # Unique ID of the carousel.
  id: ID!
}

# An extension carousel entry.
type ExtensionCarouselEntry {
  # URL the user is directed to when clicking the carousel entry.
  clickThroughURL: String!
  # Unique ID of the entry.
  id: ID!
  # URL of the image to display for the carousel entry.
  imageURL: String!
  # Text associated with the carousel entry.
  title: String!
}

# An extension category.
type ExtensionCategory {
  # Description for what kind of extensions this category represents.
  description: String!
  # The paginated list of extensions in the category.
  extensions(first: Int = 10, after: Cursor): ExtensionConnection
  # The category ID which is uniquely generated.
  id: ID!
  # Boolean value representing whether a category has been deleted.
  isDeleted: Boolean!
  # Denotes that no updates can be made to the category and no extensions can be added to it.
  isReadOnly: Boolean!
  # Boolean value representing whether this category should be hidden from listings.
  isVisible: Boolean!
  # Human readable name for the Category.
  name: String!
  # Display order for this category. Categories are returned in ascending order.
  order: Float!
  # The URL-safe slug for the category. This slug may be used as the identifier to retrieve
  # categories from the root Query.
  slug: ID
  # Enumerated value specifying how this category's content should be ordered. Popularity, manual, etc.
  sortKey: ExtensionCategorySortKey!
  # Category Type which can be curated or developer.
  type: ExtensionCategoryType!
}

# A paginated list of extension categories, and their metadata.
type ExtensionCategoryConnection {
  # The list of extension categories in this page.
  edges: [ExtensionCategoryEdge!]!
  # Information about this page of extension categories.
  pageInfo: PageInfo!
  # The total number of extension categories.
  totalCount: Int!
}

# An element in a paginated list of extension categories and its metadata.
type ExtensionCategoryEdge {
  # Cursor represents the position of the current edge/node.
  cursor: Cursor!
  # Node represents the extension category for the current edge.
  node: ExtensionCategory!
}

# Enumeration of the different sort keys to sort extensions within a category.
enum ExtensionCategorySortKey {
  # Manual sort key refers to an arbitrary sorting of extensions.
  MANUAL
  # Popularity sort key refers to sorting of extensions by popularity.
  POPULARITY
  # Time sort key refers to sorting of extensions from newest to latest.
  TIME
}

# Enumeration of the different category types that are currently supported.
enum ExtensionCategoryType {
  # Curated Category Type is Twitch controlled.
  CURATED
  # Developer Category Type is developer controlled.
  DEVELOPER
  # Pseudo Categories are categories whose extensions are generated. Slugs are required
  # on pseudo categories and are often the best way to retrieve them. Example pseudo categories
  # and slugs include "new-releases" and "whitelisted".
  PSEUDO
}

# Parameters for filtering ChallengeConditionParticipants.
input ExtensionChallengeConditionByIDInput {
  # The ID of the condition for the specified owner.
  conditionID: ID!
  # TUID of condition participant's associated condition's owner.
  conditionOwnerID: ID!
}

# A paginated list of extension challenge conditions.
type ExtensionChallengeConditionConnection {
  # The elements of the paginated list.
  edges: [ExtensionChallengeConditionEdge!]!
  # Information about this page.
  pageInfo: PageInfo!
}

# An element in a paginated list of extension challenge conditions.
type ExtensionChallengeConditionEdge {
  # An opaque cursor identifying the edge's position in the paginated list.
  cursor: Cursor!
  # The element node.
  node: ChallengeCondition!
}

# A paginated list of extension challenge conditionParticipants.
type ExtensionChallengeConditionParticipantConnection {
  # The elements of the paginated list.
  edges: [ExtensionChallengeConditionParticipantEdge!]!
  # Information about this page.
  pageInfo: PageInfo!
}

# An element in a paginated list of extension challenge conditionParticipants.
type ExtensionChallengeConditionParticipantEdge {
  # An opaque cursor identifying the edge's position in the paginated list.
  cursor: Cursor!
  # The element node.
  node: ChallengeConditionParticipant!
}

# Parameters for filtering ChallengeConditionParticipants.
input ExtensionChallengeConditionParticipantsInput {
  # TUID of condition participant's associated condition's owner.
  conditionOwnerID: ID!
  # TUID of condition participant owner.
  conditionParticipantOwnerID: ID!
  # Filter condition participants with this state.
  endState: ChallengeConditionParticipantEndState!
}

# Parameters for filtering ChallengeConditions.
input ExtensionChallengeConditionsInput {
  # TUID of condition owner. This will typically be the broadcaster's user ID.
  conditionOwnerID: ID!
  # Filter conditions with this state.
  state: ChallengeConditionState!
}

# ExtensionClient is the authorization component of an extension.
type ExtensionClient {
  # A organization member assigned as a billing manager for this extension. Null
  # when extension is not an organization or the extension is not monetized.
  assignedBillingManager: OrganizationMember
  # CreatedAt is the timestamp at which this client was created.
  createdAt: Time!
  # ID is the OAuth ID representing the extension.
  id: ID!
  # Name is the name of the extension.
  name: String!
  # Organization is the Organization entity of the extension, it means which organization the extension belongs to.
  organization: Organization
  # RedirectURI is the URI used for client redirect on OAuth login.
  redirectURI: String!
}

# A paginated list of extension clients.
type ExtensionClientConnection {
  # The list of extension clients in this page.
  edges: [ExtensionClientEdge!]!
  # Information about this page of extension clients.
  pageInfo: PageInfo!
}

# An element in a paginated list of extension clients.
type ExtensionClientEdge {
  # Cursor represents the position of the current edge/node.
  cursor: Cursor!
  # Node represents the extension client for the current edge.
  node: ExtensionClient!
}

# ExtensionComment contains the data for the comment of an extension review.
type ExtensionComment {
  # The review comment text provided by the user.
  content: String!
  # The ID of the recorded comment.
  id: ID!
}

# The hosted configuration for an extension that comes from config service.
type ExtensionConfiguration {
  # The broadcaster-set, per-channel segment of the extension configuration.
  broadcaster: ExtensionConfigurationRecord
  # The developer-set, per-channel segment of the extension configuration.
  developer: ExtensionConfigurationRecord
  # The id of the extension that this configuration document belongs to.
  extensionID: ID!
  # The developer-set segment of the extension configuration that affects all
  # installs of the extension.
  global: ExtensionConfigurationRecord
}

# Possible locations for Extension Configuration to be hosted.
enum ExtensionConfigurationLocation {
  # Configuration not required for activation of this extension.
  NONE
  # Configuration hosted by TwitchÂ using Extensions Configuration service.
  HOSTED
  # Custom/Own service hosted configuration.
  CUSTOM
}

# A single segment from the extensions configuration service.
type ExtensionConfigurationRecord {
  # The content of the configuration segment.
  content: String!
  # The version of the configuration segment.
  version: String!
}

# A paginated list of extensions, and its metadata.
type ExtensionConnection {
  # The list of extensions in this page.
  edges: [ExtensionEdge!]!
  # Information about this page of extensions.
  pageInfo: PageInfo!
  # The total number of extensions in the larger collection.
  totalCount: Int!
}

# ExtensionDeveloperManifest is the developer specific extension data.
type ExtensionDeveloperManifest {
  # Author email.
  authorEmail: String!
  # Time when an extension was created.
  createdAt: String!
  # Time when an extensions version was last transitioned.
  lastTransitionedAt: Time
  # Testing uri for extension development.
  testingBaseURI: String!
  # Current state of this version in the development timeline.
  versionState: ExtensionState!
}

# ExtensionDeveloperManifestInput is the developer specific extension data.
input ExtensionDeveloperManifestInput {
  # Author email.
  authorEmail: String!
  # Testing uri for extension development.
  testingBaseURI: String!
}

# Extension metadata used for discovery.
type ExtensionDiscoveryManifest {
  # Name of the extension author.
  authorName: String!
  # Extension categories.
  categories: [ExtensionCategory!]!
  # Games that an extension is content-matched to. This list is managed internally by Twitch.
  contentMatchedGames: [Game!]
  # Extension descriprion. 1024 character limit.
  description: String!
  # Games that an extension is associated to. This list is managed by the extension developer.
  games: [Game!]!
  # Icon urls for extensions.
  iconURLs: ExtensionIcons
  # name of the extension.
  name: String!
  # Url to an extensions privacy policy.
  privacyPolicyURL: String!
  # Extension screenshot urls.
  screenshotURLs: [String!]!
  # Extension summary. 140 character limit.
  summary: String!
  # Extension developers support email.
  supportEmail: String!
  # Extension eula/tos url.
  termsURL: String!
  # Extension viewer summary.
  viewerSummary: String!
}

# Extension metadata used for discovery.
input ExtensionDiscoveryManifestInput {
  # Name of the extension author.
  authorName: String!
  # Extension categories.
  categories: [ID!]!
  # Extension descriprion. 1024 character limit.
  description: String!
  # games an extension is associated with.
  games: [ID!]!
  # name of the extension.
  name: String!
  # Url to an extensions privacy policy.
  privacyPolicyURL: String!
  # Extension summary. 140 character limit.
  summary: String!
  # Extension developers support email.
  supportEmail: String!
  # Extension eula/tos url.
  termsURL: String!
  # A summary of the extension's functionality from a viewer's perspective.
  viewerSummary: String
}

# ExtensionDynamicManagementInput represents the game ID and whether it is dynamically managed or not on an extension.
input ExtensionDynamicManagementInput {
  # The discovery game ID.
  gameID: ID!
  # If the game has been marked as dynamically managed or not.
  isManaged: Boolean!
}

# An element in a paginated extensions of videos, and its metadata.
type ExtensionEdge {
  # Cursor represents the position of the current edge/node.
  cursor: Cursor!
  # Node represents the extension for the current edge.
  node: Extension!
}

# The complete set of potential icons provided by a developer to represent their Extension on the site.
type ExtensionIcons {
  # 300x200 splash image used in extension discovery & management.
  discoverySplash: String!
  # Square 100x100 icon used in extension discovery & management.
  square100: String!
  # Square 24x24 icon used in video player taskbar.
  square24: String!
}

# Url and UploadId provided by Upload Service.
type ExtensionImageUploadResponse {
  # Upload ID.
  uploadID: ID!
  # Upload URL.
  url: String!
}

# Extension Installation are models which contain an Extension and it's associated installation metadata.
type ExtensionInstallation {
  # The abilities this extension can use for the channel it is installed on.
  abilities: ExtensionInstallationAbilities!
  # The current activation metadata for the extension.
  activationConfig: ExtensionActivationConfig!
  # The extension which the installation record is for.
  extension: Extension!
  # The the composite extension installation ID in the form of <clientID>:<version>:<channelID>.
  id: ID!
  # The installer's decision whether to allow an extension to use a particular feature.
  permittedFeatures: ExtensionInstallationFeatureFlags!
  # The required, if any, for the installed extension after an activation.
  requiredActions: [ExtensionRequiredAction!]
  # The self connection of the extension installation.
  self: ExtensionInstallationSelfConnection
}

# The set of abilities an extension is authorized to use.
type ExtensionInstallationAbilities {
  # Whether the extension can use bits in the current context.
  isBitsEnabled: Boolean!
  # Whether the extension can send chat messages in the current context.
  isChatEnabled: Boolean!
  # Whether the extension has access to subscription status in the current context.
  isSubscriptionStatusAvailable: Boolean!
}

# The dynamic management setting for a content-matched game on an extension installation.
type ExtensionInstallationDynamicManagement {
  # The game that the setting is for.
  game: Game
  # Whether or not dynamic management is turned on for this extensions.
  isManaged: Boolean!
}

# The set of extension features an installer can opt in or out of.
type ExtensionInstallationFeatureFlags {
  # Whether the installer has granted the extension access to their subscriptions list.
  canRetrieveSubscriptionStatus: Boolean!
  # Whether the installer has opted in or out of chat capabilities in extensions.
  canSendChat: Boolean!
  # Whether the installer has opted in or out of bit capabilities in extensions.
  canUseBits: Boolean!
  # The dynamic management settings for the extension installation.
  dynamicManagement: [ExtensionInstallationDynamicManagement!]
}

# The connection a user has to an Installed Extension.
type ExtensionInstallationSelfConnection {
  # Represents whether the requesting user can activate the extension.
  canActivate: Boolean!
}

# The data that links the active user with a particular extension
# installation on a channel.
type ExtensionInstallationSelfEdge {
  # The extension installation.
  installation: ExtensionInstallation
  # Authentication information that links the active user and the installation.
  token: ExtensionToken
  # Configurations set for this extension/user pair.
  configuration: ExtensionConfiguration
  # The time this response was issuedAt, so the client can set a timer for when
  # the token needs to be refreshed.
  issuedAt: Time
}

# Extension Link User Error.
type ExtensionLinkUserError {
  # The error code.
  code: ExtensionLinkUserErrorCode
}

# Extension Link User Error Code.
enum ExtensionLinkUserErrorCode {
  # The current user is not authorized to link / unlink this extension.
  UNAUTHORIZED
  # The request body was invalid.
  BAD_REQUEST
  # An unexpected error occurred.
  UNKNOWN
}

# The required input for an ExtensionLinkUser mutation.
input ExtensionLinkUserInput {
  # The id of the channel the extension is currently installed on.
  channelID: ID!
  # The ID of the extension that the user would like to link/unlink with.
  extensionID: ID!
  # The current extension jwt for the user being linked/unlinked.
  jwt: String
  # Whether to link or unlink the user from this extension.
  showUser: Boolean!
}

# The result of a ExtensionLinkUser mutation.
type ExtensionLinkUserPayload {
  # Error from an Extension Link User Call.
  error: ExtensionLinkUserError
  # The user's new token reflecting their now linked/unlinked status.
  token: ExtensionToken
}

# ExtensionManifest is the data that represents an entire extension manfiest.
type ExtensionManifest {
  # ExtensionAssetManifest is data related to the assets of an extension.
  assetManifest: ExtensionAssetManifest!
  # Data about what an Extension can do, in general, and at the time of interaction.
  capabilities: ExtensionCapabilities!
  # ExtensionDeveloperManifest is the developer specific extension data.
  developerManifest: ExtensionDeveloperManifest!
  # Extension metadata used for discovery.
  discoveryManifest: ExtensionDiscoveryManifest!
  # Extension id.
  id: ID!
  # Extension version.
  version: String!
  # Extension views.
  views: ExtensionViews!
}

# A paginated list of extension manifests.
type ExtensionManifestConnection {
  # The list of extension manifests in this page.
  edges: [ExtensionManifestEdge!]!
  # Information about this page of extension manifests.
  pageInfo: PageInfo!
}

# An element in a paginated list of extension manifests.
type ExtensionManifestEdge {
  # Cursor represents the position of the current edge/node.
  cursor: Cursor!
  # Node represents the extension manifest for the current edge.
  node: ExtensionManifest
}

# A summary of extension state and the associated manifests.
type ExtensionManifestsSummary {
  # The global deleted state of the extension.
  isDeleted: Boolean!
  # The list of extension manifests.
  manifests: ExtensionManifestConnection
}

# ExtensionPanel is a placeholder in the panel list for arbitrary iframed content.
type ExtensionPanel implements Panel {
  # id is a unique identifier for the panel.
  id: ID!
  # slotID is an identifier to map extensions content from `User.extensions` to the proper place in the `User.panels` list.
  slotID: ID!
  # type is `PanelType.EXTENSION`.
  type: PanelType!
}

# ExtensionRating contains the information of a user's rating of a Twitch extension.
type ExtensionRating {
  # The ID of the recorded rating.
  id: ID!
  # Whether the user recommended the extension or not.
  isRecommended: Boolean!
  # Where the user submitted the rating.
  location: ExtensionRatingLocation!
}

# Enumerates where the user can submit an extension rating.
enum ExtensionRatingLocation {
  # The global notifications popout.
  NOTIFICATION
}

# A holder for the presigned S3 URL for an extension ratings report.
type ExtensionRatingsCSVReportPresignedURL {
  # The presigned URL, if one is ready.  Otherwise empty string.
  presignedURL: String
}

# Extension recommendation.
type ExtensionRecommendation {
  # The recommended extension.
  extension: Extension
}

# The action a user must take to complete an activation of an extension installation.
type ExtensionRequiredAction {
  # On PROMPT_FOR_PERMISSIONS the redirectURI to load for OAuth.
  redirectURI: String
    @deprecated(
      reason: "PROMPT_FOR_PERMISSIONS is no longer a valid required action"
    )
  # The action the user must take in order to complete the activation.
  type: ExtensionRequiredActionType!
}

# The possible types of required actions after attempting to activate an extension.
enum ExtensionRequiredActionType {
  # The user must accept the permissions in order to complete the activation.
  PROMPT_FOR_PERMISSIONS
  # The user must configure the extension in order to complete the activation.
  REQUIRES_CONFIGURATION
}

# The shared secret between the extension and the extension validator service.
type ExtensionSecret {
  # When the secret was activated.
  activeAt: Time!
  # The actual content of the secret.
  content: String!
  # When the secret expires.
  expiresAt: Time!
}

# The extensions secrets information.
type ExtensionSecretsInfo {
  # A user-friendly error, should one occur.
  error: GetExtensionSecretsError
  # A list of secrets.
  secrets: [ExtensionSecret!]
}

# The connection a user has to an Extension object.
type ExtensionSelfConnection {
  # Represents whether the requesting user is able to install extensions.
  canInstall: Boolean!
}

# The possible values for ExtensionState.
enum ExtensionState {
  # IN_TEST extensions are currently being worked on by a developer.
  IN_TEST
  # READY_FOR_REVIEW extensions are currently being examined by a developer for their readiness
  # to be reviewed (assets hosted on CDN).
  READY_FOR_REVIEW
  # IN_REVIEW extensions are being looked at by Twitch.
  IN_REVIEW
  # REJECTED extensions are permanently rejected; no action by the  developer will make them acceptable.
  REJECTED
  # APPROVED extensions are ready to be released, at the developer's convenience.
  APPROVED
  # RELEASED extensions are currently available to users.  Only one version of an extension
  # can be in this state at any time.
  RELEASED
  # DEPRECATED extensions were once released, but a newer version now exists.
  DEPRECATED
  # PENDING_ACTION extensions are ones that were reviewed by Twitch and returned to the developer for fixing.
  PENDING_ACTION
  # UPLOADING extensions are in the process of having their assets loaded onto S3.
  UPLOADING
  # ASSETS_UPLOADED extensions have had their assets uploaded already to S3. This state mirrors
  # the existing READY_FOR_REVIEW state, but doesn't incur an implicit upload.
  ASSETS_UPLOADED
  # DELETED extensions have been deleted; this is a soft delete so we can undelete things.
  DELETED
}

# ExtensionStateFilter contains all the valid states to filter the list of extensions by.
enum ExtensionStateFilter {
  # Released extension.
  RELEASED
}

# The support levels for subscriptions features.
enum ExtensionSubscriptionsSupportLevel {
  # This extension doesn't have any support for subscriptions features.
  NONE
  # This extension has support for subscriptions features but can operate in the event
  # the broadcaster disables the permissions.
  OPTIONAL
}

# The user-specific token for an installed extension on a channel.
type ExtensionToken {
  # The ID of the extension associated with this token.
  extensionID: ID!
  # The JWT token for the requesting user.
  jwt: String!
}

# ExtensionVersionDiscoveryManifest is the data that represents an extension discovery manifest.
type ExtensionVersionDiscoveryManifest {
  # Extension metadata used for discovery.
  discoveryManifest: ExtensionDiscoveryManifest!
  # Extension id.
  id: ID!
  # Extension version.
  version: String!
}

# ExtensionView is the interface which every anchor-specific extension view extends from.
interface ExtensionView {
  # Relative path of the HTML file to load for this view, used by devsite to specify the layout of assets.
  viewerPath: String!
  # The URL which should be loaded in for the extension.
  viewerURL: String!
}

# The potential anchor-specific configurations and extension can have.
type ExtensionViews {
  # The developer configuration of the extension as a component extension, if supported.
  component: ComponentView
  # The developer configuration of the extension's configuration view, if supported.
  config: ConfigView
  # The configuration for a hidden extension. The only hidden extension is used for load testing.
  hidden: HiddenView
  # The developer configuration of the extension's live configuration dashboard view, if supported.
  liveConfig: LiveConfigView
  # The developer configuration of the extension as a mobile extension, if supported.
  mobile: MobileView
  # The developer configuration of the extension as a panel extension, if supported.
  panel: PanelView
  # The developer configuration of the extension as a video overlay extension, if supported.
  videoOverlay: VideoOverlayView
}

# The potential anchor-specific configurations and extension can have.
input ExtensionViewsInput {
  # The developer configuration of the extension as a component extension, if supported.
  component: ComponentViewInput
  # The developer configuration of the extension's configuration view, if supported.
  config: ConfigViewInput
  # The developer configuration of the extension's live configuration dashboard view, if supported.
  liveConfig: LiveConfigViewInput
  # The developer configuration of the extension as a mobile extension, if supported.
  mobile: MobileViewInput
  # The developer configuration of the extension as a panel extension, if supported.
  panel: PanelViewInput
  # The developer configuration of the extension as a video overlay extension, if supported.
  videoOverlay: VideoOverlayViewInput
}

# Whitelists for restricting extension access and behavior.
type ExtensionWhitelists {
  # List of broadcaster account IDs allowed to install an extension after release.
  # If this is empty or missing, all broadcasters can use this extension.
  broadcasters: [ID!]!
  # URLs which are permitted to be opened from the configuration dialog.
  configURLs: [String!]!
  # URLs which are permitted to be opened from an extension set as a panel.
  panelURLs: [String!]!
  # List of account IDs which should have access to a version of an extension.
  # Users in this list are ignored by the broadcaster whitelist check.
  testers: [ID!]!
}

# ExtensionWhitelistsInput contains whitelists for restricting extension access and behavior.
input ExtensionWhitelistsInput {
  # List of broadcaster account IDs allowed to install an extension after release.
  # If this is empty or missing, all broadcasters can use this extension.
  broadcasters: [ID!]!
  # URLs which are permitted to be opened from the configuration dialog.
  configURLs: [String!]!
  # URLs which are permitted to be opened from an extension set as a panel.
  panelURLs: [String!]!
  # List of account IDs which should have access to a version of an extension.
  # Users in this list are ignored by the broadcaster whitelist check.
  testers: [ID!]!
}

# Url and UploadId provided by Upload Service.
type ExtensionZipUploadResponse {
  # Upload ID.
  uploadID: ID!
  # Upload URL.
  url: String!
}

# ExternalChargeModel defines a 3P managed SKU for a given offer.
type ExternalChargeModel {
  # Externally managed default/static SKU identifier. This is specifically for
  # discovery and preview flows. Use `self -> checkoutSKU` for purchase flows.
  previewSKU: String!
  # The provider for this externally managed SKU.
  provider: String!
  # Externally managed default/static SKU identifier. For mobile checkouts, use
  # `self` for dynamically vended SKU for the user.
  sku: String! @deprecated(reason: "Use 'previewSKU' instead")
  # The authenticated user's relationship with the external charge model.
  self: ExternalChargeModelSelfEdge
}

# The authenticated user's relationship with the internal charge model.
type ExternalChargeModelSelfEdge {
  # The final checkout SKU of this offer available for the authenticated user.
  checkoutSKU: String!
}

# FeaturedContentSections contain the a set of FeaturedItems that should be shown
# together in a particular section of Twitch apps.
type FeaturedContentSection {
  # A combination of the type and style for a given section, i.e. spotlight-previews.
  id: ID!
  items: [FeaturedItem!]
}

type FeaturedItem {
  # The featured item's content.
  content: FeaturedItemContent
  # An markdown description of the item, available when a item is featured.
  description: String!
  # ID used for tracking interactions.
  id: ID!
  # A URL for a special thumbnail image, when this item is featured.
  imageURL: String!
  # Is this item featured because it is scheduled?
  isScheduled: Boolean!
  # Is this item featured because it is sponsored?
  isSponsored: Boolean!
  # A lower priority level means the item is higher priority.
  priorityLevel: Int!
  # When featured, the title of the item.
  title: String!
}

union FeaturedItemContent = Stream | User | Video
# FeaturedStream contains extra metadata for presenting a featured Stream.
type FeaturedStream {
  # The featured stream's broadcaster.
  broadcaster: User
  # The featured channel.
  channel: Channel
    @deprecated(reason: "Use featuredStream.broadcaster instead.")
  # A markdown description of the stream, available when a stream is featured.
  description: String
  # An HTML description of the stream, available when a stream is featured.
  descriptionHTML: String
    @deprecated(reason: "Use featuredStream.description instead")
  # A URL for a special thumbnail image, when this stream is featured.
  imageURL: String
  # Is this stream featured because it is scheduled?
  isScheduled: Boolean
  # Is this stream featured because it is sponsored?
  isSponsored: Boolean
  # A lower priority level means the stream is higher priority.
  priorityLevel: Int
  # The featured live steam.
  stream: Stream
  # When featured, the title of the stream.
  title: String
}

# DEPRECATED: do not use, it is subject to change.
# FeaturedVideo contains extra metadata for presenting a featured video.
type FeaturedVideo {
  # An markdown description of the video, available when a video is featured.
  description: String!
  # A URL for a special thumbnail image, when this video is featured.
  imageURL: String!
  # Is this video featured because it is scheduled?
  isScheduled: Boolean!
  # Is this video featured because it is sponsored?
  isSponsored: Boolean!
  # A lower priority level means the stream is higher priority.
  priorityLevel: Int!
  # When featured, the title of the video.
  title: String!
  # The featured video.
  video: Video
}

type FeatureFlags {
  isPulseEnabled: Boolean @deprecated(reason: "Enabled for everyone.")
}

# Feed is twitch's pulse product of content a user may enjoy.
type Feed {
  id: ID!
  items(first: Int = 5, after: Cursor): FeedItemConnection
}

# FeedEmbed describes the types of items contained in a Feed.
union FeedEmbed =
    Clip
  | LinkOEmbed
  | PhotoOEmbed
  | RichOEmbed
  | Video
  | VideoOEmbed
# FeedItem is the units of a feed.
# They do not have an identifier because you cannot look them up by identifier.
type FeedItem {
  content: FeedItemContent
  reasons: [FeedItemReason]
  tracking: FeedItemTracking
}

type FeedItemConnection {
  edges: [FeedItemEdge]
  pageInfo: PageInfo
}

# FeedItemContent is the supported content types that may appear in a feed.
union FeedItemContent = Clip | Post | Share | Stream | Video
type FeedItemEdge {
  cursor: Cursor
  node: FeedItem
}

# FeedItemReason explains why an item is in your feed.
type FeedItemReason {
  reason: String
}

# FeedItemTracking contains the tracking info of a feeditem.
type FeedItemTracking {
  batchID: String
  cardImpressionID: String
  recGenerationID: String
  recGenerationIndex: Int
}

# FinalizeCompetitionLobbyInput contains the inputs required to change a lobby's status to done.
input FinalizeCompetitionLobbyInput {
  # The competition id of the competition.
  competitionID: ID!
  # The lobbyID of the competition that we want to mark done.
  lobbyID: ID!
  # The phase id of the competition that this lobby belongs to.
  phaseID: ID!
}

# FinalizeCompetitionLobbyPayload is the success response for updating a lobby to done.
type FinalizeCompetitionLobbyPayload {
  # The new state of competition after marking the lobby as done.
  competition: Competition
  # Used for competition mutation errors.
  error: CompetitionError
}

# Settings specific to the first cheer tutorial.
type FirstCheerTutorial {
  # Optional field that dictates whether a user has exited out of the first cheer tutorial by clicking out of the experience.
  hasAbandoned: Boolean
  # Optional field that dictates whether a user has skipped the first cheer tutorial by clicking the skip button.
  hasSkipped: Boolean
}

# Information about the flagged track of copyrighted music.
type FlaggedTrack {
  # Title of the album of the flagged track.
  albumTitle: String!
  # The appeal for track's usage.
  appeal: FlaggedTrackAppeal
  # ID of the flagged track.
  id: ID!
  # Duration in seconds of the mute. Standard length is 360 (6 mins).
  # This can be null if the flagged track was succesfully appealed.
  muteDurationSeconds: Int
  # Offset is how many seconds into the video the mute begins. 0 indicates the beginning of the video is muted.
  # This can be null if the flagged track was succesfully appealed.
  muteOffsetSeconds: Int
  # Performer of the flagged track.
  performer: String!
  # Title of the flagged track.
  title: String!
}

# The appeal information associated with the flagged track.
type FlaggedTrackAppeal {
  # ID of the track appeal.
  id: ID!
  # Reason for the track appeal.
  reason: String!
  # Status of the track appeal, ie. PENDING, RESOLVED, UNKNOWN.
  status: FlaggedTrackAppealStatus!
}

# The status of the track appeal.
enum FlaggedTrackAppealStatus {
  # The track appeal has not yet been resolved.
  PENDING
  # The track appeal has a resolved at time.
  RESOLVED
}

# Data about the relationship between one User and a User they are following.
type Follow {
  # Whether to disable notifications for this relationship.
  disableNotifications: Boolean
  # Represents when this relationship was established.
  followedAt: Time
  # The user who is followed.
  user: User
}

# A paginated list of follows relationships.
type FollowConnection {
  # The elements of the paginated list.
  edges: [FollowEdge]
  # Information about this page.
  pageInfo: PageInfo
  # The total number of followers.
  totalCount: Int
}

# A list of followed games.
type FollowedGameConnection {
  # The elements of the paginated list.
  nodes: [Game!]
}

enum FollowedGamesType {
  # Only games which are currently being streamed will be returned.
  LIVE
  # All followed games.
  ALL
}

# An element in a paginated list of follows relationships.
# Contains metadata about the follow relationship between two users.
type FollowEdge {
  # An opaque cursor identifying the edge's position in the paginted list.
  cursor: Cursor!
  # Whether to disable notifications for this relationship.
  disableNotifications: Boolean
    @deprecated(reason: "use notificationSettings.isEnabled instead.")
  # Represents when this relationship was established.
  followedAt: Time
  # The user who is followed.
  node: User
  # Notification settings for this relationship.
  notificationSettings: ChannelNotificationSettings
}

# A list of broadcasters followed by a user and hosting live broadcasters.
type FollowedHostConnection {
  # The broadcasters.
  nodes: [User]
}

# A list of live-streaming broadcasters followed by a user.
type FollowedLiveUserConnection {
  # The live broadcasters.
  edges: [FollowedLiveUserEdge]!
  # The live broadcasters.
  nodes: [User]
    @deprecated(
      reason: "Use FollowedLiveUserConnection.edges instead for pagination support"
    )
  # Pagination.
  pageInfo: PageInfo!
}

# A live streaming broadcaster with cursor.
type FollowedLiveUserEdge {
  cursor: Cursor!
  node: User
}

# A paginated list of followers relationships.
type FollowerConnection {
  # The elements of the paginated list.
  edges: [FollowerEdge]
  # Metadata about this page.
  pageInfo: PageInfo
  # The total number of followers.
  totalCount: Int
}

# An element in a paginated list of followers.
# Contains metadata about the follower relationship between two users.
type FollowerEdge {
  # An opaque cursor identifying the edge's position in the paginted list.
  cursor: Cursor!
  # Whether to disable notifications for this relationship.
  disableNotifications: Boolean
  # Represents when this relationship was established.
  followedAt: Time
  # The user who is a follower.
  node: User
  # Notification settings for this relationship.
  notificationSettings: ChannelNotificationSettings
}

input FollowGameInput {
  # The identifier of the game to follow.
  gameID: ID!
}

type FollowGamePayload {
  # The game that was followed if the operation was successful.
  game: Game
}

enum FollowsFilter {
  # All users the user is following.
  ALL
  # Users the user is following to which the user can subscribe.
  # this is authenticated so only a logged in user can filter by SUBBABLE.
  SUBBABLE
}

# Information to communicate to the user about an error state.
type FollowUserError {
  # Error code.
  code: FollowUserErrorCode!
}

# Enum for follow errors.
enum FollowUserErrorCode {
  # Used when fromUser is being blocked by targetUser.
  FORBIDDEN
  # Used when user has reached their follow cap.
  TOO_MANY_FOLLOWS
}

input FollowUserInput {
  # disableNotifications, when true, prevents the followed user's stream from sending email and push notifications to
  # the authenticated user when it goes live.
  disableNotifications: Boolean!
  targetID: ID!
}

type FollowUserPayload {
  # Used for user blocked errors.
  error: FollowUserError
  # The new follow relationship.
  follow: Follow
}

# The format type signifies the format the competition will run from.
enum FormatType {
  # Double elimination bracket format.
  DOUBLE_ELIM
  # Single elimination bracket format.
  SINGLE_ELIM
  # Round robin format.
  ROUND_ROBIN
  # Leaderboard format.
  LEADERBOARD
  # Custom format.
  CUSTOM
  # Unknown format.
  UNKNOWN
}

# The details of different formats. Currently there is only 1 detail type.
union FormatTypeDetails = LeaderboardDetails
# FragmentContent contains the parse content of a fragment, and can be an emote or a mention.
# NOTE: should have been called RoomMessageFragmentContent.
union FragmentContent =
    AutoMod
  | CheermoteToken
  | Emote
  | RoomMessageGroupMention
  | User
# A list of a user's friend relationships.
type FriendConnection {
  # The friend elements of this list.
  edges: [FriendEdge]
  # The total number of friends this user has.
  totalCount: Int!
}

# The friendship between the authenticated user and another user.
type FriendEdge {
  # An action that a user or session is performing.
  activity: Activity
  # The computed state of a user or session.
  availability: Availability!
  # The last time the friend's availability or activity changed.
  lastStatusChangeAt: Time
  # The friend user.
  node: User
}

# The friend-type relationship between the authenticated user and another user.
#
# If this field is a FriendEdge, the authenticated user and the other user are Friends.
#
# If it is an IncomingFriendRequestEdge, the other user has an open friend request with authenticated user.
#
# If it is an OutgoingFriendRequestEdge, the authenticated user has an open friend request with the other user.
union FriendRelationship =
    FriendEdge
  | IncomingFriendRequestEdge
  | OutgoingFriendRequestEdge
# Decides how to sort Friendship-related responses.
enum FriendSort {
  # Sort from oldest to newest.
  ASC
  # Sort from newest to oldest.
  DESC
}

# A Game is often the subject of a Stream on Twitch.
type Game implements Directory {
  # What campaigns are active for this game.
  activeDropCampaigns: [DropCampaign!]
    @deprecated(reason: "Functionality not supported in Drops 2.0")
  # URL to an avatar image.
  # The image dimensions are specifiable via the `height` and `width` parameters.
  #
  # If `height` or `width` are not specified, the URL will contain
  # the template strings `{height}
` and/or `{width}
` in their respective places.
  avatarURL(width: Int, height: Int): String
  # URL to a box art image.
  # The image dimensions are specifiable via the `height` and `width` parameters.
  #
  # If `height` or `width` are not specified, the URL will contain
  # the template strings `{height}
` and/or `{width}
` in their respective places.
  boxArtURL(width: Int, height: Int): String
  # Number of broadcasters streaming this game.
  broadcastersCount: Int
  # Number of channels currently streaming this game.
  channelsCount: Int @deprecated(reason: "Use broadcastersCount instead.")
  # A paginated list of clips featuring this game, ordered by view count descending.
  # When criteria is not specified, the default values are used.
  clips(
    first: Int = 10
    after: Cursor
    criteria: GameClipsInput
  ): ClipConnection
  # URL to a cover image.
  # The image dimensions are specifiable via the `height` and `width` parameters.
  #
  # If `height` or `width` are not specified, the URL will contain
  # the template strings `{height}
` and/or `{width}
` in their respective places.
  coverURL(width: Int, height: Int): String
  # The game's description.
  description: String
  # The game's developers.
  developers: [String!]
  # The type of directory â€“ in this case, always GAME.
  directoryType: DirectoryType
  # The translated game name used for display purposes.
  # Use name for tracking props or URLs.
  displayName: String!
  # The associated clientID for a game used to determine if users have an account link
  # created between tuid and in-game userID as well as the timestamp of when this link was created.
  dropAccountLink: DropAccountLink
  # A list of clients that use the Enhanced Experiences (E2) API for
  # Twitch integrations with this game.
  enhancedExperiencesClients(organizationID: ID!): [EnhancedExperiencesClient!]
  # The game's ESRB rating.
  esrbRating: ESRBRating!
  # The game's ESRB descriptions.
  esrbDescriptions: [String!]
  # A list of extension recommendations, according to the game.
  extensionRecommendations: [ExtensionRecommendation!]
  # Number of users that follow this game.
  followersCount: Int
  # The franchises the game belongs to.
  franchises: [String!]
  # The game's unique GiantBomb identifier.
  giantBombID: ID @deprecated
  # The game's unique Twitch identifier.
  # It is used to associate games with product offers.
  id: ID!
  # URL to a game logo image.
  # The image dimensions are specifiable via the `height` and `width` parameters.
  #
  # If `height` or `width` are not specified, the URL will contain
  # the template strings `{height}
` and/or `{width}
` in their respective places.
  logoURL(width: Int, height: Int): String
  # The name of the game. This string is untranslated.
  # This field should only be used in limited occassions, like tracking and URLs.
  # You should use displayName for all all game names shown to the users.
  name: String!
  # The original release date of the game. Date string is formatted as yyyy-mm-ddThh:mm:ssZ.
  originalReleaseDate: String
  # The platforms the game is on.
  platforms: [String!]
  # A measure of the games popularity.
  popularityScore: Int
  # The game's unique Presto identifier.
  prestoID: ID
  # The game's publishers.
  publishers: [String!]
  # The authenticated user's relationship with this Game.
  self: GameSelfConnection
  # Get a page of live streams broadcasting this game.
  # The languages param can be used to filter the streams. Otherwise all languages will be returned.
  # The filters param contains additional metadata filters, for example {hearthstoneGameMode: "arena"}
.
  # The sort param can be used to change the default sorting, which sometimes is specific to specific games.
  # The tags param are an array of tag ID as optional filters for streams.
  # DEPRECATED field arguments: languages, requestID, sort, tags
  # Use GameStreamOptions instead.
  streams(
    first: Int = 10
    after: Cursor
    options: GameStreamOptions
    languages: [String!]
    filters: StreamMetadataFilterInput
    sort: StreamSort = VIEWER_COUNT
    requestID: ID
    tags: [String!]
  ): StreamConnection
  # List of recommeded tags in the corresponding category.
  tags(limit: Int = 5, tagType: TagType!): [Tag!]
  # A paginated list of top videos for this game.
  videos(
    first: Int = 10
    after: Cursor
    languages: [String!]
    types: [BroadcastType!]
    sort: VideoSort = TIME
  ): VideoConnection
  # Number of viewers currently watching a stream which features this game.
  viewersCount: Int
}

# GameApplication is an application to associate a game with an organization.
type GameApplication {
  # Creation time.
  createdAt: Time!
  # Game that is added in the application.
  game: Game!
  # ID of the game application, stored in RBAC.
  id: ID!
  # Organization that is going to be associated with the game.
  organization: Organization!
}

# Moment Details specific to a game change.
type GameChangeMomentDetails {
  # The game that the user changed to.
  game: Game
}

# Filtering criteria for paginated game clips results.
input GameClipsInput {
  # The ID of the broadcaster to filter results by.
  broadcasterID: ID
  # The ID of the curator to filter results by.
  curatorID: ID
  # Overrides the period. if startAt is provided, but endAt isn't, the endAt value will be the day when the query was made.
  endAt: Time
  # DEPRECATED: `filter` should no longer be used. Prefer `period` and `sort` instead.
  # A filter which restricts results.
  filter: ClipsFilter
  # Clip results will be filtered by this language.
  # Omit this input field to get results by all languages.
  languages: [Language!]
  # The time period to restrict clips based on creation time.
  period: ClipsPeriod = LAST_WEEK
  # The sort order for the clips results.
  sort: ClipsSort = VIEWS_DESC
  # Overrides the period param. If endAt is provided, but startAt isn't, 2015-01-01 will be used for it.
  startAt: Time
}

# Paginated list of Games.
# Implements the Relay cursor connections specification.
# See: https://facebook.github.io/relay/graphql/connections.htm.
type GameConnection {
  # The list of games to display.
  edges: [GameEdge!]
  pageInfo: PageInfo!
}

# Contains information about a Game's relationship to a given page (connection),
# and the Game itself.
type GameEdge {
  cursor: Cursor
  node: Game
  # Unique id per game response item, used by clients to attribute displays/clicks to items.
  trackingID: ID
}

# Game followed by a User.
type GameFollow {
  # Represents when this relationship was established.
  followedAt: Time!
  # The game that is followed.
  game: Game
  # The user who is following.
  user: User
}

# Optional input to filter categories.
# Add any additional optional fields to this input.
input GameOptions {
  # The locale of the user.
  locale: String
  # If sorted by relevance, this provides additional context used to influence recommendations.
  recommendationsContext: RecommendationsContext
  # A GUID that is created by the caller for tracking. This should be globally
  # unique per request and is required if sort=RELEVANCE.
  requestID: ID
  # The sort param can be used to change the default sorting of results.
  sort: GameSort = VIEWER_COUNT
  # Tags are an array of tag IDs as optional filters for categories.
  tags: [String!]
}

# Game that my viewers also like to watch.
type GameOverlap {
  # How much my viewers like to watch this game.
  score: Float!
  # Game that my viewers also like to watch.
  viewersAlsoWatch: Game
}

# The relationship between the authenticated user and a game.
type GameSelfConnection {
  # The current user's follow relationship with this game.
  follow: GameFollow
  # Whether or not the current user has a link to this game that can be used
  # for Drops.
  isDropsLinked: Boolean
}

# Possible ways of sorting collections of categories.
enum GameSort {
  # Sort by number of concurrent viewers, descending (most viewers first).
  VIEWER_COUNT
  # Sort by relevance to the current user.
  RELEVANCE
}

# Optional input to filter game specific streams.
# add additional optional fields to this input.
input GameStreamOptions {
  # Filter streams based on restriction types.
  includeRestricted: [StreamRestrictionType!]
  # Broadcaster languages to filter streams by.
  # Deprecated: use language tags instead.
  languages: [String!]
  # The locale of the user.
  locale: String
  # If sorted by relevance, this provides additional context used to influence recommendations.
  recommendationsContext: RecommendationsContext
  # RequestID must be specified if sort=RELEVANCE.
  requestID: ID
  # The sort param can be used to change the default sorting, which sometimes is specific to specific games.
  sort: StreamSort = VIEWER_COUNT
  # The tags param are an array of tag ID as optional filters for streams.
  tags: [String!]
}

# GDPR Consent contains user consent on different tracking vendors.
input GDPRConsent {
  # Whether Amazon has user GDPR consent.
  allowAmazon: Boolean
  # Whether Comscore has user GDPR consent.
  allowComscore: Boolean
  # Whether Google has user GDPR consent.
  allowGoogle: Boolean
  # Whether Nielson has user GDPR consent.
  allowNielsen: Boolean
  # Whether Salesforce has user GDPR consent.
  allowSalesforce: Boolean
}

# GDPR cookie vendors either support TCF Strings or dont, hence two types of GDPR Vendors.
union GDPRCookieVendor = NonTCFCookieVendor | TCFCookieVendor
# List of GDPR cookie vendors.
type GDPRVendorConsent {
  # status for vendors.
  status: [GDPRCookieVendor!]!
}

# Input to the animateEmote mutation.
input GenerateAnimatedEmoteInput {
  # The ID for the input image. Must be the 4x size.
  image4xID: ID!
  # The preset animation to apply on the provided static emote.
  preset: AnimatedEmotePreset!
}

# Payload from the animateEmote mutation.
type GenerateAnimatedEmotePayload {
  # The ID of the generate request. Pubsub messages will contain this ID to match up the message with the generate request.
  id: ID
  # The animated emote assets.
  animatedAssets: [AnimatedImageAsset!]
}

# GenerateExtensionRatingsCSVInput takes an extensionID and some time range info for generating a CSV of extension ratings
# data for an extension developer.
# Authenticated on UserID via oauth token and OWL (via the ExtensionRatings backend).
input GenerateExtensionRatingsCSVReportInput {
  # endAt is expected to be RFC3339 UTC and is inclusive in the results when truncated to YYYY-MM-DD.
  endAt: Time!
  # extensionID to generate a CSV of ratings data for.
  extensionID: ID!
  # startAt is expected to be RFC3339 UTC and is inclusive in the results when truncated to YYYY-MM-DD.
  startAt: Time!
}

# GenerateExtensionRatingsCSVPayload returns the filename that the CSV report will have when it is completed, and gives
# the caller something to poll for.
type GenerateExtensionRatingsCSVReportPayload {
  # reportFilename is the filename for the generated report.
  reportFilename: String
}

# Error returned during a invalid user request.
type GenerateSecondFactorQRCodeError {
  # Error code returned by the backend.
  code: GenerateSecondFactorQRCodeErrorCode!
  # The localized external error message.
  message: String!
}

# The possible error enums returned while trying to generate a second factor QR code.
enum GenerateSecondFactorQRCodeErrorCode {
  # The user needs to re-authenticate to perform this operation.
  REAUTH_NEEDED
  # The user does not have two factor enabled and cannot generate a QR code.
  NO_TWO_FACTOR
  # The user has requested too many second factor QR codes.
  REQUEST_THROTTLED
  # The user does not exist.
  USER_NOT_FOUND
  # Something unexpected occured.
  UNKNOWN_ERROR
}

# The required input for a generateSecondFactorQRCode mutation.
input GenerateSecondFactorQRCodeInput {
  # The ID of the user that is requesting a new second factor QR code.
  userID: ID!
}

# The result of a generateSecondFactorQRCode mutation.
type GenerateSecondFactorQRCodePayload {
  # error code and localized error.
  error: GenerateSecondFactorQRCodeError
  # qrCode will be a base64 encoded png file.
  qrCode: String
}

# GenerateSubscribersCSVInput takes a channelID to generate a CSV of subscribers for.
# Authenticated on channelID.
input GenerateSubscribersCSVInput {
  # channelID to generate a CSV of subscribers for.
  channelID: String!
}

# GenerateSubscribersCSVPayload returns the channelID it currently generating
# a CSV for.
type GenerateSubscribersCSVPayload {
  # channelID that a subscribers CSV is being generated for.
  channelID: ID!
}

# Generic card containing only the name of the card to display.
type GenericCreatorHomeCard implements CreatorHomeCard {
  # The type of the card, i.e. "STAT_FOLLOWERS_CARD".
  type: String!
}

# The input for getting upload config.
input GetEmoteUploadConfigInput {
  # The type of asset to be uploaded.
  assetType: EmoteAssetType
  # If the asset type is "animated", whether to generate the static versions from the first frame.
  generateStaticVersionOfAnimatedAssets: Boolean
  # Resizing plan to use.
  resizePlan: EmoteResizePlan!
  # Sizes to provide upload URLs for.
  sizes: [EmoteImageSize!]
}

# Response payload.
type GetEmoteUploadConfigPayload {
  # Upload config for resizing/original.
  uploadConfig: UploadConfig @deprecated(reason: "Use uploadConfigs instead.")
  # Upload config for 1x image resouce.
  uploadConfig1x: UploadConfig @deprecated(reason: "Use uploadConfigs instead.")
  # Upload config for 2x image resource.
  uploadConfig2x: UploadConfig @deprecated(reason: "Use uploadConfigs instead.")
  # Upload config for 4x image resource.
  uploadConfig4x: UploadConfig @deprecated(reason: "Use uploadConfigs instead.")
  # Upload configs for all sizes and asset types.
  uploadConfigs: [UploadConfig!]
}

# An error describing why the issue happened, when relevant.
enum GetExtensionSecretsError {
  # User has indicated an invalid extension id.
  INVALID_CLIENT
  # User is unable to read the extension secrets.
  UNAUTHORIZED
  # Something went wrong on our side that we need to fix.
  INTERNAL
}

# GiftCardCode that can be claimed to add a monetary balance to a user's account.
type GiftCardCode implements Claimable {
  # A description of what is claimable for the code.
  description: String!
  # The ID of the Gift Card code.
  id: ID!
  # The field that gives us claim information for the logged in user.
  self: SelfClaimEdge
  # The type is `ClaimableType.GIFT_CARD_CODE`.
  type: ClaimableType!
}

# User edge relating the pin's status to the user.
type GiftCardCodeSelfClaimEdge implements SelfClaimEdge {
  # If the user is eligible to claim the key code.
  canClaim: Boolean!
  # Nullable field for the country where the user redeemed the claimable.
  countryOfResidence: String
  # The user ID that is claiming the code.
  id: ID!
  # Nullable status code for if the user cannot claim the key code.
  statusCode: String
}

# Types of a gift offer.
enum GiftType {
  # A single recipient gift type.
  SINGLE_RECIPIENT
  # A community gift type.
  COMMUNITY
}

# GlobalCheerConfig contains information about (1) How to display Cheers and (2) What Cheermotes are globally available.
type GlobalCheerConfig {
  # The CheermoteDisplayConfig provides information about how Cheermotes can be displayed
  # This includes things like the possible sizes, colors, backgrounds, and display order.
  displayConfig: CheermoteDisplayConfig!
  # The Cheermote Groups containing the Global Cheermotes.
  groups: [CheermoteGroup!]!
}

# Analytics associated with a given notification.
type GoLiveNotification {
  # Custom notification text, e.g., "Summit1g playing Hearthstone today".
  customText: String!
  # Number of followers that engaged with the notification.
  engagements: Int!
  # Number of followers at the time the notification was sent.
  followerCount: Int!
  # Number of followers that were sent the notification.
  followersNotified: Int!
  # Time that the associated stream went live.
  streamStartTime: Time!
}

# GoLiveNotificationConnection represents GoLiveNotification edges and page metadata.
type GoLiveNotificationConnection {
  # Each GoLiveNotificationEdge contains the GoLiveNotification node and cursor data.
  edges: [GoLiveNotificationEdge!]!
  # Page metadata includes hasNextPage/hasPreviousPage.
  pageInfo: PageInfo!
}

# GoLiveNotificationEdges are returned by a given GoLiveNotificationConnection.
type GoLiveNotificationEdge {
  # A GoLiveNotification cursor is represented by an exclusive stream start time.
  cursor: Cursor!
  # The actual GoLiveNotification payload associated with a given edge.
  node: GoLiveNotification
}

# Analytics associated with go live notification timeseries.
type GoLiveNotificationTimeseries {
  # Grouping of notification timeseries items with timestamp and engagements.
  items: [GoLiveNotificationTimeseriesItem!]
  # Sum of all notification engagements for a given date range.
  total: Int!
}

# Single go live notification timeseries item. Represents day, or week/monthly aggregation.
type GoLiveNotificationTimeseriesItem {
  # Number of engagements for a single set of go live notifications.
  engagements: Int!
  # First timestamp for a single set of go live notifications.
  timestamp: Time!
}

# GoRaidError is the error associated with a goRaid.
type GoRaidError {
  # The associated error code.
  code: GoRaidErrorCode!
}

# GoRaidErrorCode are the possible errors that this mutation returns.
enum GoRaidErrorCode {
  # The request is missing valid channel parameters.
  INVALID_CHANNEL
  # The user tries to unraid without an active raid.
  NO_ACTIVE_RAID
}

# Inputs to the goRaid mutation.
input GoRaidInput {
  # Source ID.
  sourceID: ID!
}

# Outputs from the goRaid mutation.
type GoRaidPayload {
  # The possible error returned from the service.
  error: GoRaidError
  # The raid then just went.
  raid: Raid
}

# Set based on the auth input type.
enum GrantType {
  # Used for the initial flow after LWA, one-time usage.
  AUTHORIZATION_CODE
  # Used for follow up refreshes, can be used as many times as needed.
  REFRESH_TOKEN
}

# GrantVIPError contains details about a client error that occurred.
type GrantVIPError {
  # The type of error that occurred when granting VIP status.
  code: GrantVIPErrorCode!
}

# GrantVIPErrorCode defines a client error that occurred while granting the VIP status.
enum GrantVIPErrorCode {
  # The channel does not exist.
  CHANNEL_NOT_FOUND
  # The granter does not have permission to grant VIP status in this channel.
  FORBIDDEN
  # The user who is to be granted the VIP status actually already has the VIP status.
  GRANTEE_ALREADY_VIP
  # The user who is to be granted the VIP status is banned or timed out in this channel.
  GRANTEE_CHAT_BANNED
  # The user who is to be granted the VIP status does not exist.
  GRANTEE_NOT_FOUND
  # The channel has reached the maximum number of users with the VIP status and cannot grant the status to any more users.
  MAX_VIPS_REACHED
  # The channel has not completed the VIP Achievement to unlock the VIP feature.
  VIP_ACHIEVEMENT_INCOMPLETE
}

# GrantVIPInput contains the parameters to grant the VIP status to a user for a channel.
input GrantVIPInput {
  # The channel for which the VIP status of a user will be granted.
  channelID: ID!
  # The ID of the user who will be granted the VIP status.
  # Either granteeID or granteeLogin must be provided.
  granteeID: ID
  # The login of the user who will be granted the VIP status.
  # Either granteeID or granteeLogin must be provided.
  granteeLogin: String
}

# GrantVIPPayload is the response after attemping to grant the VIP status to a user.
type GrantVIPPayload {
  # The channel for which the VIP status of the user was granted.
  channel: User
  # The client error that has occurred.
  # Null if the operation is successful.
  error: GrantVIPError
  # The user who was granted the VIP status.
  grantee: User
}

# Different types of granularities supported.
enum Granularity {
  # Bucketed by five minute intervals.
  FIVE_MINUTE
  # Bucketed by twenty minute intervals.
  TWENTY_MINUTE
  # Bucketed by forty minute intervals.
  FORTY_MINUTE
  # Bucketed by day intervals.
  DAY
  # Bucketed by week intervals.
  WEEK
  # Bucketed by month intervals.
  MONTH
}

# The hearthstone game mode that was played.
type HearthsoneMomentGameMode {
  # The game type (e.g. Ranked, Casual, Arena, Pack Opening, etc.).
  type: String!
  # The value for the game type (e.g. 0-11 for Arena, Priest vs Warlock for Ranked).
  value: String
}

# Moment Details specific to the hearthstone game.
type HearthstoneMomentDetails {
  # The broadcasters hero, can be null.
  broadcasterHero: HearthstoneMomentHero
  # The game mode that was played, can be null.
  gameMode: HearthsoneMomentGameMode
  # The oponents hero, can be null.
  opponentHero: HearthstoneMomentHero
}

# The hero that either the broadcaster or opponent played.
type HearthstoneMomentHero {
  # The hero's (capitalized) class.
  class: String!
  # The hero's id.
  id: ID!
  # The hero's (capitalized) name.
  name: String!
}

# Represents the user's Hero.
type Hero {
  # A unique ID for this hero.
  id: ID!
  # The URI to the pre-composited, full-resolution hero image.
  imageURI: String!
  # The configuration of that hero, to be used by the editor.
  self: HeroConfiguration
}

# Representation of a Hero asset.
type HeroAsset {
  # User colorization of the asset, if any.
  color: String
  # URI to the asset's color mask image.
  colorMaskURI: String
  # When does this asset expire.
  expiresAt: Time
  # Is this asset new to the requesting user.
  isNew: Boolean
  # URI to the asset's line art image.
  lineArtURI: String
  # What skeletons does this asset function properly on.  A NULL entry here
  # indicates that the asset will function on all skeletons.
  supportedSkeletons: [HeroSkeleton!]
  # The type of the asset.
  type: HeroAssetType!
}

# Represents the position of an asset relative to a skeleton.
type HeroAssetPosition {
  # Which type of asset this position refers to.
  assetType: HeroAssetType!
  # x coordinate of the position.
  x: Int!
  # y coordinate of the position.
  y: Int!
}

# The complete list of asset types.
enum HeroAssetType {
  # Background asset.
  BACKGROUND
  # Hat asset.
  HAT
  # Hair asset.
  HAIR
  # Eyebrow asset.
  EYEBROWS
  # Eye asset.
  EYES
  # Glasses asset.
  GLASSES
  # Nose asset.
  NOSE
  # Mouth asset.
  MOUTH
  # Facial hair asset.
  FACIAL_HAIR
  # Freckles asset.
  FRECKLES
  # Undershirt asset.
  UNDERSHIRT
  # Jacket asset.
  JACKET
  # Gloves asset.
  GLOVES
  # Pants asset.
  PANTS
  # Socks asset.
  SOCKS
  # Shoes asset.
  SHOES
}

# Represents the user's Hero configuration.
type HeroConfiguration {
  # What assets the user has equipped.
  assets: [HeroAsset!]
  # Which skeleton the user employed.
  skeleton: HeroSkeleton
  # What color was applied to that skeleton.
  skeletonColor: String
}

# The hero preset.
enum HeroPreset {
  # The first preset.
  PRESET_1
  # The second preset.
  PRESET_2
}

# Represents a Hero skeleton.
type HeroSkeleton {
  # List of x,y offsets for the assets to be properly composited on this skeleton.
  assetPositions: [HeroAssetPosition!]!
  # URI to the color mask for the skeleton.
  colorMaskURI: String!
  # The UUID for this skeleton.
  id: ID!
  # URI to the line art for the skeleton.
  lineArtURI: String!
}

# HiddenView holds the view configuration of an extension if it is a hidden load test extension.
type HiddenView implements ExtensionView {
  # Specifies whether or not the extension has the ability to link to external websites.
  canLinkExternalContent: Boolean!
  # Relative path of the HTML file to load for this view, used by devsite to specify the layout of assets.
  viewerPath: String!
  # The URL which should be loaded in for the extension.
  viewerURL: String!
}

# HiddenView holds the view configuration of an extension if it is a hidden load test extension.
input HiddenViewInput {
  # Relative path of the HTML file to load for this view.
  viewerPath: String!
}

# Input to describe a single continuous time range of the source VOD to be included in the highlight.
input HighlightRange {
  # The end time offset in milliseconds into the VOD.
  endMs: Int!
  # The start time offset in milliseconds into the VOD.
  startMs: Int!
  # The ID of the source VOD to create a Highlight from.
  vodID: ID!
}

# An minimal version of a DONE CompetitionLobby focusing on the outcome of a lobby
type HistoricalCompetitionLobby {
  # id is the unique id of the HistoricalCompetitionLobby.
  id: ID!
  # The participant who had a higher score, if scores are equal and the lobby is done, the lobby ended in a tie.
  winner: CompetitionLobbyParticipant
}

# Paginated list of Users hosting a particular target User.
type HostConnection {
  # Users hosting a target User.
  edges: [HostEdge!]
  # Pagination information for this connection.
  pageInfo: PageInfo!
  # The total number of users hosting a target.
  totalCount: Int
}

# Edge between Users hosting a target.
type HostEdge {
  # Unique identifier for each Users hosting.
  cursor: Cursor!
  # A User hosting.
  node: User
}

# HostTargetChannelError contains a error code.
type HostTargetChannelError {
  # The type of error that occurred when trying to host.
  code: HostTargetChannelErrorCode!
}

# HostTargetChannelErrorCode are the list of thrown errors.
enum HostTargetChannelErrorCode {
  # The target channel is already being hosted.
  TARGET_CHANNEL_ALREADY_HOSTED
  # The target channel is unhostable because the target channel has ignored/banned
  # the channel attempting to host, the target channel is blocked from hosting, etc.
  UNHOSTABLE_CHANNEL
  # The target channel is a TOS/DMCA/suspended channel and cannot be hosted.
  TARGET_CHANNEL_IN_BAD_STANDING
  # A channel cannot host itself.
  CANNOT_HOST_SELF
}

# HostTargetChannelInput contains the necessary inputs to host a target channel.
input HostTargetChannelInput {
  # Channel ID where host was initiated on.
  channelID: ID!
  # Target channel ID to host.
  targetID: ID!
}

# HostTargetChannelPayload is the response after attempting to host.
type HostTargetChannelPayload {
  # The client error that has occurred.
  # Null if the operation is successful.
  error: HostTargetChannelError
  # The channel that is hosting.
  source: User
  # The target channel that is hosted.
  target: User
}

# The wrapper structure that contains information regarding a Hype Train.
type HypeTrain {
  # Configuration for Hype Trains for a channel, normally loaded this way when configuring the Hype Train from the
  # Broadcaster's perspective.
  config: HypeTrainConfig
  # Information pertaining to executions of Hype Trains in a channel. This is loaded on channel page load.
  execution: HypeTrainExecution
}

# The Hype Train reward that's a Badge.
type HypeTrainBadgeReward implements HypeTrainReward {
  # The badge that is to be entitled.
  badge: Badge
  # The identifier of the reward.
  id: ID!
  # The type of reward, which will be HypeTrainRewardType.BADGE.
  type: HypeTrainRewardType!
}

# A conductor of the Hype Train.
type HypeTrainConductor {
  # The participation that made them the Hype Train conductor.
  participation: [HypeTrainParticipation!]!
  # The conductor source.
  source: HypeTrainParticipationSource!
  # The user object that is the conductor.
  user: User!
}

# The configured conductor rewards for a given participation source.
type HypeTrainConductorReward {
  # The rewards entitled for being the conductor and contributing from this source.
  rewards: [HypeTrainReward!]!
  # The source that the conductor participated from.
  source: HypeTrainParticipationSource!
  # The type of conductor that gets this reward.
  type: HypeTrainConductorType!
}

# The conductor type of the Hype Train reward.
enum HypeTrainConductorType {
  # The current conductor of an active hype train.
  CURRENT
  # The former conductor of a hype train.
  FORMER
  # An unknown conductor type.
  UNKNOWN
}

# The Hype Train config for a channel.
type HypeTrainConfig {
  # A custom setting that will be an emote that the user has chosen (or PogChamp
  # if not set) to display in their Hype Train events.
  calloutEmote: Emote
  # The conductor rewards for a Hype Train successful execution.
  conductorRewards: [HypeTrainConductorReward!]!
  # The cooldown period between Hype Train executions.
  cooldownPeriodMinutes: Int!
  # The difficulty of the Hype Train.
  difficulty: HypeTrainDifficulty!
  # The configured levels of the Hype Train.
  difficultySettings: [HypeTrainDifficultySettings!]!
  # The identifier for the hype train.
  id: ID!
  # The boolean flag that denotes if the Hype Train is enabled or not.
  isEnabled: Boolean!
  # The structure that holds the parameters for tweaking how a Hype Train gets kicked off.
  kickoff: HypeTrainKickoffConfig!
  # The duration a Hype Train level executes for.
  levelDurationSeconds: Int!
  # The threshold for a notification to be displayed.
  notificationThresholds: [HypeTrainNotificationThreshold!]!
  # The conversion rates for all the actions that contribute to Hype Train progress.
  participationConversionRates: [HypeTrainParticipationConversionRate!]!
  # Hex color for the current hype train. Null if not enabled or no theme color is set.
  primaryHexColor: String
  # A boolean flag that indicates if the hype train settings should be personalized by Twitch.
  shouldUsePersonalizedSettings: Boolean!
  # A custom setting for using the creators color as the base color of hype trains.
  willUseCreatorColor: Boolean!
}

# The difficulty a Hype Train can be set to.
enum HypeTrainDifficulty {
  # Easy, the easiest difficulty level.
  EASY
  # Medium, the middle difficulty level.
  MEDIUM
  # Hard, the hard difficulty level.
  HARD
  # Super Hard, the harder difficulty level.
  SUPER_HARD
  # Insane, the hardest difficulty level.
  INSANE
  # An unknown difficulty.
  UNKNOWN
}

# A mapping between a difficulty and the levels that correspond.
type HypeTrainDifficultySettings {
  # The difficulty of the level.
  difficulty: HypeTrainDifficulty!
  # The levels associated with the difficulty.
  levels: [HypeTrainLevel!]!
}

# The Hype Train reward that's an Emote.
type HypeTrainEmoteReward implements HypeTrainReward {
  # The emote that is to be entitled.
  emote: Emote
  # The identifier of the reward.
  id: ID!
  # The type of reward, which will be HypeTrainRewardType.EMOTE.
  type: HypeTrainRewardType!
}

# The enumerated end reasons for a Hype Train.
enum HypeTrainEndReason {
  # The Hype Train expired, which means that the Hype Train never completed level 1 after being started.
  EXPIRED
  # The Hype Train is in progress, which means it has not ended.
  IN_PROGRESS
  # The Hype Train was completed, which means that any level was completed.
  COMPLETED
  # An unknown ending reason.
  UNKNOWN
}

# An enumeration of event types for Hype Train Activity Feeds.
enum HypeTrainEventType {
  # Event of when a Hype Train started for the given channel.
  HYPE_TRAIN_STARTED
  # Event of when a Hype Train ended for the given channel.
  HYPE_TRAIN_ENDED
  # Notification of when another Hype Train can start.
  HYPE_TRAIN_COOL_DOWN_EXPIRED
}

# The structure that defines Hype Train Execution in a channel.
type HypeTrainExecution {
  # The conductors of the Hype Train.
  conductors: [HypeTrainConductor!]!
  # The Hype Train config that the train was started with.
  config: HypeTrainConfig!
  # The reason the Hype Train was ended, if it has been ended.
  endReason: HypeTrainEndReason
  # The time the Hype Train was ended, if the Hype Train was a previous execution.
  endedAt: Time
  # The time that the Hype Train will expire at.
  expiresAt: Time!
  # The identifier of the execution.
  id: ID!
  # Boolean flag that denotes if the Hype Train is active or not.
  isActive: Boolean!
  # The participation events in the Hype Train.
  participations: [HypeTrainParticipation!]!
  # The progress structure that contains relevant information about how much progress the Hype Train acheived.
  progress: HypeTrainProgress!
  # The time that the Hype Train started.
  startedAt: Time!
  # The last time the Hype Train was updated.
  updatedAt: Time!
}

# The Hype Train kickoff configuration.
type HypeTrainKickoffConfig {
  # What quantity of current commerce events can trigger a Hype Train.
  eventsThreshold: Int!
  # The minimum value of points that the combined events have to equal to kick off a Hype Train.
  minPoints: Int!
  # The period of time that is required for these commerce events to occur in to execute a Hype Train.
  periodSeconds: Int!
}

# HypeTrainKickoffInput specifies settings for kicking off hype trains.
input HypeTrainKickoffInput {
  # The number of qualifying events needed to kickoff a hype train.
  eventsThreshold: Int
}

# The Hype Train level configuration, which includes information about level completion and associated rewards.
type HypeTrainLevel {
  # The value of participation that will take to complete the level.
  goal: Int!
  # The level ID.
  id: ID!
  # The associated rewards for completing the level.
  rewards: [HypeTrainReward!]!
  # The value of the level, like Level 1, 2, etc. Can be configurable.
  value: Int!
}

# The notification threshold for an action / source combination.
type HypeTrainNotificationThreshold {
  # The action performed.
  action: HypeTrainParticipationAction!
  # The source of the action.
  source: HypeTrainParticipationSource!
  # The value that is the theshold for displaying a notification.
  value: Int!
}

# The Hype Train participation structure that contains relevant information about the participation event.
type HypeTrainParticipation {
  # The type of participation.
  action: HypeTrainParticipationAction!
  # The amount that the participation is valued in the Hype Train progress.
  quantity: Int!
  # The participation source.
  source: HypeTrainParticipationSource!
}

# The participation action of events in a Hype Train.
enum HypeTrainParticipationAction {
  # A Cheer event.
  CHEER
  # A use of bits in extensions.
  BITS_ON_EXTENSION
  # A poll bits usage.
  POLLS
  # A tier 1 sub purchase.
  TIER_1_SUB
  # A tier 2 sub purchase.
  TIER_2_SUB
  # A tier 3 sub purchase.
  TIER_3_SUB
  # A tier 1 sub gift.
  TIER_1_GIFTED_SUB
  # A tier 2 sub gift.
  TIER_2_GIFTED_SUB
  # A tier 3 sub gift.
  TIER_3_GIFTED_SUB
  # An unkonwn action.
  UNKNOWN
}

# The participation conversion rate for what an action will count towards the Hype Train.
type HypeTrainParticipationConversionRate {
  # The action performed.
  action: HypeTrainParticipationAction!
  # The source of the action.
  source: HypeTrainParticipationSource!
  # The rate that it will be converted as in the Hype Train progress calculations.
  value: Int!
}

# The Hype Train participation source that denotes the commerce types that can occur.
enum HypeTrainParticipationSource {
  # Bits source, like cheering.
  BITS
  # Subs source, like subbing to twitch.tv/michael on stream.
  SUBS
  # An unknown source.
  UNKNOWN
}

# The structure that contains relevant information about the current progress in the Hype Train.
type HypeTrainProgress {
  # The goal value that the Hype Train is trying to complete.
  goal: Int!
  # The Level that the Hype Train is currently on.
  level: HypeTrainLevel!
  # The current progression that the channel has made in the level.
  progression: Int!
  # The number of seconds left until this Hype Train execution ends.
  remainingSeconds: Int!
  # The total progression overall that has occurred in the Hype Train across all levels.
  total: Int!
}

# The hype train reward interface, which has to implement an identifier and the hype train reward type.
interface HypeTrainReward {
  # The identifier of the reward.
  id: ID!
  # The type of reward that is entitled.
  type: HypeTrainRewardType!
}

# The enumerated types of rewards that can be entitled.
enum HypeTrainRewardType {
  # Emote rewards.
  EMOTE
  # Badge rewards.
  BADGE
  # An unknown reward type.
  UNKNOWN
}

type Image {
  # The original height of the image in pixels.
  height: Int!
  # The URL source of the image.
  imageURL: String! @deprecated(reason: "Use the 'url' query instead.")
  # The URL source of the image.
  url(width: Int, height: Int): String!
  # The original width of the image in pixels.
  width: Int!
}

input ImageOptions {
  # The height of the image in pixels.
  height: Int
  # The width of the image in pixels.
  width: Int
}

# Friend requests sent from other users to this user.
type IncomingFriendRequestConnection {
  # The friend request elements of this list.
  edges: [IncomingFriendRequestEdge!]!
  # The most recent incoming friend request received by this user, if any exist. This field is provided as a
  # convenience, as edges is not strictly time-ordered. The incoming friend request's presence in this field does not
  # prevent it from also occurring in edges.
  newestEdge: IncomingFriendRequestEdge
  # Information about this page.
  pageInfo: PageInfo!
  # The total number of incoming friend requests.
  totalCount: Int!
  # The total number of unseen incoming friend requests. Use the ClearUnreadFriendRequests mutation to set this to 0.
  totalUnreadCount: Int!
}

# A friend request sent from another user to this user.
type IncomingFriendRequestEdge {
  # The time at which the friend request was sent.
  createdAt: Time!
  # An opaque cursor identifying the edge's position in the paginated list.
  cursor: Cursor!
  # The user who sent the friend request.
  node: User
}

# Determines what other channels can raid this channel.
enum IncomingRaidsPolicy {
  # This user cannot be radied by anyone.
  NONE
  # This user can be raided by other people in their network.
  NETWORK
  # This user can be raided by anyone.
  ALL
}

# IngestFrameDrop represent an event where a video frame is dropped while ingesting a video stream.
type IngestFrameDrop {
  # Duration of events in seconds.
  durationSeconds: Float!
  # Start time of the event.
  startedAt: Time!
}

# IngestSession is a set of stream metadata related to ingest events.
type IngestSession {
  # Type of live stream.
  broadcastFormat: BroadcastFormat!
  # Staff-only field. Hostname for the session where ingest stream was received.
  ingestHost: String
  # Name of Ingest Server PoP that received the broadcast. Ex) IAD or PDX.
  ingestProxy: String!
  # How many seconds were intentionally delayed in stream as requested by the broadcaster.
  streamDelaySeconds: Int!
  # The time when the stream was ended.
  streamDownAt: Time
  # The time when the stream was started.
  streamUpAt: Time
}

# IngestStarvationEvent represent an event where an expected video frame from broadcaster does not arrive.
type IngestStarvationEvent {
  # Duration of events in seconds.
  durationSeconds: Float!
  # Starr time of the event.
  startedAt: Time!
}

# Set of codes to warn the broadcaster about what is wrong with the stream.
type IngestStreamHealth {
  # Reasons why the stream is unstable.
  reasons: [IngestStreamHealthReason!]
  # Indicate whether the stream is at okay, warning or unstable status.
  status: IngestStreamHealthStatus!
}

# Reason of why the stream is unstable.
enum IngestStreamHealthReason {
  # Reason not set.
  UNKNOWN
  # Stream is behaving normally.
  ALL_GOOD
  # Broadcaster's encoder is sending an incompatible audio codec.
  INCOMP_AUDIO_CODEC
  # Broadcaster's encoder is sending an incompatible video codec.
  INCOMP_VIDEO_CODEC
  # Broadcaster's encoder is using a deprecated MP3 audio codec.
  INCOMP_MP3_DEPRECATED
  # The stream is unstable due to high bitrate of the stream.
  HIGH_BITRATE
  # Some frames are being dropped by the broadcaster's encoder.
  DROPPED_FRAMES
  # Ingest server expects video segments in sequence, but the server did not receive them from the client.
  STARVATION
  # The interval between each key frame is too high.
  HIGH_KEY_FRAME_INTERVAL
}

# Health of the stream to inform the broadcaster.
enum IngestStreamHealthStatus {
  # A misspelling of UNKNOWN.
  UNKNWON @deprecated(reason: "Use UNKNOWN instead")
  # The stream is ingested okay.
  OK
  # The stream is at warning level.
  WARN
  # The stream is unstable.
  UNSTABLE
  # Health Status not set.
  UNKNOWN
}

# Insight cards contains a single piece of information in regards to a creator's stream.
type InsightCreatorHomeCard implements CreatorHomeCard {
  # The type of the card, i.e. "STAT_FOLLOWERS_CARD".
  type: String!
  # currentValue indicates where the creator is in regards to an insight.
  # i.e You have gained "12" new followers.
  currentValue: Float!
}

# InstallExtensionError is wrapper for error associated with the installExtension mutation.
type InstallExtensionError {
  # Error code.
  code: InstallExtensionErrorCode!
  # The installation id if got EXTENSION_ALREADY_INSTALLED error.
  installationID: ID
}

# InstallExtensionErrorCode is an error code associated with InstallExtensionError.
enum InstallExtensionErrorCode {
  # User is unable to make modifications to the extension.
  UNAUTHORIZED
  # Channel id is invalid, for example, is empty.
  INVALID_CHANNEL_ID
}

# The required input for an installExtension mutation.
input InstallExtensionInput {
  # The channelID the user is installing the extension on.
  channelID: ID!
  # The composite ID of an extension <extensionID:version>.
  extensionID: ID!
}

# The result of an installExtension mutation.
type InstallExtensionPayload {
  # The error when the mutation fails to install extension.
  error: InstallExtensionError
  # The resulting extension installation record from the install.
  installedExtension: ExtensionInstallation
}

# A shelf title token type that contains a number with various formatters.
type IntegerToken {
  # The numerical value to display for this token.
  value: Int!
}

# InternalChargeModel defines a 1P price identifier for the offer.
type InternalChargeModel {
  # The charge model plan. It will be omitted for consumable purchases (e.g. Bits).
  plan: ChargeModelPlan
  # Preview of the price.
  previewPrice: PriceInfo
  # The price identifier.
  priceID: ID!
  # The authenticated user's relationship with the internal charge model.
  self: InternalChargeModelSelfEdge
}

# The authenticated user's relationship with the internal charge model.
type InternalChargeModelSelfEdge {
  # Contains information on the final checkout price of this offer.
  checkoutPrice(
    quantity: Int!
    paymentProvider: PaymentProvider!
  ): ProductPurchase
}

# InterruptScheduleBoundsError represents errors that are due to input being out of bounds.
type InterruptScheduleBoundsError implements InterruptScheduleError {
  # Error code.
  code: InterruptScheduleErrorCode!
  # If the error is related to an input out of service-defined bounds, provide the maximum allowed value.
  maximum: Int
  # If the error is related to an input out of service-defined bounds, provide the miniimum allowed value.
  minimum: Int
}

# InterruptScheduleError is a wrapper for error associated with the CreateScheduleSegment mutation.
interface InterruptScheduleError {
  # Error code.
  code: InterruptScheduleErrorCode!
}

# The possible errors.
enum InterruptScheduleErrorCode {
  # Not authorized to disable the schedule.
  FORBIDDEN
  # The schedule was not found.
  NOT_FOUND
  # EndAt is too far in the future.
  END_TOO_FAR_IN_FUTURE
  # The argument is invalid and does not map to a known error.
  INVALID_ARGUMENT
}

# The input to interrupt a schedule.
input InterruptScheduleInput {
  # The end time when the schedule will no longer be disabled.
  endAt: Time!
  # The reason the schedule was disabled.
  reason: ScheduleInterruptionReason!
  # The id of the schedule.
  scheduleID: ID!
  # The start time when the schedule will be disabled.
  startAt: Time!
  # The geographic timezone of the new segment defined by IANA; i.e. "America/Los_Angeles".
  timezone: String!
}

# The payload returned when interrupting a schedule.
type InterruptSchedulePayload {
  # The possible error.
  error: InterruptScheduleError
  # The updated stream schedule.
  schedule: Schedule
}

# InterruptScheduleStandardError represents general errors that are not related to bound errors.
type InterruptScheduleStandardError implements InterruptScheduleError {
  # Error code.
  code: InterruptScheduleErrorCode!
}

# Arguments for the invalidation of all of a user's sessions.
input InvalidateAuthenticatedSessionsInput {
  # Session to keep alive.
  keepSession: String
  # Twitch user owner of the sessions.
  userID: ID!
}

# Payload after invalidating sessions.
type InvalidateAuthenticatedSessionsPayload {
  # Twitch User.
  user: User
}

# InvalidateEmailAssociationPayload is input required to mark a user as not owning an email address.
input InvalidateEmailAssociationInput {
  # Email address that is incorrectly attributed to a user.
  email: String!
  # EmailAssociationOpaqueID is the OpaqueID of the association to the above email.
  emailAssociationOpaqueID: ID!
}

# InvalidateEmailAssociationPayload is the response payload.
type InvalidateEmailAssociationPayload {
  # HasSucceeded indicates whether or not the request has succeeded.
  hasSucceeded: Boolean!
}

# Contains the inventory for a particular user, which consists of drops.
type Inventory {
  # The campaigns which have drops that the user is eligible for and has banked
  # (or is currently earning) minutes-watched progress for.
  dropCampaignsInProgress: [DropCampaign!]
  # The drops awarded to this user via Drops 1.0 and triggered by game publishers according to minutes watched data.
  drops: UserDropAwardConnection
  # The drops awarded to this user via Drops 2.0 and triggered by broadcaster's game events.
  gameEventDrops: [UserDropReward]
}

# IOSPaymentTrackingDataInput contains fields to pass in tracking data related to iOS payments.
input IOSPaymentTrackingDataInput {
  # The user's device ID.
  deviceID: ID
  # The locale of the user.
  locale: String
}

# IOSReceiptDataInput contains the necessary fields to pass in iOS purchase receipt data.
input IOSReceiptDataInput {
  # The encrypted receipt of an iOS purchase, signed by Apple. Required to process any iOS payment.
  signedReceipt: String!
  # The external transaction ID.
  extTransactionID: ID!
}

# Associated metrics for the "It Begins" quest.
type ItBegins {
  # Image URL for the quest's badge.
  badgeURL: String
  # Time that this quest was completed.
  completedAt: Time
  # Whether or not the user has streamed before.
  hasStreamed: Boolean
  # Whether or not the user has updated their category before.
  hasUpdatedCategory: Boolean
  # Whether or not the user has updated their stream title before.
  hasUpdatedStreamTitle: Boolean
  # Whether or not the user has visited their stream manager.
  hasVisitedDashboard: Boolean
}

input JoinChannelRoomsInput {
  channelID: ID!
}

type JoinChannelRoomsPayload {
  channel: User
}

# Inputs to the joinRaid mutation.
input JoinRaidInput {
  # The raid ID being joined by the user.
  raidID: ID!
}

# Outputs from the joinRaid mutation.
type JoinRaidPayload {
  # The ID of the raid that was joined by the user.
  raidID: ID
}

# The connection of key batches for a given key pool.
type KeyBatchConnection {
  # The list of key batch edges in the connection.
  edges: [KeyBatchEdge!]!
  # The metadata about having more key batches to fetch, or if there is a previous page of key batches.
  pageInfo: PageInfo!
  # The total number of key batches for the key pool.
  totalCount: Int!
}

# The key batch edge which contains our cursor and node.
type KeyBatchEdge {
  # The cursor of the edge, which is the key batch ID.
  cursor: Cursor!
  # The node of the edge, which contains all information about the key batch.
  node: KeyBatchNode
}

# The information associated with a given key batch.
type KeyBatchNode {
  # The key batch ID, which is unique for a given key pool.
  id: ID!
  # The number of keys in the batch.
  numKeys: Int!
  # The status of the batch.
  status: KeyBatchStatus!
}

# An enumeration of key batch statuses.
enum KeyBatchStatus {
  # The key batch is active and keys generated from it can be claimed.
  ACTIVE
  # The key batch is inactive and keys generated from it cannot be claimed.
  INACTIVE
  # The key batch is invalid and keys generated from it are invalidated.
  INVALIDATED
}

# The connection of key pools to a user.
type KeyPoolConnection {
  # The list of key pool edges associated with the user.
  edges: [KeyPoolEdge!]!
  # The metadata about having more key pools to fetch, or if there is a previous page of key pools.
  pageInfo: PageInfo!
  # The total number of key pools for the given user.
  totalCount: Int!
}

# The key pool edge which contains our cursor and node.
type KeyPoolEdge {
  # The cursor of the edge, which is also the key pool ID.
  cursor: Cursor!
  # The node of the edge, which contains all information about the key pool.
  node: KeyPoolNode
}

# The information associated with a given key pool.
type KeyPoolNode {
  # The key batches that have been generated in the key pool.
  batches(after: String): KeyBatchConnection
  # The description of the key pool.
  description: String!
  # The key pool ID, which is unique.
  id: ID!
  # The product type associated with the key pool, which determines what kind of keys are generated.
  productType: String!
  # The SKU associated with the key pool, which is used to redeem content.
  sku: String!
  # Status of the key pool, which can be active, inactive, or invalidated.
  status: KeyPoolStatus!
}

# An enumeration of key pool statuses.
enum KeyPoolStatus {
  # The key pool is active and can generate more key batches.
  ACTIVE
  # The key pool is inactive and all batches are invalid.
  INACTIVE
  # The key pool is invalid and new batches cannot be made.
  INVALIDATED
}

# An enumeration of broadcaster languages.
enum Language {
  # Arabic.
  AR
  # American Sign Language.
  ASL
  # Bulgarian.
  BG
  # Catalan.
  CA
  # Czech.
  CS
  # Danish.
  DA
  # German.
  DE
  # Greek.
  EL
  # English.
  EN
  # Spanish.
  ES
  # Finnish.
  FI
  # French.
  FR
  # Hindi.
  HI
  # Hungarian.
  HU
  # Indonesian.
  ID
  # Italian.
  IT
  # Japanese.
  JA
  # Korean.
  KO
  # Malay.
  MS
  # Dutch.
  NL
  # Norwegian.
  NO
  # Other.
  OTHER
  # Polish.
  PL
  # Portuguese.
  PT
  # Romanian.
  RO
  # Russian.
  RU
  # Slovak.
  SK
  # Swedish.
  SV
  # Thai.
  TH
  # Tagalog.
  TL
  # Turkish.
  TR
  # Ukrainian.
  UK
  # Vietnamese.
  VI
  # Chinese.
  ZH
  # Chinese (Hong Kong).
  ZH_HK
}

# An enumeration of user language tags (shortened BCP 47) available on Twitch.
# This should not be confused with Language, which is broadcaster language.
enum LanguageTag {
  # Arabic.
  AR
  # Bulgarian.
  BG
  # Czech.
  CS
  # Danish.
  DA
  # German.
  DE
  # Greek.
  EL
  # English.
  EN
  # English - Great Britain.
  EN_GB
  # Spanish.
  ES
  # Spanish - Mexico.
  ES_MX
  # Finnish.
  FI
  # French.
  FR
  # Hindi.
  HI
  # Hungarian.
  HU
  # Italian.
  IT
  # Japanese.
  JA
  # Korean.
  KO
  # Dutch.
  NL
  # Norwegian.
  NO
  # Polish.
  PL
  # Portuguese.
  PT
  # Portuguese - Brazil.
  PT_BR
  # Romanian.
  RO
  # Russian.
  RU
  # Slovak.
  SK
  # Swedish.
  SV
  # Thai.
  TH
  # Turkish.
  TR
  # Vietnamese.
  VI
  # Chinese - China.
  ZH_CN
  # Chinese - Taiwan.
  ZH_TW
  # Chinese.
  ZH
}

# The details of Leaderboard format.
type LeaderboardDetails {
  # The max participant count for a lobby in phase. Valid values are 1-100.
  lobbyMaxSize: Int!
  # The number of phases to be created for the competition. Valid values are 1-20.
  phaseCount: Int!
  # A display string conveying how a Competition Organizer intends to resolve ties.
  tiebreakerLabel: TiebreakerLabel
}

# LeaderboardSet contains the set of leaderboards that are active on a channel.
type LeaderboardSet {
  # bits contains the leaderboard of top users by number of bits cheered for the channel.
  bits: UserLeaderboard
  # subGift contains the leaderboard of top users by number of sub gifts given in the channel.
  subGift: UserLeaderboard
}

# Partner dashboard settings for the bits cheering and sub gifting leaderboards.
type LeaderboardSettings {
  # The default leaderboard the user wants to show.
  defaultLeaderboard: LeaderboardType!
  # Flag that is true if the user has bits cheering leaderboards turned on.
  isCheerEnabled: Boolean!
  # Flag that is true if the user has sub gifting leaderboards turned on.
  isSubGiftEnabled: Boolean!
  # The time period the user wants the leaderboard to be displayed as.
  timePeriod: LeaderboardTimePeriodType!
}

# LeaderboardTimePeriodType enumerates the various types of supported Leaderboards.
enum LeaderboardTimePeriodType {
  # Daily leaderboards reset at midnight PT.
  DAY
  # Weekly leaderboards reset at midnight PT between Sunday and Monday.
  WEEK
  # Monthly leaderboards reset at midnight PT on the last day of the month.
  MONTH
  # All time leaderboards are cumulative back to when Bits launched in June of 2016.
  ALLTIME
}

# LeaderboardType enumerates the various types of supported Leaderboards.
enum LeaderboardType {
  # Bits cheering leaderboards.
  CHEER
  # Sub gifting leaderboards.
  SUBGIFT
}

input LeaveChannelRoomsInput {
  channelID: ID!
}

type LeaveChannelRoomsPayload {
  channel: User
}

# Inputs to the leaveRaid mutation.
input LeaveRaidInput {
  # The raid ID being left by the user.
  raidID: ID!
}

# Outputs from the leaveRaid mutation.
type LeaveRaidPayload {
  # The ID of the raid that was joined by the user.
  raidID: ID
}

# LeaveSquadStreamError is the error associated with a leaveSquadStream.
type LeaveSquadStreamError {
  # The associated error code.
  code: LeaveSquadStreamErrorCode!
}

# LeaveSquadStreamErrorCode are the possible errors that this mutation returns.
enum LeaveSquadStreamErrorCode {
  # The user is not in the squad specified.
  USER_NOT_IN_SQUAD
  # The operation is unauthorized.
  UNAUTHORIZED
}

# Inputs to the leaveSquadStream mutation.
input LeaveSquadStreamInput {
  # The optional ID of a squad member that is leaving the squad (defaults to ID from auth token).
  memberID: ID!
  # The ID of the squad stream that the caller wants to leave.
  squadStreamID: ID!
}

# Outputs from the leaveSquadStream mutation.
type LeaveSquadStreamPayload {
  # The possible error returned from the service.
  error: LeaveSquadStreamError
  # The updated squad stream.
  squadStream: SquadStream
}

# LinkOEmbed is a link oEmbed.  This looks strange being empty, but mirrors the oEmbed official spec most exactly.
type LinkOEmbed implements OEmbed {
  authorName: String
  authorURL: String
  cacheAge: Int
  inputURL: String!
  providerName: String
  providerURL: String
  thumbnail: ThumbnailOEmbed
  title: String
  type: String!
  version: String!
}

# LinkSSOError is an error that occurs when account linking fails.
type LinkSSOError {
  # The error code that describes why account linking failed.
  code: LinkSSOErrorCode! @deprecated(reason: "To be removed.")
}

# LinkSSOErrorCode enumerates the possible errors that can cause account linking to fail.
enum LinkSSOErrorCode {
  # The activation code is incorrect.
  CODE_INCORRECT @deprecated(reason: "To be removed.")
  # The activation code is expired.
  CODE_EXPIRED @deprecated(reason: "To be removed.")
  # The user has already linked an SSO app of the same type to their account.
  ALREADY_LINKED @deprecated(reason: "To be removed.")
}

# LinkSSOInput links an SSO app to the authenticated user's account if the activation code is valid.
input LinkSSOInput {
  # The code that identifies the single sign-on (SSO) app that should be linked to the authenticated user's account.
  code: String!
}

# LinkSSOPayload returns the newly created link or an error if account linking failed.
type LinkSSOPayload {
  # The error when an app cannot be linked to the user's account.
  error: LinkSSOError @deprecated(reason: "To be removed.")
  # The new SSO link.
  link: SSOLink @deprecated(reason: "To be removed.")
}

# The location that a piece of text should link to.
enum LinkType {
  # Do not link to anything.
  NO_LINK
  # Link to the categories directory (on web: https://www.twitch.tv/directory).
  CATEGORIES_DIRECTORY
  # Link to the streams directory (on web: https://www.twitch.tv/directory/all).
  STREAMS_DIRECTORY
}

# LiveConfigView holds the view configuration of an extension if the live config dashboard page is supported.
type LiveConfigView implements ExtensionView {
  # Specifies whether or not the extension has the ability to link to external websites.
  canLinkExternalContent: Boolean!
  # Relative path of the HTML file to load for this view, used by devsite to specify the layout of assets.
  viewerPath: String!
  # The URL which should be loaded in for the extension.
  viewerURL: String!
}

# LiveConfigViewInput holds the view configuration of an extension if the live config dashboard page is supported.
input LiveConfigViewInput {
  # Relative path of the HTML file to load for this view.
  viewerPath: String!
}

type LiveRecommendationConnection {
  # The list of recommended streams with metadata to display.
  edges: [StreamRecommendationEdge!]
  # Per-generation tracking id for identifying a recommendation model.
  generationID: String!
  # The list of recommended streams to display.
  nodes: [Stream]!
    @deprecated(
      reason: "To be replaced by edges which also includes a required trackingID."
    )
  # Unique tracking id per response.
  responseID: String!
}

# Information about the live up notification of a user.
type LiveUpNotificationInfo {
  # Whether the user's liveUpNotification field is the default value (i.e. "<user> went live!").
  isDefault: Boolean
  # The text that will be in the notification that sends when the user starts broadcasting.
  # The default value is currently a translated version of "<user> went live!" when the user has not set a custom value.
  liveUpNotification: String
}

# The lobby state signifies the progress in the competition.
enum LobbyState {
  # No participants are in lobby.
  PREP
  # Participants have filled the lobby and can be swapped around different lobbies.
  READY
  # Participants are currently playing in the lobby, they can be scored but cannot be swapped to different lobbies.
  ACTIVE
  # Participants are all scored and no longer playing.
  DONE
  # Lobby state is unknown.
  UNKNOWN
}

# An error returned from the lockPredictionEvent mutation.
type LockPredictionEventError {
  # Code describing the error.
  code: LockPredictionEventErrorCode!
}

# Possible error codes from the lockPredictionEvent mutation.
enum LockPredictionEventErrorCode {
  # The current user is forbidden from updating this Prediction Event.
  FORBIDDEN
  # This Prediction Event is not currently in the ACTIVE state.
  EVENT_NOT_ACTIVE
  # An unknown error occurred.
  UNKNOWN
}

# Input for moving a Prediction Event from ACTIVE to LOCKED, so that users can no longer make predictions on it.
input LockPredictionEventInput {
  # The unique identifier of the Prediction Event to move from ACTIVE to LOCKED.
  id: ID!
}

# Payload from closing a prediciton event to new predictions.
type LockPredictionEventPayload {
  # If present, there was an error with the request.
  error: LockPredictionEventError
  # The updated Prediction Event.
  predictionEvent: PredictionEvent
}

# Communicates a Loyalty Badge (usually during upload).
type LoyaltyBadge {
  # Unique identifier the badges method of tenure by channelid and cumulative months.
  channelTenureMethodID: ID!
  # The channel's loyalty badge unique identifier.
  id: ID!
  # image1xURL to retrieve the 1x sized Badge.
  image1xURL: String!
  # Image1xURL to retrieve the 2x sized Badge.
  image2xURL: String!
  # image4xURL to retrieve the 4x sized Badge.
  image4xURL: String!
  # Identifies the amount of cumulative tenure months to acquire Badge.
  requiredTenureMonths: Int!
  # A localized, human-friendly title for the badge.
  # Defaults to English if no translation exists for the requested locale.
  title: String!
}

# LoyaltyBadgeUploadConfig is the upload configuration for creating loyalty badges.
type LoyaltyBadgeUploadConfig {
  # The image ID of the badge image.
  imageID: ID
  # The resulting URL of the badge image.
  imageURL: String
  # The upload ID of the badge file.
  uploadID: ID
  # The URL to upload the badge image to.
  uploadURL: String
}

# Caller should store all of these fields.
type LWAToken {
  # Access token to pass in on subsequent requests.
  accessToken: String!
  # TTL in seconds, default is 3600.
  expiresIn: Int!
  # Should be stored, though generally shouldn't change.
  refreshToken: String!
}

# Input for creating a batch download URL for key codes.
input MakeKeyBatchDownloadURLInput {
  # The ID of the batch to download.
  batchID: String!
}

# The results of creating a key batch download.
type MakeKeyBatchDownloadURLPayload {
  # The decryption key to decrypt the batch of keys.
  decryptionKey: String!
  # The URL created for downloading the batch of keys.
  url: String!
}

# An error returned from the makePrediction mutation.
type MakePredictionError {
  # Code describing the error.
  code: MakePredictionErrorCode!
  # If the error code is MAX_POINTS_PER_EVENT, this will specify how many total points the user is allowed to spend.
  maxPointsPerEvent: Int
  # If the error code is MAX_POINTS_PER_EVENT, this will specify how many points the user has already spent.
  userPointsSpent: Int
}

# Possible error codes from the makePrediction mutation.
enum MakePredictionErrorCode {
  # The current user is forbidden from making a Prediction on this Prediction Event.
  FORBIDDEN
  # The provided event ID or outcome ID does not exist.
  NOT_FOUND
  # This Prediction Event is no longer actively accepting predictions.
  EVENT_NOT_ACTIVE
  # The client is retrying with a transaction id that has already been used.
  DUPLICATE_TRANSACTION
  # The client is retrying with a transaction id that is currently being processed in another request.
  TRANSACTION_IN_PROGRESS
  # The user does not have enough points to make this prediction.
  NOT_ENOUGH_POINTS
  # Making this prediction would bring the user's total amount spent on this prediction above the maximum.
  MAX_POINTS_PER_EVENT
  # The user has already made a prediction on a different Outcome, so this prediction cannot be made.
  MULTIPLE_OUTCOMES
  # The user is restricted from full participation because their geographic
  # location has a blanket ban on Prediction participation.
  REGION_LOCKED
  # The user must accept the Predictions Terms of Service.
  MUST_ACCEPT_TOS
  # The user's request was rate limited. They can try again after a few seconds.
  RATE_LIMITED
  # The user is restricted from full participation because their geographic
  # location has a ban on Predictions for the specific game/category being played.
  CATEGORY_REGION_LOCKED
  # The user is restricted from full participation because they have the ability to manage Predictions on this channel.
  EVENT_MANAGER
  # The user attempted to make a Prediction in Spectator Mode but is ineligible for that mode.
  SPECTATOR_MODE_INELIGIBLE
  # The user attempted to make a Prediction in Spectator Mode but has already made one on this Event.
  SPECTATOR_MODE_DUPLICATE
  # An unknown error occurred.
  UNKNOWN
}

# Input for making a Prediction.
input MakePredictionInput {
  # The unique identifier of the Prediction Event to make the prediction on.
  eventID: ID!
  # The unique identifier of the Prediction Outcome to make the prediction on.
  outcomeID: ID!
  # The number of points to spend on this Prediction.
  points: Int!
  # Client-set identifier for the transaction. This ID should be universally unique.
  transactionID: ID!
}

# Payload for making a prediction.
type MakePredictionPayload {
  # If present, there was an error with the request.
  error: MakePredictionError
  # The created or updated Prediction.
  prediction: Prediction
}

# A custom challenge created by the broadcaster.
type ManualChannelChallenge implements ChannelChallenge {
  # Total bits amount contributed.
  bitsAmount: Int!
  # Time when challenge was created.
  createdAt: Time!
  # User that created the challenge.
  createdBy: User
  # Amount of seconds from when the challenge starts to when it ends.
  durationSeconds: Int!
  # ID of challenge.
  id: ID!
  # User who owns this challenge. The challenge will appear on their channel.
  ownedBy: User
  # Amount of milliseconds before the challenge times out.
  # 0 when the challenge has timed out.
  remainingDurationMilliseconds: Int!
  # The authenticated user's relationship with this challenge.
  # Main use case is to connect the user to a challenge to allow bit contributions.
  # Null if un-authenticated user is making this query.
  self: ChannelChallengeSelfEdge
  # The status of the challenge.
  status: ChannelChallengeStatus!
  # Title of the challenge.
  title: String!
  # Time when challenge was updated.
  updatedAt: Time!
}

# ManuallyTriggerDrop has fields required to update a campaign summary.
input ManuallyTriggerDropInput {
  # The id of the campaign that includes the drop to trigger.
  campaignID: ID!
  # The id of the drop to trigger.
  dropID: ID!
  # This is the Organization ID (RBAC) to determine access / ownership of the campaign and attached drops.
  ownerID: ID!
}

# ManuallyTriggerDropPayload returns the result of the creation/update.
type ManuallyTriggerDropPayload {
  # A mapped error returned by the drops management service.
  error: DropsError
  # Returns a list of channels the drop was tried to be triggered on and the trigger restult.
  triggerResults: [TriggerResult!]
}

# The possible return status of a drop trigger try on a channel.
enum ManuallyTriggerDropResultStatus {
  # Returned if the trigger try was successful.
  SUCCESS
  # Returned if the streamer is not eligible to have the drop triggered on it.
  VERIFICATION_FAILURE
  # Returned if the drop triggered returned an error for given channel.
  ERROR
}

# Drop manually triggered.
type ManualTriggerBasedDrop implements DropType {
  # The rewards for this drop and how often those rewards can be awarded.
  benefitEdges: [DropBenefitEdge!]
  # The campaign this drop belongs to.
  campaign: DropCampaign!
  # Amount of time the viewer has to claim the drop after the rule is completed.
  claimDurationSeconds: Int!
  # The time this drop becomes unavailable.
  endAt: Time!
  # A unique identifier.
  id: ID!
  # The name of this drop.
  name: String!
  # The time this drop becomes available.
  startAt: Time!
}

# Input for readAllCreatorNotifications mutation.
input MarkAllCreatorNotificationsAsReadInput {
  # The ID of the user performing the reading.
  userID: ID!
}

# The result of a readAllCreatorNotifications mutation.
type MarkAllCreatorNotificationsAsReadPayload {
  # Whether the mutation succeeded.
  hasSucceeded: Boolean
}

# Input for readAllViewerNotifications mutation.
input MarkAllViewerNotificationsAsReadInput {
  # The ID of the user performing the reading.
  userID: ID!
}

# The result of a readAllViewerNotifications mutation.
type MarkAllViewerNotificationsAsReadPayload {
  # Whether the mutation succeeded.
  hasSucceeded: Boolean
}

# Revealed Metric types that the client can filter on.
enum MemberMetricsRevealedParams {
  # Return all members.
  NONE
  # Return all `StatsRevealed` members.
  STATS
  # Return all `RevenueRevealed` members.
  REVENUE
  # Return users with both `StatsRevealed` and `RevenueRevealed`.
  STATS_AND_REVENUE
}

# A message from a user.
type Message {
  # The text and emoticon content of a message.
  content: MessageContent!
  # Time the message was deleted or purged. Null if the message is not deleted.
  deletedAt: Time
  # UUID of the message.
  id: ID!
  # The message of the parent if this message is a reply.
  parentMessage: Message
  # Replies to this message.
  replies: MessageReplyConnection
  # The user that sent the message.
  sender: User
  # Time the message was sent.
  sentAt: Time!
}

# MessageBody is a way of encoding emote annotated text.  The original text is included as content and the
# parsed emotes are included which indicate the start and end indexes they should replace.
type MessageBody {
  # The text content of the body.
  content: String
  # Collection of rune indexed emotes to be replaced clientside.
  emotes: [EmbeddedEmote]
}

# The content of a user's message to a channel's chat.
type MessageContent {
  # Parsed list of fragments in the message, include emotes, mentions, and plaintext.
  fragments: [MessageFragment!]!
  # String representation of the user message.
  text: String!
}

# One parsed part of a message, which may be an emote, mention, or plaintext.
type MessageFragment {
  # Contains an emote or a mentioned user depending on the text of the fragment.
  content: FragmentContent
  # Plaintext representation of the fragment.
  text: String!
}

# A list of messages.
type MessageReplyConnection {
  # Nodes is the list of replies to a message.
  nodes: [Message!]!
  # The total number of replies to a message.
  totalCount: Int!
}

# Milestone is a construct is used within a tournament. For a given threshold, when the user
# cheers at or past this amount, they are able to claim a reward for cheering at this level.
# Rewards can be fulfilled by different platforms.
# Types of milestones:
# - **Global milestone**: for a given threshold, this milestone is reached when cheers from all
#   users on the channel is greater than or equal to the threshold.
#   This unlocks a reward for all users who have cheered.
# - **Individual milestone**: for a given threshold, this milestone is reached when an individual
#   user's total cheers in the channel is greater than or equal to the threshold.
#   This unlocks a reward for the individual user who cheered.
# - **Team milestone**: for a given threshold, this milestone is reached when an individual cheers
#   for a specific team in total is greater than or equal to the threshold.
#   This unlocks a reward for the individual user who cheered.
#
# NOTE: Should have been named CheeringTournamentMilestone.
type Milestone {
  # End date for when a milestone is no longer active.
  endDate: String! @deprecated
  # GraphQL ID of the milestone.
  id: ID! @deprecated
  # Whether the milestone is for prime users only.
  isPrimeOnly: Boolean! @deprecated
  # The type of milestone this is for. e.g INDIVIDUAL or GLOBAL.
  objectiveTag: String! @deprecated
  # Threshold that needs to be cheered by an individual to claim reward.
  participationThreshold: Int! @deprecated
  # The subs that this milestoneâ€™s completion requires.
  requiredSubscriptions: [SubscriptionProduct!] @deprecated
  # The rewards associated with milestones.
  rewards: [TournamentReward!]! @deprecated
  # Start date for when a milestone is active.
  startDate: String! @deprecated
  # Threshold that needs to be cheered to claim reward.
  threshold: Int! @deprecated
}

# MobileAdIdentityInput contains mobile device information.
input MobileAdIdentityInput {
  # deviceInfo is a MobileAdDeviceInfo contains a certain number of attributes required by TIFA.
  deviceInfo: MobileDeviceInfo!
  # lmt is limit ad tracking signal read from mobile device.
  lmt: Boolean!
  # mAID is the mobile ad identifier.
  mAID: ID!
  # platform is an enum that describes the device platform.
  platform: AdPlatform!
  # userAgent is a string sent by mobile clients.
  userAgent: String!
}

# MobileDeviceInfo contains attributes required by TIFA.
input MobileDeviceInfo {
  # Hardware brand name, ex. samsung.
  make: String!
  # Hardware model, ex: "Galaxy S10".
  model: String!
  # Hardware os: ex. "Android".
  os: String!
  # Os version number.
  osVersion: String!
}

# MobileView holds the view configuration of an extension if mobile is supported.
type MobileView implements ExtensionView {
  # Relative path of the HTML file to load for this view, used by devsite to specify the layout of assets.
  viewerPath: String!
  # The URL which should be loaded in for the extension.
  viewerURL: String!
}

# MobileViewInput holds the view configuration of an extension if mobile is supported.
input MobileViewInput {
  # Relative path of the HTML file to load for this view.
  viewerPath: String!
}

# Paginated list of moderators of a channel.
type ModConnection {
  # The elements of the list.
  edges: [ModEdge!]!
  # Information about this page.
  pageInfo: PageInfo!
}

# Element in a list of moderators of a channel.
type ModEdge {
  # Opaque cursor describing this edge's position in the paginated list.
  cursor: Cursor!
  # Timestamp of when the moderator status was granted.
  grantedAt: Time!
  # Whether the moderator is connected to the channel's chat.
  isActive: Boolean
  # The user that is a moderator.
  node: User!
}

# ModerationAction represents the recorded actions a channel moderator takes on a channel.
enum ModerationAction {
  # Moderator changes Automod settings levels.
  AUTOMOD_LEVEL_CHANGE
  # Moderator allows message caught by Automod.
  ALLOW_MESSAGE
  # Moderator approves unban request.
  APPROVE_UNBAN_REQUEST
  # Moderator bans a user.
  BAN_USER
  # Moderator adds terms to Automod blocked list.
  BLOCKED_TERM_ADD
  # Moderator removes terms to Automod blocked list.
  BLOCKED_TERM_REMOVE
  # Moderator clears chat.
  CHAT_CLEAR
  # Moderator creates a mod comment about a user.
  COMMENT
  # Moderator deletes a chat message.
  DELETE_MESSAGE
  # Moderator denies message caught by Automod.
  DENY_MESSAGE
  # Moderator denies unban request.
  DENY_UNBAN_REQUEST
  # Moderator turns emotes only chat off.
  EMOTES_ONLY_OFF
  # Moderator turns chat to motes only.
  EMOTES_ONLY_ON
  # Moderator turns followers only chat off.
  FOLLOWERS_ONLY_OFF
  # Moderator turns chat to followers only.
  FOLLOWERS_ONLY_ON
  # Moderator hosts another channel.
  HOST
  # Default Action.
  INVALID_ACTION
  # Moderator unmods a user.
  UNMOD_USER
  # Moderator mods a user.
  MOD_USER
  # Moderator adds terms to Automod permitted list.
  PERMITTED_TERM_ADD
  # Moderator removes terms to Automod permitted list.
  PERMITTED_TERM_REMOVE
  # Moderator raids another channel.
  RAID
  # Moderator turns slow off in chat.
  SLOW_OFF
  # Moderator slows chat.
  SLOW_ON
  # Moderator turns subscribers only chat off.
  SUBS_ONLY_OFF
  # Moderator turns chat to subscribers only.
  SUBS_ONLY_ON
  # Moderator timeouts a user.
  TIMEOUT_USER
  # Moderator unbans a user.
  UNBAN_USER
  # Moderator unhosts another channel.
  UNHOST
  # Moderator turns unique only chat off.
  UNIQUE_OFF
  # Moderator turns unique only chat on.
  UNIQUE_ON
  # Moderator unraids another channel.
  UNRAID
  # Moderator untimeouts a user.
  UNTIMEOUT_USER
  # Moderator makes user not vip.
  UNVIP_USER
  # Moderator makes user vip.
  VIP_USER
}

# An interface to query subsets of the moderation logs information for a given channel.
type ModerationLogs {
  # The moderation actions that have been take in the given channel.
  actions(
    first: Int = 100
    after: Cursor
    order: SortOrder = DESC
  ): ChannelModerationActionConnection
}

# An interface to query subsets of the moderation logs information for a given channel.
type ModLogs {
  # The comments left by moderators on a specified user on the given channel.
  comments(
    targetID: ID!
    after: Cursor
    first: Int = 100
    order: SortOrder = DESC
  ): ModLogsCommentConnection
  # The chat history for an specified user on a given channel.
  messagesBySender(
    senderID: ID!
    first: Int = 100
    after: Cursor
    order: SortOrder = DESC
    includeMessageCount: Boolean = true
    includeTargetedActions: Boolean = true
    includeAutoModCaughtMessages: Boolean = false
  ): ModLogsMessageConnection
  # The chat moderation history on a specified user on the given channel.
  targetedModActions(
    targetID: ID!
    actionType: ModLogsAction!
  ): ModLogsTargetedModActionsConnection
}

# ModLogsAccess defines the access level of a channel role to the channel's moderator logs.
type ModLogsAccess {
  # The access level to moderator logs.
  accessLevel: ModLogsAccessLevel!
  # The user role.
  channelRole: ChannelUserRole!
}

# Access levels to moderator logs.
enum ModLogsAccessLevel {
  # User cannot read moderator logs or create new entries.
  NONE
  # User can read moderator log entries.
  READ
  # User can read and create moderator log entries.
  WRITE
}

# ModLogsAction represents the recorded actions a channel moderator takes on a channel.
enum ModLogsAction {
  # Default Action.
  INVALID_ACTION
  # Channel Mod chat bans a user.
  BAN_USER
  # Channel Mod chat timeouts a user.
  TIMEOUT_USER
  # Channel Mod chat unbans a user.
  UNBAN_USER
  # Channel Mod sets chat mode.
  SET_CHANNEL_MODE
  # Channel Mod changes.
  CHANGE_CHANNEL_RULES
  # Channel Mod approves an automod caught message.
  ALLOW_MESSAGE
  # Channel Mod denies an automod caught message.
  DENY_MESSAGE
  # Channel Mod updates mod terms.
  UPDATE_MODERATED_TERMS
  # Channel Mod creates a mod comment about a user.
  COMMENT
  # Channel Mod chat untimeouts a user.
  UNTIMEOUT_USER
}

# ModLogsCommentsEntry defines an entry of a user's moderation history on a channel.
type ModLogsComment {
  # Author is the moderator that created the comment.
  author: User
  # Channel is where the moderator comment was created.
  channel: User
  # Details about the moderator comment.
  details: ModLogsCommentDetails
  # UUID of the moderator comment.
  id: ID!
  # Target is the target user of the moderator comment.
  target: User
  # Timestamp when comment was created.
  timestamp: Time!
}

# Paginated list of moderator comments on a user in a channel.
type ModLogsCommentConnection {
  # The elements of the list.
  edges: [ModLogsCommentEdge!]
  # Information about this page of mod logs.
  pageInfo: PageInfo!
}

# ModLogsCommentDetails contains the details of a moderator comment.
type ModLogsCommentDetails {
  # Body of the comment.
  text: String
}

# Element in a list of moderator comments on a user in a channel.
type ModLogsCommentEdge {
  # Opaque cursor describing this edge's position in the paginated list.
  cursor: Cursor!
  # A moderator comment on a user in a channel.
  node: ModLogsComment
}

# A message sent from a user to a room.
type ModLogsMessage {
  # The text and emoticon content of a message.
  content: ModLogsMessageContent!
  # UUID of the message.
  id: ID!
  # The user that sent the message.
  sender: User
  # Time the message was sent.
  sentAt: Time!
}

# Paginated list of messages from a single sender in a channel.
type ModLogsMessageConnection {
  # The elements of the list.
  edges: [ModLogsMessageEdge!]!
  # The partial count of messages (up to 1000).
  # Empty if includeMessageCount was not set when the query was requested.
  messageCount: Int
  # Information about this page.
  pageInfo: PageInfo!
}

# The content of a user's message to a room.
type ModLogsMessageContent {
  # Parsed list of fragments in the message, include emotes, mentions, and plaintext.
  fragments: [ModLogsMessageFragment!]!
  # String representation of the user message.
  text: String!
}

# Element in a list of messages.
type ModLogsMessageEdge {
  # Opaque cursor describing this edge's position in the paginated list.
  cursor: Cursor!
  # The message or targeted moderation action.
  node: ModLogsMessageResult
}

# One parsed part of a message, which may be an emote, mention, or plaintext.
type ModLogsMessageFragment {
  # Contains an emote or a mentioned user depending on the text of the fragment.
  content: FragmentContent
  # Plaintext representation of the fragment.
  text: String!
}

# ModLogsMessageResult defines the types of entries that appear as mod log
# messages: Mod Logs (Chat) Messages and Targeted Mod Actions.
union ModLogsMessageResult =
    AutoModCaughtMessage
  | ModLogsMessage
  | ModLogsTargetedModActionsEntry
# Paginated list of mod logs of a user on a channel.
type ModLogsTargetedModActionsConnection {
  # The partial count of targeted mod actions (bans or timeouts), up to 100.
  # Does not count undo actions (unbans or untimeouts).
  actionCount: Int!
  # The elements of the list.
  edges: [ModLogsTargetedModActionsEdge!]
  # Information about this page of mod logs.
  pageInfo: PageInfo!
}

# Element in a list of mod logs of a user on a channel.
type ModLogsTargetedModActionsEdge {
  # Opaque cursor describing this edge's position in the paginated list.
  cursor: Cursor!
  # A mod log of the user.
  node: ModLogsTargetedModActionsEntry
}

# ModLogsTargetedModActionsEntry defines an entry of a user's moderation history on a channel.
type ModLogsTargetedModActionsEntry {
  # Action is the mod action of the entry.
  action: ModLogsAction!
  # Channel is where the mod action was taken.
  channel: User
  # Details about the mod action.
  details: TargetedModActionDetails
  # The UUID of the entry.
  id: ID!
  # Target is the target user of the mod action.
  target: User
  # Timestamp when entry was created.
  timestamp: Time!
  # User is the mod that created the action.
  user: User
}

# ModUserError contains details about a client error that occurred.
type ModUserError {
  # The enum indicating what error has occurred.
  code: ModUserErrorCode!
}

# ModUserErrorCode defines a client error that occurred while adding a moderator.
enum ModUserErrorCode {
  # The requesting user does not have permission to add a moderator in this channel.
  FORBIDDEN
  # The target user does not exist or has a suspended account.
  TARGET_NOT_FOUND
  # The channel does not exist.
  CHANNEL_NOT_FOUND
  # The target user is banned or timed out in this channel.
  TARGET_IS_CHAT_BANNED
  # The target user is already a moderator.
  TARGET_ALREADY_MOD
}

# ModUserInput contains the parameters to add a user as a moderator to a channel.
input ModUserInput {
  # The channel that the user will be added as a moderator to.
  channelID: ID!
  # The ID of the user that will be added as a moderator.
  # Either targetID or targetLogin must be provided.
  targetID: ID
  # The login of the user that will be added as a moderator.
  # Either targetID or targetLogin must be provided.
  targetLogin: String
}

# ModUserPayload is the response when adding a user as a moderator.
type ModUserPayload {
  # The channel that the user is added as a moderator to.
  channel: User
  # The client error that has occurred.
  # Null if the operation is successful.
  error: ModUserError
  # The user that is added as a moderator.
  target: User
}

# ModViewNewsfeedEntry is an entry that displays content for the Mod View page's "What's New" feed.
type ModViewNewsfeedEntry {
  # content is localized text content for the changelog entry.
  content: String!
  # iconURL is the url for the entry's icon image.
  iconURL: String
  # id is a unique human readable slug for the entry e.g. "squad-stream".
  id: ID!
  # linkText is the text that the linkURL should display.
  linkText: String
  # linkURL is an optional link for more content for this changelog entry.
  linkURL: String
  # position is where entry should be located within changelog entries of the same date.
  position: Int!
  # publishedAt is the timestamp that the changelog entry was published.
  publishedAt: Time
  # title is the localized title of the changelog entry.
  title: String!
}

# Settings for Mod View Page.
type ModViewSettings {
  # Date that tuorial was SEEN (nullable when tutorial is dismissed or unseen).
  tutorialSeenAt: Time
  # Setting to store whether the user has completed the mod view tutorial.
  tutorialState: TutorialState
}

# Data containing a layout definition for the
# Mosaic algorithm. Should only be parsed or modified by Mosaic.
scalar MosaicData

# Movie metadata.
type MovieDetails {
  # Total length of the content.
  durationSeconds: Int
}

# A multiplayer ad offer is an ad offer.
type MultiplayerAdOffer {
  # The duration of the ad in seconds.
  adDurationSeconds: Int!
  # The name of the brand associated with the ad.
  brandName: String
  # The message to be display to the broadcaster.
  broadcasterMessage: String
  # How much preroll free time will be credited to the creator for running this ad offer.
  creditDurationSeconds: Int
  # When the offer expires.
  expiresAt: Time!
  # The offer's unique identifier.
  id: ID!
  # If offer has reward, the max rate for reward. (e.g. vote per bits for polling).
  rewardsMaxRate: Float
  # If offer has reward, the min rate for reward. (e.g. vote per bits for polling).
  rewardsMinRate: Float
}

# Multi-view content attribute(s) are used to augment the multi-view experience.
# they are used for filterings and groupings of chanlets to help viewers find content that they are interested in.
type MultiviewContentAttribute {
  # childIDs is an optional list of child content attribute ids.
  childIDs: [ID!]
  # Time when this content attribute is created.
  createdAt: Time
  # id is a unique identifier generated on the server side.
  id: ID!
  # URL to the image (icon) of the content attribute.
  imageURL: String
  # key is a grouping identifier for content attributes of the same type.
  key: String!
  # name is a human-readable string of the content attribute type.
  name: String!
  # ownerChannel is the channel that this content attribute is created under.
  ownerChannel: Channel
  # parentID is an optional pointer to specify the parent attribute.
  parentID: ID
  # parentKey is an optional pointer to specifiy the key of the parent attribute.
  parentKey: String
  # Time when this content attribute is last modified.
  updatedAt: Time
  # value is the human-readble value of the attribute value.
  value: String!
  # valueShortName is an optional abbreviation of value.
  valueShortName: String
}

# Contains all information to create a new content attribute.
input MultiviewContentAttributeParams {
  # Optional list of child content attribute ids.
  childIDs: [ID!]
  # Unique identifier.
  id: ID
  # Optional an URL to the icon of this content attribute.
  imageURL: String
  # Indicates the type of the attribute.
  key: String!
  # Human-readable name of the attribute.
  name: String!
  # The channel that the content attribute is created under.
  ownerChannelID: ID
  # Optional pointer to a parent content attribute instance.
  parentID: ID
  # Optional pointer to a parent content attribute key.
  parentKey: String
  # value of the attribute.
  value: String!
  # Optional abbreviation of value.
  valueShortName: String
}

# Operations to update data in the Twitch API.
type Mutation {
  # acceptFriendRequest accepts a friend request from the target user to the
  # authenticated user, creating a new Friend relationship.
  acceptFriendRequest(
    input: AcceptFriendRequestInput!
  ): AcceptFriendRequestPayload
  # AcceptOrganizationInvite accepts an invite to an organization and the user is added as member to that organization.
  acceptOrganizationInvite(
    input: AcceptOrganizationInviteInput!
  ): AcceptOrganizationInvitePayload
  # Accept program agreement during payout onboarding.
  acceptProgramAgreement(
    input: AcceptProgramAgreementInput!
  ): AcceptProgramAgreementPayload
  # acceptSquadStreamInvitation allows a user that has recieved a squad stream invitation to accept and join
  # the squad stream.
  acceptSquadStreamInvitation(
    input: AcceptSquadStreamInvitationInput!
  ): AcceptSquadStreamInvitationPayload
  # Acknowledge the result of a Prediction. Only the user who made the Prediction can acknowledge the result.
  # This should be triggered automatically when the result of a Prediction is displayed on screen, either from a
  # User Notice or by viewing the Channel Points panel. Because this has the potential to trigger a thundering herd, as
  # every participant in a Prediction Event will see the results at the same time, clients should automatically jitter
  # this call by waiting a random duration between 0-60 seconds before making this mutation.
  acknowledgePredictionResult(
    input: AcknowledgePredictionResultInput!
  ): AcknowledgePredictionResultPayload
  # acknowledgeSubscriptionState allow to apply Acknowledged status to the provided subscription.
  acknowledgeSubscriptionState(
    input: AcknowledgeSubscriptionStateInput!
  ): AcknowledgeSubscriptionStatePayload
  # acknowledgeUnbanRequest allows a user to acknowledge their unban request has been approved, and can now
  # rejoin a channel's chat after being unbanned.
  acknowledgeUnbanRequest(
    input: AcknowledgeUnbanRequestInput!
  ): AcknowledgeUnbanRequestPayload
  # Activate an extension which has been installed on a channel.
  activateExtension(input: ActivateExtensionInput!): ActivateExtensionPayload
    @deprecated(reason: "Should use applyExtensionActivations instead")
  # Adds to a user's list of channelIDs to autohost.
  addAutohostChannels(
    input: AddAutohostChannelsInput!
  ): AddAutohostChannelsPayload
  # addBrowserPushSubscription adds a browser push subscription for receiving browser (desktop) push notifications.
  # The client must retrieve the input fields from the browser's push notification API. Client's will
  # call this when the user opts-in. A browser push subscription is tied to a user's browser (device).
  # Twitch will use these push subscriptions to send browser push notifications.
  #
  # Spec: https://www.w3.org/TR/push-api/#push-subscription.
  addBrowserPushSubscription(
    input: AddBrowserPushSubscriptionInput!
  ): AddBrowserPushSubscriptionPayload
  # Adds a blocked term to a channel.
  addChannelBlockedTerm(
    input: AddChannelBlockedTermInput!
  ): AddChannelBlockedTermPayload
  # Adds a permitted term to a channel.
  addChannelPermittedTerm(
    input: AddChannelPermittedTermInput!
  ): AddChannelPermittedTermPayload
  # addCollectionItem adds an item to a collection.
  addCollectionItem(input: AddCollectionItemInput!): AddCollectionItemPayload
  # Add CompetitionPhase to a competition.
  addCompetitionPhase(
    input: AddCompetitionPhaseInput!
  ): AddCompetitionPhasePayload
  # Add CompetitionPlayer to a competition.
  addCompetitionPlayer(
    input: AddCompetitionPlayerInput!
  ): AddCompetitionPlayerPayload
  # Add CompetitionTeam to a competition.
  addCompetitionTeam(input: AddCompetitionTeamInput!): AddCompetitionTeamPayload
  # addDeviceToken associates a new push notification token to the given user.
  addDeviceToken(input: AddDeviceTokenInput!): AddDeviceTokenPayload
  # addDropToCampaign allows an organization to add a new drop record to an existing campaign.
  addDropToCampaign(input: AddDropToCampaignInput!): AddDropToCampaignPayload
  # Grant a user the editor status for a given channel.
  addEditor(input: AddEditorInput!): AddEditorPayload
  # Register a radio content play start.
  addRadioRecentlyPlayed(
    input: AddRadioRecentlyPlayedInput!
  ): AddRadioRecentlyPlayedPayload
  # addReaction allows a user to create a reaction for any reactable item in a feed.
  addReaction(input: AddReactionInput!): AddReactionPayload @deprecated
  # addRecommendationFeedback allows a user to add feedback about a recommendation they've received.
  addRecommendationFeedback(
    input: AddRecommendationFeedbackInput!
  ): AddRecommendationFeedbackPayload
  # Adds a user to stream on behalf of broadcaster.
  addStreamAuthorizedUser(
    input: AddStreamAuthorizedUserInput!
  ): AddStreamAuthorizedUserPayload
  # Allocates product keys that a broadcaster may need to complete the bounty.
  allocateKeysForBounty(
    input: AllocateKeysForBountyInput!
  ): AllocateKeysForBountyPayload
  # Allows a message rejected on a channel chat.
  allowRejectedChatMessage(
    input: AllowRejectedChatMessageInput!
  ): AllowRejectedChatMessagePayload
  # Allows a cheer rejected on a channel chat.
  allowRejectedCheer(
    input: AllowRejectedCheerInput!
  ): AllowRejectedCheerPayload
    @deprecated(reason: "logic handled by allowRejectedChatMessage")
  # Apply activation state to a subset of installed extensions. In order to deactivate an installed extension,
  # simply pass a null value in the anchor.
  applyExtensionActivations(
    input: ApplyExtensionActivationsInput!
  ): ApplyExtensionActivationsPayload
  # Approve a request to be unbanned from a channel-banned user.
  approveUnbanRequest(
    input: ApproveUnbanRequestInput!
  ): ApproveUnbanRequestPayload
  # Archives a chanlet to remove the chanlet from the parent channel.
  archiveChanlet(input: ArchiveChanletInput!): ArchiveChanletPayload
  # archiveCommunityPointsCommunityGoal archives a Community Points Community Goal.
  archiveCommunityPointsCommunityGoal(
    input: ArchiveCommunityPointsCommunityGoalInput!
  ): ArchiveCommunityPointsCommunityGoalPayload
  # Archive a poll with the given poll id.
  archivePoll(input: ArchivePollInput!): ArchivePollPayload
  # Archive the current poll in a channel.
  archivePollInChannel(
    input: ArchivePollInChannelInput!
  ): ArchivePollInChannelPayload
  # Assign an emote to a bits tier.
  assignEmoteToBitsTier(
    input: AssignEmoteToBitsTierInput!
  ): AssignEmoteToBitsTierPayload
  # Assign an emote to a subscription product.
  assignEmoteToSubscriptionProduct(
    input: AssignEmoteToSubscriptionProductInput!
  ): AssignEmoteToSubscriptionProductPayload
  # Assign a billing manager to an extension.
  # The billing manager is the organization's Owner or member with Billing_Manager role that is ready to receive
  # payments for the monetized extension within an organization.
  assignExtensionBillingManager(
    input: AssignExtensionBillingManagerInput!
  ): AssignExtensionBillingManagerPayload
  # Bans a user from chat room permanently or for an specified period of time.
  banUserFromChatRoom(
    input: BanUserFromChatRoomInput!
  ): BanUserFromChatRoomPayload
  # banVideoCommenter bans a user from commenting on a video.
  banVideoCommenter(input: BanVideoCommenterInput!): BanVideoCommenterPayload
  # beginUseBitsInExtension starts a bits transaction in an extension.
  beginUseBitsInExtension(
    input: BeginUseBitsInExtensionInput!
  ): BeginUseBitsInExtensionPayload
  # Blocks target user from communicating with the current user.
  blockUser(input: BlockUserInput!): BlockUserPayload
  # Approve a list of unban requests on a channel.
  bulkApproveUnbanRequest(
    input: BulkApproveUnbanRequestInput!
  ): BulkApproveUnbanRequestPayload
  # Deny a list of unban requests on a channel.
  bulkDenyUnbanRequest(
    input: BulkDenyUnbanRequestInput!
  ): BulkDenyUnbanRequestPayload
  # Cancel all active boosts on a channel.
  cancelActiveBoostOrders(
    input: CancelActiveBoostOrdersInput!
  ): CancelActiveBoostOrdersPayload
  # cancelBounty allows a user to cancel a claimed bounty.
  # If the user has not met the requirements to cancel the bounty, an error will be returned.
  cancelBounty(input: CancelBountyInput!): CancelBountyPayload
  # cancelFriendRequest destroys a friend request relationship from the authenticated user to the target user.
  cancelFriendRequest(
    input: CancelFriendRequestInput!
  ): CancelFriendRequestPayload
  # Cancel a current payout onboarding workflow.
  cancelPayoutOnboardingWorkflow(
    input: CancelPayoutOnboardingWorkflowInput!
  ): CancelPayoutOnboardingWorkflowPayload
  # Cancel a Prediction Event.
  cancelPredictionEvent(
    input: CancelPredictionEventInput!
  ): CancelPredictionEventPayload
  # Cancel a raid.
  cancelRaid(input: CancelRaidInput!): CancelRaidPayload
  # cancelSubscriptionGift allows the current user to cancel their gifted subscription to a channel.
  cancelSubscriptionGift(
    input: CancelSubscriptionGiftInput!
  ): CancelSubscriptionGiftPayload
  # cancelUnbanRequest allows the user to cancel their provided unban request.
  cancelUnbanRequest(input: CancelUnbanRequestInput!): CancelUnbanRequestPayload
  # changeUsername allows a user to update their username(login).
  changeUsername(input: ChangeUsernameInput!): ChangeUsernamePayload
  # claimBounty allows a user to claim a bounty from a campaign (e.g. Stream a Game Campaign).
  # If the user has not met the requirements to claim it, an error will be returned.
  claimBounty(input: ClaimBountyInput!): ClaimBountyPayload
  # claimCommunityPoints allows a user to claim community points that they have available in a channel.
  # If the user does not have a claim available, an error will be returned.
  claimCommunityPoints(
    input: ClaimCommunityPointsInput!
  ): ClaimCommunityPointsPayload
  # claimDropRewards allows a user to attempt to claim their rewards from a Drops 2.0 drop.
  claimDropRewards(input: ClaimDropRewardsInput!): ClaimDropRewardsPayload
  # claimPrimeOffer allows a user to create their entitlement to the given offer/content.
  claimPrimeOffer(input: ClaimPrimeOfferInput!): ClaimPrimeOfferPayload
  # clearUnreadFriendRequests marks all friend requests for the authenticated user as read.
  clearUnreadFriendRequests: ClearUnreadFriendRequestsPayload
  # cloneExtensionDiscoveryData copies the discovery data of an extension from one version to another.
  cloneExtensionDiscoveryData(
    input: CloneExtensionDiscoveryDataInput!
  ): CloneExtensionDiscoveryDataPayload
  # cloneExtensionManifest creates a new version of an extension that is a clone of a previous version.
  cloneExtensionManifest(
    input: CloneExtensionManifestInput!
  ): CloneExtensionManifestPayload
  # connectAdIdentity creates an Amazon ad identity for the authenticated user.
  connectAdIdentity(input: ConnectAdIdentityInput!): ConnectAdIdentityPayload
  # contributeCommunityPointsCommunityGoal contributes Community Points towards a Community Goal.
  contributeCommunityPointsCommunityGoal(
    input: ContributeCommunityPointsCommunityGoalInput!
  ): ContributeCommunityPointsCommunityGoalPayload
  # contributeToChallenge allows the user to contribute Bits towards a Challenge.
  contributeToChallenge(
    input: ContributeToChallengeInput!
  ): ContributeToChallengePayload
  # createArchivedEmote creates an archived emote object, which is not associated
  # with any products, and associates that emote with a set of image assets.
  createArchivedEmote(
    input: CreateArchivedEmoteInput!
  ): CreateArchivedEmotePayload
  # createBadgeFlair creates a custom badge flair asset for a creator's channel and specified tier.
  createBadgeFlair(input: CreateBadgeFlairInput!): CreateBadgeFlairPayload
  # createBitsChallengeConditionForExtension creates a Bits condition on behalf of a user by an extension.
  createBitsChallengeConditionForExtension(
    input: CreateBitsChallengeConditionForExtensionInput!
  ): CreateBitsChallengeConditionForExtensionPayload @deprecated
  # createBitsChallengeConditionParticipantForExtension creates a Bits condition
  # participant on behalf of a user by an extension.
  createBitsChallengeConditionParticipantForExtension(
    input: CreateBitsChallengeConditionParticipantForExtensionInput!
  ): CreateBitsChallengeConditionParticipantForExtensionPayload @deprecated
  # createBountyCampaign creates a campaign for Bounty Board.
  createBountyCampaign(
    input: CreateBountyCampaignInput!
  ): CreateBountyCampaignPayload
  # createBountyCampaignUploadConfig creates a upload configuration for assets for bounty campaigns.
  createBountyCampaignUploadConfig(
    input: CreateBountyCampaignUploadConfigInput!
  ): CreateBountyCampaignUploadConfigPayload
  # createCelebration creates a new celebration for a channel.
  createCelebration(input: CreateCelebrationInput!): CreateCelebrationPayload
  # createChanlet creates a new chanlet for a Channel.
  createChanlet(input: CreateChanletInput!): CreateChanletPayload
  # createClip creates a new clip with the authenticated user as the curator.
  createClip(input: CreateClipInput!): CreateClipPayload
  # createCollection creates a collection with a provided collection name.
  createCollection(input: CreateCollectionInput!): CreateCollectionPayload
  # createCommunityPointsCommunityGoal creates a Community Points Community Goal.
  createCommunityPointsCommunityGoal(
    input: CreateCommunityPointsCommunityGoalInput!
  ): CreateCommunityPointsCommunityGoalPayload
  # Create a custom Community Points reward in a channel.
  createCommunityPointsCustomReward(
    input: CreateCommunityPointsCustomRewardInput!
  ): CreateCommunityPointsCustomRewardPayload
  # Generate image upload information (URL and upload ID) for uploading a Community Points image.
  # Can upoload a new Community Points icon, an automatic reward icon, or a custom reward icon.
  createCommunityPointsImageUploadInfo(
    input: CreateCommunityPointsImageUploadInfoInput!
  ): CreateCommunityPointsImageUploadInfoPayload
  # Create a Competition.
  createCompetition(input: CreateCompetitionInput!): CreateCompetitionPayload
  # createContentTags creates the tags specified and associates it with the piece of content specified.
  createContentTags(input: CreateContentTagsInput!): CreateContentTagsPayload
  # createCrowdChant creates a crowd chant on a channel.
  createCrowdChant(input: CreateCrowdChantInput!): CreateCrowdChantPayload
  # createDropBenefit creates a benefit that can be used within a drop campaign.
  createDropBenefit(input: CreateDropBenefitInput!): CreateDropBenefitPayload
  # createDropCampaign creates a Drop Campaign owned by an organization.
  createDropCampaign(input: CreateDropCampaignInput!): CreateDropCampaignPayload
  # createDropImageUploadURL creates and returns a url to use on the client side to upload drops images.
  createDropImageUploadURL(
    input: CreateDropImageUploadURLInput!
  ): CreateDropImageUploadURLPayload @deprecated(reason: "use dropImageUpload")
  # createExtensionClient creates an extension with a provided name.
  createExtensionClient(
    input: CreateExtensionClientInput!
  ): CreateExtensionClientPayload
  # createExtensionImageUploadInfo creates and returns a url and uploadId to use
  # on the client side to upload extension logo, taskbar, discovery and screenshot images.
  createExtensionImageUploadInfo(
    input: CreateExtensionImageUploadInfoInput!
  ): CreateExtensionImageUploadInfoPayload
  # createExtensionZipUploadInfo creates and returns a url and uploadId to use on the client side to upload zip files.
  createExtensionZipUploadInfo(
    input: CreateExtensionZipUploadInfoInput!
  ): CreateExtensionZipUploadInfoPayload
  # createFriendRequest creates a friend request relationship between the authenticated user and the target user.
  createFriendRequest(
    input: CreateFriendRequestInput!
  ): CreateFriendRequestPayload
  # createFollowerEmote creates an emote object to be used only on the given channel, by followers of that channel.
  createFollowerEmote(
    input: CreateFollowerEmoteInput!
  ): CreateFollowerEmotePayload
  # createGameApplication creates an application request to add game to a certain organization.
  createGameApplication(
    input: CreateGameApplicationInput!
  ): CreateGameApplicationPayload
  # createGameBoxArtUploadURL returns a URL that can be used to upload the game
  # box art asset, for developers with access to the game box art image.
  createGameBoxArtUploadURL(
    input: CreateGameBoxArtUploadURLInput!
  ): CreateGameBoxArtUploadURLPayload
  # CreateLoyaltyBadge creates a new badge with these settings.
  createLoyaltyBadge(input: CreateLoyaltyBadgeInput!): CreateLoyaltyBadgePayload
  # createLoyaltyBadgeUploadConfig creates a config with URL to upload the badge image to.
  createLoyaltyBadgeUploadConfig(
    input: CreateLoyaltyBadgeUploadConfigInput!
  ): CreateLoyaltyBadgeUploadConfigPayload
  # createModeratorComment creates and returns a comment on the target user in the given channel.
  # Requester must be a moderator or higher in the channel.
  createModeratorComment(
    input: CreateModeratorCommentInput!
  ): CreateModeratorCommentPayload
  # Creates a new custom Mosaic layout with the specified properties for the current user.
  createDashboardViewMosaicLayout(
    input: CreateDashboardViewMosaicLayoutInput!
  ): CreateDashboardViewMosaicLayoutPayload
  # createMultiVideoHighlight creates a video of type Highlight with multi-segment support from an Archive type video.
  createMultiVideoHighlight(
    input: CreateMultiVideoHighlightInput!
  ): CreateMultiVideoHighlightPayload
  # createMultiviewContentAttributeImageUploadConfig creates and returns a upload
  # configuration for uploading and retrieving content attribute images.
  createMultiviewContentAttributeImageUploadConfig(
    input: CreateMultiviewContentAttributeImageUploadConfigInput!
  ): CreateMultiviewContentAttributeImageUploadConfigPayload
  # createMultiviewContentAttributes creates new content attributes with server assigned IDs.
  createMultiviewContentAttributes(
    input: CreateMultiviewContentAttributesInput!
  ): CreateMultiviewContentAttributesPayload
  # CreateOrganizationApplicaton creates a new Twitch Developer Organization
  # application with the authenticated user as the submitter.
  createOrganizationApplication(
    input: CreateOrganizationApplicationInput!
  ): CreateOrganizationApplicationPayload
  # CreateOrganizationInvite creates a new invitation to join an existing Twitch Developer Organization.
  createOrganizationInvite(
    input: CreateOrganizationInviteInput!
  ): CreateOrganizationInvitePayload
  # Creates JWT to be used in subsequent drops calls.
  createOrganizationJWT(
    input: CreateOrganizationJWTInput!
  ): CreateOrganizationJWTPayload
  # Adds a user to a developer organization.
  createOrganizationMember(
    input: CreateOrganizationMemberInput!
  ): CreateOrganizationMemberPayload
  # createPanel removes a panel.
  createPanel(input: CreatePanelInput!): CreatePanelPayload
  # Creates the url that a panel image gets uploaded to.
  createPanelImageUploadInfo(
    input: CreatePanelImageUploadInfoInput!
  ): CreatePanelImageUploadInfoPayload
  # createPartnershipApplication allows a user to create partnership application.
  createPartnershipApplication(
    input: CreatePartnershipApplicationInput!
  ): CreatePartnershipApplicationPayload
  # createPoll creates a poll.
  createPoll(input: CreatePollInput!): CreatePollPayload
  # createPost creates a new post.
  createPost(input: CreatePostInput!): CreatePostPayload @deprecated
  # Create a new Prediction Event.
  createPredictionEvent(
    input: CreatePredictionEventInput!
  ): CreatePredictionEventPayload
  # Create a raid.
  createRaid(input: CreateRaidInput!): CreateRaidPayload
  # createRewardedVideoToken creates a token used to initialize the truex client application.
  createRewardedVideoToken(
    input: CreateRewardedVideoTokenInput!
  ): CreateRewardedVideoTokenPayload
  # Creates a new chatroom.
  createRoom(input: CreateRoomInput!): CreateRoomPayload @deprecated
  # Create a new schedule.
  createSchedule(input: CreateScheduleInput!): CreateSchedulePayload
  # Create a new schedule segment.
  createScheduleSegment(
    input: CreateScheduleSegmentInput!
  ): CreateScheduleSegmentPayload
  # createSocialMedia creates new social media items for a Channel.
  createSocialMedia(input: CreateSocialMediaInput!): CreateSocialMediaPayload
  # Creates an invitation to a new or existing squad stream.
  createSquadStreamInvitation(
    input: CreateSquadStreamInvitationInput!
  ): CreateSquadStreamInvitationPayload
  # createStucco allows a user to create a stucco.
  createStucco(input: CreateStuccoInput!): CreateStuccoPayload
  # createStuccoPack allows the creation a new stucco pack for the channel.
  createStuccoPack(input: CreateStuccoPackInput!): CreateStuccoPackPayload
  # createUnbanRequest allows a channel-banned user to submit a request to channel moderators to be unbanned.
  createUnbanRequest(input: CreateUnbanRequestInput!): CreateUnbanRequestPayload
  # createVideoAppeal creates an appeal for the tracks that have been flagged for copyrighted music in the video.
  createVideoAppeal(input: CreateVideoAppealInput!): CreateVideoAppealPayload
  # createVideoBookmark creates a video bookmark.
  createVideoBookmark(
    input: CreateVideoBookmarkInput!
  ): CreateVideoBookmarkPayload
  # createVideoComment creates a video comment.
  createVideoComment(input: CreateVideoCommentInput!): CreateVideoCommentPayload
  # createVideoHighlight creates a video of type Highlight from an Archive type video.
  createVideoHighlight(
    input: CreateVideoHighlightInput!
  ): CreateVideoHighlightPayload
  # createVideoThumbnailUploadRequest creates a thumbnail upload request url.
  createVideoThumbnailUploadRequest(
    input: CreateVideoThumbnailUploadRequestInput!
  ): CreateVideoThumbnailUploadRequestPayload
  # Deactivate an extension which has been installed on a channel.
  deactivateExtension(
    input: DeactivateExtensionInput!
  ): DeactivateExtensionPayload
    @deprecated(reason: "Should use applyExtensionActivations instead")
  # DeclineOrganizationInvite declines an invite to an organization and the invitation is deleted.
  declineOrganizationInvite(
    input: DeclineOrganizationInviteInput!
  ): DeclineOrganizationInvitePayload
  # deleteAllChannelVideos deletes all videos for a given channel id for the authenticated users.
  deleteAllChannelVideos(
    input: DeleteAllChannelVideosInput
  ): DeleteAllChannelVideosPayload
  # Deletes a bits badge tier emoticon.
  deleteBitsBadgeTierEmoticon(
    input: DeleteBitsBadgeTierEmoticonInput!
  ): DeleteBitsBadgeTierEmoticonPayload
  # Deletes a celebration from the channel.
  deleteCelebration(input: DeleteCelebrationInput!): DeleteCelebrationPayload
  # Deletes a blocked term from a channel using the term ID.
  deleteChannelBlockedTermByID(
    input: DeleteChannelBlockedTermByIDInput!
  ): DeleteChannelBlockedTermByIDPayload
  # Deletes clips from a channel.
  deleteChannelClips(input: DeleteChannelClipsInput!): DeleteChannelClipsPayload
  # Deletes a permitted term from a channel using the term ID.
  deleteChannelPermittedTermByID(
    input: DeleteChannelPermittedTermByIDInput!
  ): DeleteChannelPermittedTermByIDPayload
  # deleteChatMessage deletes a single message from stream chat.
  deleteChatMessage(input: DeleteChatMessageInput!): DeleteChatMessagePayload
  # Deletes a custom cheermote tier from a channel.
  deleteCheermoteTier(
    input: DeleteCheermoteTierInput!
  ): DeleteCheermoteTierPayload
  # deleteClips allows a user to delete clips by slugs, video id, or broadcast id.
  # Only the slug and id can be accessed from the list of deleted clips.
  deleteClips(input: DeleteClipsInput!): DeleteClipsPayload
  # deleteCollection performs a delete on the collection with the provided ID.
  deleteCollection(input: DeleteCollectionInput!): DeleteCollectionPayload
  # deleteCommunityPointsCommunityGoal deletes a Community Points Community Goal.
  deleteCommunityPointsCommunityGoal(
    input: DeleteCommunityPointsCommunityGoalInput!
  ): DeleteCommunityPointsCommunityGoalPayload
  # Deletes a custom Community Points reward from a channel.
  deleteCommunityPointsCustomReward(
    input: DeleteCommunityPointsCustomRewardInput
  ): DeleteCommunityPointsCustomRewardPayload
  # Delete a Competition.
  deleteCompetition(input: DeleteCompetitionInput!): DeleteCompetitionPayload
  # deleteContentTags removes the tags specified and associates it with the piece of content specified.
  deleteContentTags(input: DeleteContentTagsInput!): DeleteContentTagsPayload
  # Deletes a layout with the specified id.
  deleteDashboardView(
    input: DeleteDashboardViewInput!
  ): DeleteDashboardViewPayload
  # Deletes the default payment method for a user.
  # Currently supports the Zuora (credit card) and Recurly (credit card, Pay-with-Amazon, PayPal) payment providers.
  deleteDefaultPaymentMethod(
    input: DeleteDefaultPaymentMethodInput!
  ): DeleteDefaultPaymentMethodPayload
  # deleteDeviceToken deletes a previously added device token by user and device token ID.
  deleteDeviceToken(input: DeleteDeviceTokenInput!): DeleteDeviceTokenPayload
  # deleteDrop allows a drop organization owner to delete a drop from their organization.
  deleteDrop(input: DeleteDropInput!): DeleteDropPayload
  # deleteDropCampaign allows a drop campaign owner to delete a drop campaign.
  deleteDropCampaign(input: DeleteDropCampaignInput!): DeleteDropCampaignPayload
  # Deletes a specified emote.
  deleteEmote(input: DeleteEmoteInput!): DeleteEmotePayload
  # deleteExtension allows an extension owner to delete an extension.
  deleteExtension(input: DeleteExtensionInput!): DeleteExtensionPayload
  # deleteExtensionImage delete extension image assets of the given urls.
  deleteExtensionImage(
    input: DeleteExtensionImageInput!
  ): DeleteExtensionImagePayload
  # Delete all secrets associated with an extension; this will immediately break all clients until
  # both a new secret rotate is executed and the clients manually refresh themselves. Only use this
  # if a secret is compromised and must be immediately removed from circulation.
  deleteExtensionSecrets(
    input: DeleteExtensionSecretsInput!
  ): DeleteExtensionSecretsPayload
  # Deletes a Loyalty Badge of a Channel.
  deleteLoyaltyBadge(input: DeleteLoyaltyBadgeInput!): DeleteLoyaltyBadgePayload
  # deleteModeratorComment deletes a moderator comment with the given ID.
  # The comment must have been created on the requester's channel.
  deleteModeratorComment(
    input: DeleteModeratorCommentInput!
  ): DeleteModeratorCommentPayload
  # deleteMultiviewContentAttributes deletes content attributes with the provided IDs.
  deleteMultiviewContentAttributes(
    input: DeleteMultiviewContentAttributesInput!
  ): DeleteMultiviewContentAttributesPayload
  # deleteNotification deletes an onsite notification of the authenticated user.
  deleteNotification(input: DeleteNotificationInput!): DeleteNotificationPayload
  # deletePanel removes a panel.
  deletePanel(input: DeletePanelInput!): DeletePanelPayload
  # deletePost deletes a old post.
  deletePost(input: DeletePostInput!): DeletePostPayload @deprecated
  # deleteRecommendationFeedback deletes all the recommendation feedback that matches the given input.
  deleteRecommendationFeedback(
    input: DeleteRecommendationFeedbackInput!
  ): DeleteRecommendationFeedbackPayload
  # Deletes a chatroom.
  deleteRoom(input: DeleteRoomInput!): DeleteRoomPayload @deprecated
  # Deletes an existing message in a chatroom.
  deleteRoomMessage(input: DeleteRoomMessageInput!): DeleteRoomMessagePayload
  # Delete the entire schedule of a user.
  deleteSchedule(input: DeleteScheduleInput!): DeleteSchedulePayload
  # Delete a segment of a schedule of a user.
  deleteScheduleSegment(
    input: DeleteScheduleSegmentInput!
  ): DeleteScheduleSegmentPayload
  # deleteSocialMedia deletes a social media item for a Channel.
  deleteSocialMedia(input: DeleteSocialMediaInput!): DeleteSocialMediaPayload
  # deleteSquadStreamInvitation allows a squad stream member to delete a squad stream invitation.
  deleteSquadStreamInvitation(
    input: DeleteSquadStreamInvitationInput!
  ): DeleteSquadStreamInvitationPayload
  # Deletes an authorized user who was allowed to stream on behalf of broadcaster.
  deleteStreamAuthorizedUser(
    input: DeleteStreamAuthorizedUserInput!
  ): DeleteStreamAuthorizedUserPayload
  # Deletes clips made by user.
  deleteUserClips(input: DeleteUserClipsInput!): DeleteUserClipsPayload
  # Deletes a user's creator colors.
  deleteUserColors(input: DeleteUserColorsInput!): DeleteUserColorsPayload
  # deleteVideoComment performs a delete on the video comment with the provided comment ID.
  # NOTE: this should use an input argument, not define the commentID right here.
  deleteVideoComment(commentID: ID!): DeleteVideoCommentPayload
  # deleteVideos performs a delete on the list of video ids.
  deleteVideos(input: DeleteVideosInput!): DeleteVideosPayload
  # deleteVideoThumbnail deletes a thumbnail from a video.
  deleteVideoThumbnail(
    input: DeleteVideoThumbnailInput!
  ): DeleteVideoThumbnailPayload
  # Denies a message rejected on a channel chat.
  denyRejectedChatMessage(
    input: DenyRejectedChatMessageInput!
  ): DenyRejectedChatMessagePayload
  # Denies a cheer rejected on a channel chat.
  denyRejectedCheer(input: DenyRejectedCheerInput!): DenyRejectedCheerPayload
    @deprecated(reason: "logic handled by denyRejectedChatMessage")
  # Deny an unban request from a channel-banned user.
  denyUnbanRequest(input: DenyUnbanRequestInput!): DenyUnbanRequestPayload
  # Deselect channel badge (default to global badge).
  deselectChannelBadge(
    input: DeselectChannelBadgeInput!
  ): DeselectChannelBadgePayload
  # Deselect global badge (default to no badge).
  deselectGlobalBadge: DeselectGlobalBadgePayload
  # Disables Two Factor Authentication for a Twitch user. Requires sudo authentication.
  disableTwoFactor(input: DisableTwoFactorInput!): DisableTwoFactorPayload
  # Allows the current user to disable or permanently delete their own account.
  disableUserAccount(input: DisableUserAccountInput!): DisableUserAccountPayload
  # dismissFriendRecommendation removes a friend recommendation to the authenticated user without creating a friend
  # request.
  dismissFriendRecommendation(
    input: DismissFriendRecommendationInput!
  ): DismissFriendRecommendationPayload
  # Permanently dismiss a ritual token without redeeming it.
  dismissRitualToken(input: DismissRitualTokenInput!): DismissRitualTokenPayload
  # dismissVideoSuggestedHighlight dismisses the automated highlight suggestion for a video.
  dismissVideoSuggestedHighlight(
    input: DismissVideoSuggestedHighlightInput!
  ): DismissVideoSuggestedHighlightPayload
  # dropImageUpload makes a request for a url to upload an image to. The caller can then use the URL to upload an image
  # of their choice for either a drop or a benefit.
  dropImageUpload(input: DropImageUploadInput!): DropImageUploadPayload
  # Edits an existing message in a chatroom.
  editRoomMessage(input: EditRoomMessageInput!): EditRoomMessagePayload
    @deprecated
  # emitCampaignDiscoveryEvent updates a user's progress towards a discovery objective in applicable campaigns.
  emitCampaignDiscoveryEvent(
    input: EmitCampaignDiscoveryEventInput!
  ): EmitCampaignDiscoveryEventPayload @deprecated
  # endUseBitsInExtension completes the bit usage transaction in an extension.
  endUseBitsInExtension(
    input: EndUseBitsInExtensionInput!
  ): EndUseBitsInExtensionPayload
  # equipHeroAssets adds the specified assets to a user's hero.
  equipHeroAssets(input: EquipHeroAssetsInput!): EquipHeroAssetsPayload
  # exportVideoToYoutube allows a user to export a video to Youtube.
  exportVideoToYoutube(
    input: ExportVideoToYoutubeInput!
  ): ExportVideoToYoutubePayload
  # extensionLinkUser enables or disables the user's identity sharing with an extension.
  extensionLinkUser(input: ExtensionLinkUserInput!): ExtensionLinkUserPayload
  # finalizeCompetitionLobby update's a lobby's state to DONE and progresses the competition.
  finalizeCompetitionLobby(
    input: FinalizeCompetitionLobbyInput!
  ): FinalizeCompetitionLobbyPayload
  # followGame allows a user to follow a game.
  followGame(input: FollowGameInput!): FollowGamePayload
  # followUser creates a follow relationship between the authenticated user and
  # the target user.
  followUser(input: FollowUserInput!): FollowUserPayload
  # generateAnimatedEmote kicks off the generation of animated .gif assets from a given animation preset and static image ids.
  # The user will be notified of success or failure on pubsub.
  generateAnimatedEmote(
    input: GenerateAnimatedEmoteInput!
  ): GenerateAnimatedEmotePayload
  # generateExtensionRatingsCSVReport  asks the ExtensionRatings backend to generate a report and return a filename
  # for that report.  The filename can then be used in follow-up calls to getReportPresignedURL to poll for its
  # completion.  Authenticated on userID:extensionID via OWL in the ExtensionRatings backend.
  generateExtensionRatingsCSVReport(
    input: GenerateExtensionRatingsCSVReportInput!
  ): GenerateExtensionRatingsCSVReportPayload
  # generateSecondFactorQRCode generates a new second factor QR code so it can be used to generate OTP for authentication.
  # The mutation requires sudo privilege to be successful.
  generateSecondFactorQRCode(
    input: GenerateSecondFactorQRCodeInput!
  ): GenerateSecondFactorQRCodePayload
  # generateSubscribersCSV kicks off a background job that will generate a csv containing a list
  # of the channel's subscribers and then will alert the frontend that the csv is ready to
  # download using pubsub. Authenticated on the channelID.
  generateSubscribersCSV(
    input: GenerateSubscribersCSVInput!
  ): GenerateSubscribersCSVPayload
  # getEmoteUploadConfig makes a request to mako to get emote upload configuration for a user to upload a new emote with.
  getEmoteUploadConfig(
    input: GetEmoteUploadConfigInput!
  ): GetEmoteUploadConfigPayload
  # Start a raid.
  goRaid(input: GoRaidInput!): GoRaidPayload
  # Grant the VIP status to a user for a channel.
  grantVIP(input: GrantVIPInput!): GrantVIPPayload
  # Host a target channel from a channel.
  hostTargetChannel(input: HostTargetChannelInput!): HostTargetChannelPayload
  # Install an extension onto a specific channel.
  installExtension(input: InstallExtensionInput!): InstallExtensionPayload
  # Disable the schedule of a user.
  interruptSchedule(input: InterruptScheduleInput!): InterruptSchedulePayload
  # Invalidates authenticated sessions.
  invalidateAuthenticatedSessions(
    input: InvalidateAuthenticatedSessionsInput!
  ): InvalidateAuthenticatedSessionsPayload
  # Invalidates an association to an email.
  invalidateEmailAssociation(
    input: InvalidateEmailAssociationInput!
  ): InvalidateEmailAssociationPayload
  # Joins the channel's chatrooms.
  joinChannelRooms(input: JoinChannelRoomsInput!): JoinChannelRoomsPayload
    @deprecated
  # Add a viewer to a source channel's raid. The viewer will be redirected to the target channel when the raid starts.
  joinRaid(input: JoinRaidInput!): JoinRaidPayload
  # Leaves the channel's chatrooms.
  leaveChannelRooms(input: LeaveChannelRoomsInput!): LeaveChannelRoomsPayload
    @deprecated
  # Leave a raid for a viewer.
  leaveRaid(input: LeaveRaidInput!): LeaveRaidPayload
  # leaveSquadStream allows a member of a squad stream to leave the squad.  Their stream will be
  # removed from the viewer experience, and they will be free to start/join another squad stream.
  leaveSquadStream(input: LeaveSquadStreamInput!): LeaveSquadStreamPayload
  # Link a single sign-on (SSO) app to a user's account.
  linkSSO(input: LinkSSOInput!): LinkSSOPayload
    @deprecated(reason: "Service has been shutdown")
  # Update a Prediction Event from ACTIVE to LOCKED, so that users can no longer make predictions on it.
  lockPredictionEvent(
    input: LockPredictionEventInput!
  ): LockPredictionEventPayload
  # Makes a download URL for an authorized user to download a batch of keys.
  makeKeyBatchDownloadURL(
    input: MakeKeyBatchDownloadURLInput!
  ): MakeKeyBatchDownloadURLPayload
  # Make a prediction on an active Prediction Event.
  makePrediction(input: MakePredictionInput!): MakePredictionPayload
  # Manually triggers drop in Drops 2.0 system.
  manuallyTriggerDrop(
    input: ManuallyTriggerDropInput!
  ): ManuallyTriggerDropPayload
  # ReadAllCreatorNotifications marks all creator notifications as read.
  markAllCreatorNotificationsAsRead(
    input: MarkAllCreatorNotificationsAsReadInput!
  ): MarkAllCreatorNotificationsAsReadPayload
  # ReadAllViewerNotifications marks all viewer notifications as read.
  markAllViewerNotificationsAsRead(
    input: MarkAllViewerNotificationsAsReadInput
  ): MarkAllViewerNotificationsAsReadPayload
  # Make a user a moderator for a channel.
  modUser(input: ModUserInput!): ModUserPayload
  # orderPanels updates the sort order of the provided panels, the input must be a list of panel ids
  # all of which are owned by the acting user otherwise the request will fail and a generic GraphQL
  # error will be returned.
  orderPanels(input: OrderPanelsInput!): OrderPanelsPayload
  # Presign and return a secure S3 URL to download a CSV report for a GAME or EXTENSION.
  # The generated CSV report contains rows for every day after 2018-01-31.
  presignDevInsightsReportURL(
    input: PresignDevInsightsReportURLInput!
  ): PresignDevInsightsReportURLPayload
  # processAndroidPayment processes an off-platform Android payment (user was charged outside the Twitch platform).
  # See also: processIOSPayment (iOS purchases) and purchaseOffer (on-platform purchases).
  processAndroidPayment(
    input: ProcessAndroidPaymentInput!
  ): ProcessAndroidPaymentPayload
  # processIOSPayment processes an off-platform iOS payment (user was charged outside the Twitch platform).
  # See also: processAndroidPayment (Android purchases) and purchaseOffer (on-platform purchases).
  processIOSPayment(input: ProcessIOSPaymentInput!): ProcessIOSPaymentPayload
  # publishClip allows a user to permanently edit and update their default clip, viewable to the public.
  publishClip(input: PublishClipInput!): PublishClipPayload
  # Publishes a competition to make it visible on the esports page.
  publishCompetition(input: PublishCompetitionInput!): PublishCompetitionPayload
  # Publishes a subscription emote to become available with a subscription product.
  publishSubscriptionEmote(
    input: PublishSubscriptionEmoteInput!
  ): PublishSubscriptionEmotePayload
  # purchaseOffer completes the purchase of an offer made inside the Twitch platform.
  # See also: processAndroidPayment (Android purchases) and processIOSPayment.
  purchaseOffer(input: PurchaseOfferInput!): PurchaseOfferPayload
  # Submit a rating for a Twitch extension.
  rateExtension(input: RateExtensionInput!): RateExtensionPayload
  # readNotifications sets the read state to true for one or more onsite notifications of the authenticated user.
  readNotifications(input: ReadNotificationsInput!): ReadNotificationsPayload
  # Record an ad event.
  recordAdEvent(input: RecordAdEventInput!): RecordAdEventPayload
  # Redeem a claimable code, like a bits key code to add bits to your account, etc.
  redeemClaimable(input: RedeemClaimableInput!): RedeemClaimablePayload
  # Redeem a Community Points custom reward in a channel.
  redeemCommunityPointsCustomReward(
    input: RedeemCommunityPointsCustomRewardInput!
  ): RedeemCommunityPointsCustomRewardPayload
  # Redeem a set of creator gift subscriptions.
  redeemCreatorGifts(input: RedeemCreatorGiftsInput!): RedeemCreatorGiftsPayload
  # Redeem an available ritual token. Currently, tokens are redeemed by sending
  # a special message to a channel's chat.
  redeemRitualToken(input: RedeemRitualTokenInput!): RedeemRitualTokenPayload
  # Submit a Subscription Redemption.
  redeemSubscription(input: RedeemSubscriptionInput!): RedeemSubscriptionPayload
  # redeemTrueXAd processes the result of watching an ad to earn bits.
  # This action can only be taken if an OAuth token is supplied with the request.
  redeemTrueXAd(input: RedeemTrueXAdInput!): RedeemTrueXAdPayload
  # refreshExtensionToken is used by our client on a timer to ensure the token
  # doesn't expire while the user is using the site.
  refreshExtensionToken(
    input: RefreshExtensionTokenInput!
  ): RefreshExtensionTokenPayload
  # regenerateStreamKey generates a new stream key for the broadcaster and returns the newly generated stream key.
  regenerateStreamKey(
    input: RegenerateStreamKeyInput!
  ): RegenerateStreamKeyPayload
  # regenerateVerificationCode generates a new verification code and resends the verification message with the new code.
  regenerateVerificationCode(
    input: RegenerateVerificationCodeInput!
  ): RegenerateVerificationCodePayload
  # Register payout information during payout onboarding.
  registerPayoutInformation(
    input: RegisterPayoutInformationInput!
  ): RegisterPayoutInformationPayload
  # Starts the registration for second factor authentication for a twitch user. Requires sudo authentication.
  registerTwoFactor(input: RegisterTwoFactorInput!): RegisterTwoFactorPayload
  # Finishes the registration for second factor authentication for a twitch user. Requires sudo authentication.
  registerTwoFactorConfirmation(
    input: RegisterTwoFactorConfirmationInput!
  ): RegisterTwoFactorConfirmationPayload
  # rejectFriendRequest destroys a friend request relationship from the target user to the authenticated user.
  rejectFriendRequest(
    input: RejectFriendRequestInput!
  ): RejectFriendRequestPayload
  # rejectSquadStreamInvitation allows a user to decline an invitation to join a squad stream.
  rejectSquadStreamInvitation(
    input: RejectSquadStreamInvitationInput!
  ): RejectSquadStreamInvitationPayload
  # rejectSquadStreamOutOfNetworkInvitations allows a user to decline all out-of-network invitations to join a squad stream.
  rejectSquadStreamOutOfNetworkInvitations(
    input: RejectSquadStreamOutOfNetworkInvitationsInput!
  ): RejectSquadStreamOutOfNetworkInvitationsPayload
  # Removes channels from a user's AutoHost list.
  removeAutohostChannels(
    input: RemoveAutohostChannelsInput!
  ): RemoveAutohostChannelsPayload
  # removeCollectionItem removes an item from a collection.
  removeCollectionItem(
    input: RemoveCollectionItemInput!
  ): RemoveCollectionItemPayload
  # Remove a phase from a Competition.
  removeCompetitionPhase(
    input: RemoveCompetitionPhaseInput!
  ): RemoveCompetitionPhasePayload
  # Remove CompetitionPlayer from a competition.
  removeCompetitionPlayer(
    input: RemoveCompetitionPlayerInput!
  ): RemoveCompetitionPlayerPayload
  # Remove a competition team from a Competition.
  removeCompetitionTeam(
    input: RemoveCompetitionTeamInput!
  ): RemoveCompetitionTeamPayload
  # Revoke the editor status from a user for a given channel.
  removeEditor(input: RemoveEditorInput!): RemoveEditorPayload
  # Remove an emote from its assigned group.
  removeEmoteFromGroup(
    input: RemoveEmoteFromGroupInput!
  ): RemoveEmoteFromGroupPayload
  # Removes a rbac user from a developer organization.
  removeOrganizationMember(
    input: RemoveOrganizationMemberInput!
  ): RemoveOrganizationMemberPayload
  # removeReaction removes a reaction created with addReaction.
  removeReaction(input: RemoveReactionInput!): RemoveReactionPayload @deprecated
  # removeSquadStreamMember allows the owner of a squad stream to remove a member from the squad stream.
  removeSquadStreamMember(
    input: RemoveSquadStreamMemberInput!
  ): RemoveSquadStreamMemberPayload
  # removeStucco allows the owner of a stucco to remove an inactive stucco from their library.
  removeStucco(input: RemoveStuccoInput!): RemoveStuccoPayload
  # reorderCollectionItem reorders an item's position in a collection.
  reorderCollectionItem(
    input: ReorderCollectionItemInput!
  ): ReorderCollectionItemPayload
  # reportContent allows a user to report content on the site as infringing of our terms of service.
  reportContent(input: ReportContentInput!): ReportContentPayload
  # Reports a user for bad behavior in a whisper thread.
  reportWhisper(input: ReportWhisperInput!): ReportWhisperPayload
  # Reports a whisper thread as spam.
  reportWhisperThread(
    input: ReportWhisperThreadInput!
  ): ReportWhisperThreadPayload @deprecated(reason: "Use reportWhisper")
  # Request a ritual token to be issued to the user.
  requestRitualToken(input: RequestRitualTokenInput!): RequestRitualTokenPayload
  # resendVerificationEmail resends a verification email to the current user.
  resendVerificationEmail(
    input: ResendVerificationEmailInput!
  ): ResendVerificationEmailPayload
  # resetUsername allows a user to update their flagged username.
  resetUsername(input: ResetUsernameInput!): ResetUsernamePayload
  # Resolve a Prediction Event by specifying the winning option.
  resolvePredictionEvent(
    input: ResolvePredictionEventInput!
  ): ResolvePredictionEventPayload
  # Respond to a team invitation by accepting or declining.
  respondToTeamInvitation(
    input: RespondToTeamInvitationInput!
  ): RespondToTeamInvitationPayload
  # Enable the schedule of a user.
  resumeSchedule(input: ResumeScheduleInput!): ResumeSchedulePayload
  # Revoke the VIP status of a user from a channel.
  revokeVIP(input: RevokeVIPInput!): RevokeVIPPayload
  # Request a new extension secret; automatically rotates any current secrets out of service
  # with enough time for extension clients to gracefully switch over.  This function should
  # only be called when you are ready to install the new set of secrets it will return; use
  # GET to view secrets without rotating them.
  rotateExtensionSecrets(
    input: RotateExtensionSecretsInput!
  ): RotateExtensionSecretsPayload
  # Runs multiplayer ads on a channel.
  runMultiplayerAds(input: RunMultiplayerAdsInput!): RunMultiplayerAdsPayload
  # saveExtensionManifest allows a user to update the manifest for an extension in development.
  saveExtensionManifest(
    input: SaveExtensionManifestInput!
  ): SaveExtensionManifestPayload
  # Give a competition participant a seed value.
  seedCompetitionParticipant(
    input: SeedCompetitionParticipantInput!
  ): SeedCompetitionParticipantPayload
  # Select a user's channel badge for a channel.
  selectChannelBadge(input: SelectChannelBadgeInput!): SelectChannelBadgePayload
  # Select a user's global badge.
  selectGlobalBadge(input: SelectGlobalBadgeInput!): SelectGlobalBadgePayload
  # Send a chat message through subscribers-only mode with Channel Points.
  sendChatMessageThroughSubscriberMode(
    input: SendChatMessageThroughSubscriberModeInput!
  ): SendChatMessageThroughSubscriberModePayload
  # sendCheer sends a chat message that contains cheermotes. The message will
  # be processed, bits deducted from the authenticated user's balance, and then the
  # message will be passed on to the chat service (client shouldn't send the message itself).
  # This action can only be taken if an OAuth token is supplied with the request.
  sendCheer(input: SendCheerInput!): SendCheerPayload
  # Sends a pubsub message on behalf of an Extension.
  sendExtensionMessage(
    input: SendExtensionMessageInput!
  ): SendExtensionMessagePayload
  # Send a highlighted chat message with Channel Points.
  sendHighlightedChatMessage(
    input: SendHighlightedChatMessageInput!
  ): SendHighlightedChatMessagePayload
  # Sends a message to a chatroom.
  sendRoomMessage(input: SendRoomMessageInput!): SendRoomMessagePayload
    @deprecated
  # Sends a whisper message to the target user.
  sendWhisper(input: SendWhisperInput!): SendWhisperPayload
  # Set values for length and period of ads for channel ads management.
  setAutoAdDensity(input: SetAutoAdDensityInput!): SetAutoAdDensityPayload
  # Sets the user's auto refill settings.
  setAutoRefillSettings(
    input: SetAutoRefillSettingsInput!
  ): SetAutoRefillSettingsPayload
  # Sets the user's list of channelIDs to autohost.
  setAutohostChannels(
    input: SetAutohostChannelsInput!
  ): SetAutohostChannelsPayload
  # setBitsUserSettings sets a Bits users settings such as skipping the tutorial.
  setBitsUserSettings(
    input: SetBitsUserSettingsInput!
  ): SetBitsUserSettingsPayload
  # Set a channel's ad break schedule preferences.
  setChannelAdSchedule(
    input: SetChannelAdScheduleInput!
  ): SetChannelAdSchedulePayload
  # Set value for channel_feed_enabled.
  setChannelFeedEnabled(
    input: SetChannelFeedEnabledInput!
  ): SetChannelFeedEnabledPayload @deprecated
  # setChannelNotificationSetting allows a user to set a notification setting.
  setChannelNotificationSetting(
    input: SetChannelNotificationSettingInput!
  ): SetChannelNotificationSettingPayload
  # Set a channel's trailer.
  # A channel trailer can only be modified by its corresponding user, a channel editor, or a Twitch admin.
  setChannelTrailer(input: SetChannelTrailerInput!): SetChannelTrailerPayload
  # Set a user's Chat Pause setting.
  setChatPauseSetting(
    input: SetChatPauseSettingInput!
  ): SetChatPauseSettingPayload
  # setContentTags updates the tags specified and associates it with the piece of content specified.
  setContentTags(input: SetContentTagsInput!): SetContentTagsPayload
  # setCreatorBadgeFlair updates the channel-wide setting for a user that determines what
  # type of subscriber badge flair is available to eligible subscribers to that channel.
  setCreatorBadgeFlair(
    input: SetCreatorBadgeFlairInput!
  ): SetCreatorBadgeFlairPayload
  # setDashboardAlertQueueActivityStatus updates the specified activity's status for the dashboard alert queue.
  setDashboardAlertQueueActivityStatus(
    input: SetDashboardAlertQueueActivityStatusInput!
  ): SetDashboardAlertQueueActivityStatusPayload
  # setDashboardAlertQueuePreference updates the preference specified for the dashboard alert queue.
  setDashboardAlertQueuePreference(
    input: SetDashboardAlertQueuePreferenceInput!
  ): SetDashboardAlertQueuePreferencePayload
  # Sets the default payment method for a user.
  # Currently supports the Zuora (credit card) and Recurly (credit card, Pay-with-Amazon, PayPal) payment providers
  # This is the final step of the payment method management flow.
  # (User.paymentMethods -> User.paymentMethodConfigs -> this mutation).
  setDefaultPaymentMethod(
    input: SetDefaultPaymentMethodInput!
  ): SetDefaultPaymentMethodPayload
  # Set a user's Deleted Message Display Chat UI setting.
  setDeletedMessageDisplaySetting(
    input: SetDeletedMessageDisplaySettingInput!
  ): SetDeletedMessageDisplaySettingPayload
  # SetDropBenefitOnDrop adds a benefit to a drop within a drop campaign.
  setDropBenefitsOnDrop(
    input: SetDropBenefitsOnDropInput!
  ): SetDropBenefitsOnDropPayload
  # setDropCampaignAccess updates who can or cannot access a campaign's drops.
  setDropCampaignAccess(
    input: SetDropCampaignAccessInput!
  ): SetDropCampaignAccessPayload
  # setDropCampaignStatus transitions a campaign between states.
  setDropCampaignStatus(
    input: SetDropCampaignStatusInput!
  ): SetDropCampaignStatusPayload
  # setDropCampaignSummary allows organizations in the devconsole to update a previously created campaign's summary.
  setDropCampaignSummary(
    input: SetDropCampaignSummaryInput!
  ): SetDropCampaignSummaryPayload
  # setDropEventRule updates a drops's rule to be an event based rule.
  setDropEventRule(input: SetDropEventRuleInput!): SetDropEventRulePayload
  # setDropSummary allows organizations to update a drop's summary data.
  setDropSummary(input: SetDropSummaryInput!): SetDropSummaryPayload
  # setDropTimeBasedRule updates a drops's rule to be a minutes watched based rule.
  setDropTimeBasedRule(
    input: SetDropTimeBasedRuleInput!
  ): SetDropTimeBasedRulePayload
  # Set a user's emote animations UI setting.
  setEmoteAnimationsEnabled(
    input: SetEmoteAnimationsEnabledInput!
  ): SetEmoteAnimationsEnabledPayload
  # Set a user's emote animations callout dismissed setting.
  setEmoteAnimationsSettingCalloutDismissed(
    input: SetEmoteAnimationsSettingCalloutDismissedInput!
  ): SetEmoteAnimationsSettingCalloutDismissedPayload
  # Sets the emote modifier groups for a user.
  setEmoteModifierGroups(
    input: SetEmoteModifierGroupsInput!
  ): SetEmoteModifierGroupsPayload
  # Sets the configuration for an extension version.
  setExtensionConfiguration(
    input: SetExtensionConfigurationInput!
  ): SetExtensionConfigurationPayload
  # Sets the feature flag options on a specified extension installation.
  setExtensionFeatureFlags(
    input: SetExtensionFeatureFlagsInput!
  ): SetExtensionFeatureFlagsPayload
  # Set the OAuth token for an installation which is retrieved and used for Helix requests from extensions.
  setExtensionInstallationOAuth(
    input: SetExtensionInstallationOAuthInput!
  ): SetExtensionInstallationOAuthPayload
  # SetGameDropAccountLinkClient sets the client ID on a game which is used to
  # verify that users have connected their game accounts.
  setGameDropAccountLinkClient(
    input: SetGameDropAccountLinkClientInput!
  ): SetGameDropAccountLinkClientPayload
  # Sets the user's current hero to their profile picture.
  setHeroAsAvatar(input: SetHeroAsAvatarInput!): SetHeroAsAvatarPayload
  # Set access permission to the channel's moderator logs for a given role.
  setModLogsAccess(input: SetModLogsAccessInput!): SetModLogsAccessPayload
  # Set a user's mod view page tutorial seen state & time.
  setModViewSettings(input: SetModViewSettingsInput!): SetModViewSettingsPayload
  # setNotificationSetting allows a user to set a notification setting.
  setNotificationSetting(
    input: SetNotificationSettingInput!
  ): SetNotificationSettingPayload
  # setOverwatchLeagueTeamPreference allows a user to set their preferred Overwatch team.
  setOverwatchLeagueTeamPreference(
    input: SetOverwatchLeagueTeamPreferenceInput!
  ): SetOverwatchLeagueTeamPreferencePayload
  # Set a user's preferred language tag.
  setPreferredLanguageTag(
    input: SetPreferredLanguageTagInput!
  ): SetPreferredLanguageTagPayload
  # Set radio track information currently being played.
  setRadioCurrentlyPlaying(
    input: SetRadioCurrentlyPlayingInput!
  ): SetRadioCurrentlyPlayingPayload
  # Set a user's readable chat colors UI setting.
  setReadableChatColorsEnabled(
    input: SetReadableChatColorsEnabledInput!
  ): SetReadableChatColorsEnabledPayload
  # setResourceRestriction can create or update a restriction on a resource.
  setResourceRestriction(
    input: SetResourceRestrictionInput!
  ): SetResourceRestrictionPayload
  # setScheduleReminder toggles on or off a user's set reminder for a given scheduled event.
  setScheduleReminder(
    input: SetScheduleReminderInput!
  ): SetScheduleReminderPayload
  # setSessionStatus sets the user's status for this session, which influences how they appear ("online", "idle",
  # "watching SnarfyBobo") to friends and related users. To maintain a session status, setSessionStatus needs to be sent
  # periodically. The amount of time your application should wait between these status heartbeats is included in the
  # response payload.
  setSessionStatus(input: SetSessionStatusInput!): SetSessionStatusPayload
  # Set the ID of the primary player in a squad stream that the user currently has in the primary position.
  setSquadStreamPrimaryPlayer(
    input: SetSquadStreamPrimaryPlayerInput!
  ): SetSquadStreamPrimaryPlayerPayload
  # setUnbanRequestsSettings allows a user to set their channel's unban requests settings.
  setUnbanRequestsSettings(
    input: SetUnbanRequestsSettingsInput!
  ): SetUnbanRequestsSettingsPayload
  # Set user's country of residence.
  setUserResidence(input: SetUserResidenceInput!): SetUserResidencePayload
  # Make a SnoozeNextAdRequest.
  snoozeAd(input: SnoozeAdInput!): SnoozeAdPayload
  # Spend Twitch Prime monthly subscription credit.
  spendSubscriptionCredit(
    input: SpendSubscriptionCreditInput!
  ): SpendSubscriptionCreditPayload
  # Start a new ad break.
  startAd(input: StartAdInput!): StartAdPayload
  # startBounty allows a user to start a bounty for tracking (e.g. track the
  # viewers CCU for meeting the bounty's requirements).
  # If the user has not provided a title or met the other requirements to start the bounty, it will return an error.
  startBounty(input: StartBountyInput!): StartBountyPayload
  # Starts a cloud broadcast.
  startCloudBroadcast(
    input: StartCloudBroadcastInput!
  ): StartCloudBroadcastPayload
  # Start a new payout onboarding workflow.
  startPayoutOnboardingWorkflow(
    input: StartPayoutOnboardingWorkflowInput!
  ): StartPayoutOnboardingWorkflowPayload
  # Start a Prime Video Watch Party.
  startWatchParty(input: StartWatchPartyInput!): StartWatchPartyPayload
  # stopBounty allows a user to stop tracking progress for a bounty.
  stopBounty(input: StopBountyInput!): StopBountyPayload
  # Stops a cloud broadcast.
  stopCloudBroadcast(input: StopCloudBroadcastInput!): StopCloudBroadcastPayload
  # Stop a Prime Video Watch Party.
  stopWatchParty(input: StopWatchPartyInput!): StopWatchPartyPayload
  # Submit Copyright Claim Notice.
  submitCopyrightClaim(
    input: SubmitCopyrightClaimInput!
  ): SubmitCopyrightClaimPayload
  # Submit CSAT (customer satisfaction) feedback.
  submitCSATFeedback(input: SubmitCSATFeedbackInput!): SubmitCSATFeedbackPayload
  # Submit a new emote prefix for a given channel. Each channel has a single prefix.
  # Submitting more than once overrides the previously set prefix.
  submitEmotePrefix(input: SubmitEmotePrefixInput!): SubmitEmotePrefixPayload
  # Submit a new emoticon prefix for a given channel. Each channel has a single prefix. Submitting
  # more than once simply overrides the previously set prefix and putting it in a pending state.
  submitEmoticonPrefix(
    input: SubmitEmoticonPrefixInput!
  ): SubmitEmoticonPrefixPayload
    @deprecated(reason: "Use 'submitEmotePrefix' instead")
  # Submit feedback for a Twitch extension.
  submitExtensionFeedback(
    input: SubmitExtensionFeedbackInput!
  ): SubmitExtensionFeedbackPayload
  # Swap competition lobby participants within a competition phase.
  swapCompetitionLobbyParticipants(
    input: SwapCompetitionLobbyParticipantsInput!
  ): SwapCompetitionLobbyParticipantsPayload
  # Syncs the current game data with the game data stored by the DropsManagementService. The DropsManagementService
  # purposefully does not autosync when a Game is updated so that a change to the Game's account link client ID
  # doesn't get overwritten without running this command.
  syncGameOnDropCampaign(
    input: SyncGameOnDropCampaignInput!
  ): SyncGameOnDropCampaignPayload
  # Terminates the poll with the given poll id.
  terminatePoll(input: TerminatePollInput!): TerminatePollPayload
  # Terminates the current poll in a channel.
  terminatePollInChannel(
    input: TerminatePollInChannelInput!
  ): TerminatePollInChannelPayload
  # toggleRitualsEnabled allows a user to toggle the rituals feature for their channel.
  toggleRitualsEnabled(
    input: ToggleRitualsEnabledInput!
  ): ToggleRitualsEnabledPayload
  # Transitions the state for an existing extension.
  # Only allowed for the owner of the extension.
  transitionExtensionState(
    input: TransitionExtensionStateInput!
  ): TransitionExtensionStatePayload
  # Removes a ban imposed on a user for a specified chat room.
  unbanUserFromChatRoom(
    input: UnbanUserFromChatRoomInput!
  ): UnbanUserFromChatRoomPayload
  # Removes block from target user.
  unblockUser(input: UnblockUserInput!): UnblockUserPayload
  # undoRecommendationFeedback allows a user to removes a single piece of feedback.
  undoRecommendationFeedback(
    input: UndoRecommendationFeedbackInput!
  ): UndoRecommendationFeedbackPayload
  # unfollowGame allows a user to unfollow a game.
  unfollowGame(input: UnfollowGameInput!): UnfollowGamePayload
  # unfollowUser destroys the follow relationship between the authenticated user and
  # the target user.
  unfollowUser(input: UnfollowUserInput!): UnfollowUserPayload
  # unfriendUser destroys a friend relationship from the target user to the authenticated user.
  unfriendUser(input: UnfriendUserInput!): UnfriendUserPayload
  # Unhost from a channel.
  unhost(input: UnhostInput!): UnhostPayload
  # Uninstall an extension from a specific channel.
  uninstallExtension(input: UninstallExtensionInput!): UninstallExtensionPayload
  # Unlink an authenticated user's amazon connection.
  unlinkAmazonConnection(
    input: UnlinkAmazonConnectionInput!
  ): UnlinkAmazonConnectionPayload
  # Unlink a user's account connection to Riot.
  unlinkRiotConnection(
    input: UnlinkRiotConnectionInput!
  ): UnlinkRiotConnectionPayload
  # Unlink an SSO app from a user's account.
  unlinkSSO(input: UnlinkSSOInput!): UnlinkSSOPayload
    @deprecated(reason: "Service has been shutdown")
  # Unlock a chosen modified subscriber emote using Community Points.
  unlockChosenModifiedSubscriberEmote(
    input: UnlockChosenModifiedSubscriberEmoteInput!
  ): UnlockChosenModifiedSubscriberEmotePayload
  # Unlock a chosen subscriber emote using Community Points.
  unlockChosenSubscriberEmote(
    input: UnlockChosenSubscriberEmoteInput!
  ): UnlockChosenSubscriberEmotePayload
  # Unlock a random subscriber emote using Community Points.
  unlockRandomSubscriberEmote(
    input: UnlockRandomSubscriberEmoteInput!
  ): UnlockRandomSubscriberEmotePayload
  # Remove moderator status from a user in a channel.
  unmodUser(input: UnmodUserInput!): UnmodUserPayload
  # unsetHypeTrainConfig allows a user to unset the channel's custom hype train configurations.
  unsetHypeTrainConfig(
    input: UnsetHypeTrainConfigInput!
  ): UnsetHypeTrainConfigPayload
  # unsubscribeEmail unsubscribes a given user from a given email campaign.
  unsubscribeEmail(input: UnsubscribeEmailInput!): UnsubscribeEmailPayload
  # Updates a user's ad settings for their channel.
  updateAdProperties(input: UpdateAdPropertiesInput!): UpdateAdPropertiesPayload
  # Updates all a channels vidoes to the provided viewability.
  updateAllChannelVideosViewability(
    input: UpdateAllChannelVideosViewabilityInput!
  ): UpdateAllChannelVideosViewabilityPayload
  # Updates all of a user's whisper threads.
  updateAllWhisperThreads(
    input: UpdateAllWhisperThreadsInput!
  ): UpdateAllWhisperThreadsPayload
  # Set individual automod categories (i.e. set identity to level 3 but profanity to 0).
  updateAutoModLevels(
    input: UpdateAutoModLevelsInput!
  ): UpdateAutoModLevelsPayload
  # Set individual automod categories (i.e. set identity to level 3 but profanity
  # to 0) - based on Sift categories, to be deprecated.
  updateAutoModProperties(
    input: UpdateAutoModPropertiesInput!
  ): UpdateAutoModPropertiesPayload
  # Update a user's autohost settings.
  updateAutohostSettings(
    input: UpdateAutohostSettingsInput!
  ): UpdateAutohostSettingsPayload
  # Updates bits badge tier notification.
  updateBitsBadgeTierNotification(
    input: UpdateBitsBadgeTierNotificationInput!
  ): UpdateBitsBadgeTierNotificationPayload
  # Updates bits badge tiers.
  updateBitsBadgeTiers(
    input: UpdateBitsBadgeTiersInput!
  ): UpdateBitsBadgeTiersPayload
  # Updates boost settings.
  updateBoostSettings(
    input: UpdateBoostSettingsInput!
  ): UpdateBoostSettingsPayload
  # updateBroadcastSettings allows the user to update their broadcast setting.
  updateBroadcastSettings(
    input: UpdateBroadcastSettingsInput!
  ): UpdateBroadcastSettingsPayload
  # Update a channels celebration.
  updateCelebration(input: UpdateCelebrationInput!): UpdateCelebrationPayload
  # Update a channels celebration config.
  updateCelebrationConfig(
    input: UpdateCelebrationConfigInput!
  ): UpdateCelebrationConfigPayload
  # Update a channel's celebration product config.
  updateCelebrationProductConfig(
    input: UpdateCelebrationProductConfigInput!
  ): UpdateCelebrationProductConfigPayload
  # Update a user's celebration user settings.
  updateCelebrationUserSettings(
    input: UpdateCelebrationUserSettingsInput!
  ): UpdateCelebrationUserSettingsPayload
  # updateChangelogReadTime marks the changelog as read for a user.
  updateChangelogReadTime: UpdateChangelogReadTimePayload
  # updateChanletContentAttributes allows users to make changes to the multi-view content attributes on a chanlet.
  updateChanletContentAttributes(
    input: UpdateChanletContentAttributesInput!
  ): UpdateChanletContentAttributesPayload
  # updateChannelClipsSetting allows a channel owner to enable/disable creation
  # of Clips on their channel.
  updateChannelClipsSetting(
    input: UpdateChannelClipsSettingInput!
  ): UpdateChannelClipsSettingPayload
  # updateChannelHomePreferences updates a streamer's channel home preferences.
  updateChannelHomePreferences(
    input: UpdateChannelHomePreferencesInput!
  ): UpdateChannelHomePreferencesPayload
  # Update a channel's Prediction Settings.
  updateChannelPredictionSettings(
    input: UpdateChannelPredictionSettingsInput!
  ): UpdateChannelPredictionSettingsPayload
  # Updates a user's chat color.
  updateChatColor(input: UpdateChatColorInput!): UpdateChatColorPayload
  # Set different chat settings (i.e. disable globalBannedWordsOptOut).
  updateChatSettings(input: UpdateChatSettingsInput!): UpdateChatSettingsPayload
  # Update the user's partner settings regarding bits.
  updateCheerPartnerSettings(
    input: UpdateCheerPartnerSettingsInput!
  ): UpdateCheerPartnerSettingsPayload
  # Updates the image assets for a broadcaster's particular cheermote tier.
  updateCheermoteTier(
    input: UpdateCheermoteTierInput!
  ): UpdateCheermoteTierPayload
  # updateClip allows a user to update the metadata of a clip.
  updateClip(input: UpdateClipInput!): UpdateClipPayload
  # updateClipViewCount allows a user to increment the viewcount of a clip.
  updateClipViewCount(
    input: UpdateClipViewCountInput!
  ): UpdateClipViewCountPayload
    @deprecated(
      reason: "Will eventually be replaced by different viewcounting method"
    )
  # updateCollection performs an update on the collection with the provided ID and updated attributes.
  updateCollection(input: UpdateCollectionInput!): UpdateCollectionPayload
  # Update an automatic Community Points reward in a channel.
  updateCommunityPointsAutomaticReward(
    input: UpdateCommunityPointsAutomaticRewardInput!
  ): UpdateCommunityPointsAutomaticRewardPayload
  # Update a channel's Community Points channel settings.
  updateCommunityPointsChannelSettings(
    input: UpdateCommunityPointsChannelSettingsInput!
  ): UpdateCommunityPointsChannelSettingsPayload
  # updateCommunityPointsCommunityGoal updates a Community Points Community Goal.
  updateCommunityPointsCommunityGoal(
    input: UpdateCommunityPointsCommunityGoalInput!
  ): UpdateCommunityPointsCommunityGoalPayload
  # Update a custom Community Points reward in a channel.
  updateCommunityPointsCustomReward(
    input: UpdateCommunityPointsCustomRewardInput!
  ): UpdateCommunityPointsCustomRewardPayload
  # Update the status of a Community Points redemption (for example, from unfulfilled to fulfilled).
  updateCommunityPointsCustomRewardRedemptionStatus(
    input: UpdateCommunityPointsCustomRewardRedemptionStatusInput!
  ): UpdateCommunityPointsCustomRewardRedemptionStatusPayload
  # Update the status of all Community Points redemptions for a channel.
  updateCommunityPointsCustomRewardRedemptionStatusesByChannel(
    input: UpdateCommunityPointsCustomRewardRedemptionStatusesByChannelInput!
  ): UpdateCommunityPointsCustomRewardRedemptionStatusesByChannelPayload
  # Update the status of the Community Points redemptions from the provided list.
  updateCommunityPointsCustomRewardRedemptionStatusesByRedemptions(
    input: UpdateCommunityPointsCustomRewardRedemptionStatusesByRedemptionsInput!
  ): UpdateCommunityPointsCustomRewardRedemptionStatusesByRedemptionsPayload
  # Update the status of all Community Points redemptions for a reward.
  updateCommunityPointsCustomRewardRedemptionStatusesByReward(
    input: UpdateCommunityPointsCustomRewardRedemptionStatusesByRewardInput!
  ): UpdateCommunityPointsCustomRewardRedemptionStatusesByRewardPayload
  # Allows users to sign up for or remove themselves from the Community Points early access program.
  updateCommunityPointsEarlyAccessSettings(
    input: UpdateCommunityPointsEarlyAccessSettingsInput!
  ): UpdateCommunityPointsEarlyAccessSettingsPayload
    @deprecated(reason: "Early access period is over.")
  # Update the last viewed timestamp of a user for Community Points content.
  updateCommunityPointsLastViewedContent(
    input: UpdateCommunityPointsLastViewedContentInput!
  ): UpdateCommunityPointsLastViewedContentPayload
  # Update an automatic Community Points reward cost acknowledgements.
  updateCommunityPointsSmartCostsAcknowledgements(
    input: UpdateCommunityPointsSmartCostsAcknowledgementsInput!
  ): UpdateCommunityPointsSmartCostsAcknowledgementsPayload
  # Update Competition.
  updateCompetition(input: UpdateCompetitionInput!): UpdateCompetitionPayload
  # Update CompetitionPlayer in a competition.
  updateCompetitionPlayer(
    input: UpdateCompetitionPlayerInput!
  ): UpdateCompetitionPlayerPayload
  # Update  a Team in a Competition.
  updateCompetitionTeam(
    input: UpdateCompetitionTeamInput!
  ): UpdateCompetitionTeamPayload
  # Update a consent status or create a new consent status.
  updateConsent(input: UpdateConsentInput!): UpdateConsentPayload
  # updateContentTags updates the tags specified and associates it with the piece of content specified.
  updateContentTags(input: UpdateContentTagsInput!): UpdateContentTagsPayload
    @deprecated(reason: "Use setContentTags instead")
  # updateDropBenefit updates a benefit owned by an organization. The benefit can be used in drop campaigns.
  updateDropBenefit(input: UpdateDropBenefitInput!): UpdateDropBenefitPayload
  # updateDropBenefitOnDrop sets a benefit on a drop and how often that benefit can be claimed.
  updateDropBenefitOnDrop(
    input: UpdateDropBenefitOnDropInput!
  ): UpdateDropBenefitOnDropPayload
  # updateDropPreconditions updates the drops that must be claimed before a drop can be claimed.
  updateDropPreconditions(
    input: UpdateDropPreconditionsInput!
  ): UpdateDropPreconditionsPayload
  # updateDropsOptOutStatus allows the user to update their drops opt-out status.
  updateDropsOptOutStatus(
    input: UpdateDropsOptOutStatusInput!
  ): UpdateDropsOptOutStatusPayload
  # updateEmoteOrders allows a broadcaster to reorder the emotes within the emote groups they own.
  updateEmoteOrders(input: UpdateEmoteOrdersInput!): UpdateEmoteOrdersPayload
  # updateExtensionDiscoveryData allows a user to update the discovery data for an extension.
  updateExtensionDiscoveryData(
    input: UpdateExtensionDiscoveryDataInput!
  ): UpdateExtensionDiscoveryDataPayload
  # updateExtensionManifest allows a user to update the manifest for an extension in development.
  updateExtensionManifest(
    input: UpdateExtensionManifestInput!
  ): UpdateExtensionManifestPayload
    @deprecated(reason: "Switching to saveExtensionManifest")
  # updateHypeTrainConfig allows a user to update the channel's hype train configurations.
  updateHypeTrainConfig(
    input: UpdateHypeTrainConfigInput!
  ): UpdateHypeTrainConfigPayload
  # Changes the user's activity sharing setting. A user's activity is one part of their status.
  updateIsSharingActivity(
    input: UpdateIsSharingActivityInput!
  ): UpdateIsSharingActivityPayload
  # Exchanges an LWA token for an Amazon OAuth token.
  updateLWAToken(input: UpdateLWATokenInput!): UpdateLWATokenPayload
  # Update the user's partner settings regarding leaderboards.
  updateLeaderboardSettings(
    input: UpdateLeaderboardSettingsInput!
  ): UpdateLeaderboardSettingsPayload
  # Changes the user's activity sharing setting. A user's activity is one part of their status.
  updateLiveUpNotification(
    input: UpdateLiveUpNotificationInput!
  ): UpdateLiveUpNotificationPayload
  # Updates a lobby participant who is a competition player's or competition team's score.
  updateLobbyParticipantScore(
    input: UpdateLobbyParticipantScoreInput!
  ): UpdateLobbyParticipantScorePayload
  # Updates a Mosaic layout with the specified id for the current user.
  updateDashboardViewMosaicLayout(
    input: UpdateDashboardViewMosaicLayoutInput!
  ): UpdateDashboardViewMosaicLayoutPayload
  # Modifies multi-view content attributes.
  updateMultiviewContentAttributes(
    input: UpdateMultiviewContentAttributesInput!
  ): UpdateMultiviewContentAttributesPayload
  # updateOnboardingSkippedChannels updates skipped channel IDs during onboarding for a given user.
  updateOnboardingSkippedChannels(
    input: UpdateOnboardingSkippedChannelsInput!
  ): UpdateOnboardingSkippedChannelsPayload
    @deprecated(reason: "This feature is retired")
  # updateOrganizationMemberRole updates the role of an organization member (Twitch Developers).
  updateOrganizationMemberRole(
    input: UpdateOrganizationMemberRoleInput!
  ): UpdateOrganizationMemberRolePayload
  # updateOwnerChanletAttributes updates/creates a new set of owner chanlet attributes for a Channel.
  updateOwnerChanletAttributes(
    input: UpdateOwnerChanletAttributesInput!
  ): UpdateOwnerChanletAttributesPayload
  # updatePanel updates the data for a given panel.
  updatePanel(input: UpdatePanelInput!): UpdatePanelPayload
  # Starts the process for associating a phone number to a twitch account. Requires sudo authentication.
  # A one time password (valid for 10 minutes) will be sent via SMS to the phone
  # number provided. The one time password will need to be verified via
  # updatePhoneNumberConfirmation to complete the update.
  updatePhoneNumber(input: UpdatePhoneNumberInput!): UpdatePhoneNumberPayload
  # Completes the process for associating a phone number to a twitch account. Requires sudo authentication.
  # The one time password issued using updatePhoneNumber will be verified to make sure user contols the phone number.
  updatePhoneNumberConfirmation(
    input: UpdatePhoneNumberConfirmationInput!
  ): UpdatePhoneNumberConfirmationPayload
  # updatePrimeOfferStatus allows a user to update their status in respect to an offer. (e.g. UNSEEN, SEEN, CLAIMED).
  updatePrimeOfferStatus(
    input: UpdatePrimeOfferStatusInput!
  ): UpdatePrimeOfferStatusPayload
  # updatePrimeSettings allows the user to enable or disable chat notifications when spending a Prime Credit,
  # and allows the user to set the type of Smilies (Turbos, Robots, or Monkeys) they want for Prime/Turbo Emoticons.
  updatePrimeSettings(
    input: UpdatePrimeSettingsInput!
  ): UpdatePrimeSettingsPayload
  # Update a user's raid settings.
  updateRaidSettings(input: UpdateRaidSettingsInput!): UpdateRaidSettingsPayload
  # Updates an existing chatroom.
  updateRoom(input: UpdateRoomInput!): UpdateRoomPayload @deprecated
  # Updates the room modes (slow mode, emotes only mode, etc.) for the room.
  updateRoomModes(input: UpdateRoomModesInput!): UpdateRoomModesPayload
    @deprecated
  # Update's a user's room view for a chatroom.
  updateRoomView(input: UpdateRoomViewInput!): UpdateRoomViewPayload @deprecated
  # Update a schedule segment.
  updateScheduleSegment(
    input: UpdateScheduleSegmentInput!
  ): UpdateScheduleSegmentPayload
  # UpdateSeenCreatorOnboardingContent updates the list of streamer onboarding content that a user has seen.
  updateSeenCreatorOnboardingContent(
    input: UpdateSeenCreatorOnboardingContentInput!
  ): UpdateSeenCreatorOnboardingContentPayload
  # updateSocialMedia updates an existing social media item for a Channel.
  updateSocialMedia(input: UpdateSocialMediaInput!): UpdateSocialMediaPayload
  # updateSquadInvitePolicy allows a broadcaster to update their squad stream invite policy.
  updateSquadInvitePolicy(
    input: UpdateSquadInvitePolicyInput!
  ): UpdateSquadInvitePolicyPayload
  # updateSquadStream allows an owner of a squad stream to update the squad stream.
  updateSquadStream(input: UpdateSquadStreamInput!): UpdateSquadStreamPayload
  # updateStucco allows a user to update a stucco (that is currently not active).
  updateStucco(input: UpdateStuccoInput!): UpdateStuccoPayload
  # updateStuccoPack allows the updating of a channel's stucco pack. (activating stuccos).
  updateStuccoPack(input: UpdateStuccoPackInput!): UpdateStuccoPackPayload
  # updateSubscriptionProduct allows a user to update their subscription product settings.
  updateSubscriptionProduct(
    input: UpdateSubscriptionProductInput!
  ): UpdateSubscriptionProductPayload
  # updateUser updates a user's displayname, description, email or delete a phone number.
  updateUser(input: UpdateUserInput!): UpdateUserPayload
  # Updates a user's creator colors.
  updateUserColors(input: UpdateUserColorsInput!): UpdateUserColorsPayload
  # Set a user's privacy preference for registration date.
  updateUserCreateDateHidden(
    input: UpdateUserCreateDateHiddenInput!
  ): UpdateUserCreateDateHiddenPayload
  # Set a user's directory hidden field.
  updateUserDirectoryHidden(
    input: UpdateUserDirectoryHiddenInput!
  ): UpdateUserDirectoryHiddenPayload
  # Set a user's email reuse field.
  updateUserEmailReusable(
    input: UpdateUserEmailReusableInput!
  ): UpdateUserEmailReusablePayload
  # updateUserIsEmailRevertSuccess sets/resets a user's Email revert success flag.
  updateUserIsEmailRevertSuccess(
    input: UpdateUserIsEmailRevertSuccessInput!
  ): UpdateUserIsEmailRevertSuccessPayload
  # Update a user's Prediction Settings.
  updateUserPredictionSettings(
    input: UpdateUserPredictionSettingsInput!
  ): UpdateUserPredictionSettingsPayload
  # updateUserSubscriptionSettings updates the subscription preferences for the authenticated user.
  updateUserSubscriptionSettings(
    input: UpdateUserSubscriptionSettingsInput!
  ): UpdateUserSubscriptionSettingsPayload
  # updateUserTeamMembership updates the team membership preferences for target user.
  updateUserTeamMembership(
    input: UpdateUserTeamMembershipInput!
  ): UpdateUserTeamMembershipPayload
  # updateUserVideoShelves adds/removes/reorders for a user's video shelves.
  updateUserVideoShelves(
    input: UpdateUserVideoShelvesInput!
  ): UpdateUserVideoShelvesPayload
  # updateUserViewedVideo updates a resume watching entry for a specified user and video.
  updateUserViewedVideo(
    input: UpdateUserViewedVideoInput!
  ): UpdateUserViewedVideoPayload
  # updateVideo updates a video identified by provided video ID.
  updateVideo(input: UpdateVideoInput!): UpdateVideoPayload
  # updateVideoComment updates a video comment identified by provided comment ID.
  updateVideoComment(input: UpdateVideoCommentInput!): UpdateVideoCommentPayload
  # updateVideoStreamSettings updates the broadcaster's video stream settings such as latency mode.
  updateVideoStreamSettings(
    input: UpdateVideoStreamSettingsInput!
  ): UpdateVideoStreamSettingsPayload
  # UpdateVideosViewability updates videos to being published or unpublished.
  updateVideosViewability(
    input: UpdateVideosViewabilityInput!
  ): UpdateVideosViewabilityPayload
  # Changes the user's visibility setting. This is an account-level setting that will cause the user's availability to
  # appear differently to other users, despite what sessions are reporting. See the VisibilityInput enum for details on
  # the effects of each value.
  #
  # Because this is an account-level setting, it should only be used in response to the user expressing clear intention
  # to change their visibility. Setting a status for an individual session should be done using setSessionStatus.
  updateVisibility(input: UpdateVisibilityInput!): UpdateVisibilityPayload
  # Updates Whisper settings for the authenticated user.
  updateWhisperSettings(
    input: UpdateWhisperSettingsInput!
  ): UpdateWhisperSettingsPayload
  # Updates a whisper thread.
  updateWhisperThread(
    input: UpdateWhisperThreadInput!
  ): UpdateWhisperThreadPayload
  # uploadCompetitionImage generates a url for a user to upload an image to for a competition.
  uploadCompetitionImage(
    input: UploadCompetitionImageInput!
  ): UploadCompetitionImagePayload
  # Uses a chat notification token.
  useChatNotificationToken(
    input: UseChatNotificationTokenInput!
  ): UseChatNotificationTokenPayload
  # validateVerificationCode validates a given code and sets the address to verified if it matches.
  validateVerificationCode(
    input: ValidateVerificationCodeInput!
  ): ValidateVerificationCodePayload
  # verifyContactMethod verifies a user contact method from an opaque ID.
  verifyContactMethod(
    input: VerifyContactMethodInput!
  ): VerifyContactMethodPayload
  # verifyOneTimePassword verifies a one time password for a user for authentication. Requires sudo authentication.
  verifyOneTimePassword(
    input: VerifyOneTimePasswordInput!
  ): VerifyOneTimePasswordPayload
  # verifyRewardedVideoEligibilityCaptcha verifies a users captcha with the rewarded video system.
  verifyRewardedVideoEligibilityCaptcha(
    input: VerifyRewardedVideoEligibilityCaptchaInput!
  ): VerifyRewardedVideoEligibilityCaptchaPayload
  # viewedNotifications updates when the authenticated user last saw onsite notifications.
  viewedNotifications: ViewedNotificationsPayload
  # visitStreamManager updates when the authenticated user visits their stream manager for the first time.
  visitStreamManager(input: VisitStreamManagerInput!): VisitStreamManagerPayload
  # Casts a vote for a specific choice in an ad poll.
  voteInAdPoll(input: VoteInAdPollInput!): VoteInAdPollPayload
  # Casts a vote for a specific choice in a poll.
  voteInPoll(input: VoteInPollInput!): VoteInPollPayload
  # Casts a vote for a specific choice in a poll, by index and channelID.
  voteInPollByChoiceIndex(
    input: VoteInPollByChoiceIndexInput!
  ): VoteInPollByChoiceIndexPayload
}

# GDPR cookie vendors for vendors that dont support TCF strings, for a user.
type NonTCFCookieVendor {
  # User content status for each vendor.
  consentStatus: ConsentStatus!
  # If itâ€™s an advertising, analytics, or essential cookie.
  cookieVendorType: CookieVendorType!
  # A flag that shows if the consent is given by the user or by consent service as default value.
  hasUserSetConsent: Boolean!
  # A flag that shows if the vendor should be visible to management page.
  isVisible: Boolean!
  # Vendor name.
  name: VendorName!
  # Url to the Vendor's privacy policy.
  policyURL: String!
}

# Information about a registered developer OAuth application.
type OAuthApp {
  # The category that describes the app's type.
  category: OAuthAppCategory
  # The timestamp when the app was created.
  createdAt: Time!
  # The ID of the app. It is the value of the `Client-ID` header when the app makes API requests.
  id: ID!
  # The name of the app.
  name: String!
  # The user-provided description of the app's type. Used if `Category` is Other.
  otherDescription: String
  # Owner is the user that owns this app.
  owner: User
  # The URI to which users should be redirected after authorizing the app.
  redirectURI: String!
  # The client secret of the app.
  secret: String!
  # The timestamp when the app was last updated.
  updatedAt: Time!
  # Whether the app's OAuth tokens expire.
  willTokensExpire: Boolean!
}

# Possible categories of developer apps.
enum OAuthAppCategory {
  # Game integration category.
  GAME_INTEGRATION
  # Website integration category.
  WEBSITE_INTEGRATION
  # Application integration category.
  APPLICATION_INTEGRATION
  # Browser extension category.
  BROWSER_EXTENSION
  # Broadcaster suite category.
  BROADCASTER_SUITE
  # Chat bot category.
  CHAT_BOT
  # Giveaway loyalty tool category.
  GIVEAWAY_LOYALTY_TOOL
  # Analytics tool category.
  ANALYTICS_TOOL
  # Category for when the other categories do not describe.
  OTHER
}

# A list of applications.
type OAuthAppConnection {
  # The applications.
  edges: [OAuthAppEdge!]!
  # Pagination.
  pageInfo: PageInfo!
}

# A broadcaster user with cursor.
type OAuthAppEdge {
  # Cursor represents the position of the current edge/node.
  cursor: Cursor!
  # Node represents the app for the current edge.
  node: OAuthApp!
}

# OEmbed is a universal spec converted to GraphQL from http://oembed.com/.
interface OEmbed {
  authorName: String
  authorURL: String
  cacheAge: Int
  # The inputURL is the URL that we are trying to resolve via oEmbed.  It is not part
  # of the official spec, but GQL implementations practically need to use it.
  inputURL: String!
  providerName: String
  providerURL: String
  # The description of thumbnail from the oembed spec fits with an optional thumbnail
  # type with required parameters.
  thumbnail: ThumbnailOEmbed
  title: String
  type: String!
  version: String!
}

# Offer describes something that is purchasable.
type Offer {
  # Details of the user's eligibility to purchase the Offer.
  eligibility: OfferEligibility!
  # The time at which this Offer ceases to be valid for purchase. If null, this Offer will never expire.
  endAt: Time
  # The type of the gift offer (will be omitted if the Offer is not a gift).
  giftType: GiftType
  # Unique identifier for an Offer.
  id: ID!
  # A listing describing the charge model and cancellation policy for the Offer.
  listing: OfferListing
  # The platform on which the Offer is eligible for purchase.
  platform: OfferPlatform!
  # A Promotion object describes the promotion to be applied on an Offer (if any).
  promotion: OfferPromotion
  # Quantity is the configured purchase quantity restrictions.
  quantity: Range
  # The authenticated user's relationship with the Offer.
  self: OfferSelfEdge
  # The time at which this Offer becomes valid for purchase.
  startAt: Time!
  # Tag bindings provide static and dynamic bindings of the attributes on an Offer.
  tagBindings: [OfferTagBinding!]!
  # Tenant product line registry to which this Offer belongs.
  tplr: String!
}

# Contains an offer ID and offer status.
input OfferAndStatus {
  # Unique Identifier for an offer.
  offerID: ID!
  # The status to set the offer to for the specified user.
  status: String!
}

# Deliver method type for Prime Offers entitlements.
enum OfferDeliveryMethod {
  # The entitlement will be delivered as a claim code, which can be used to get the entitlement.
  CLAIM_CODE
  # The entitlement will be directly delivered.
  DIRECT_ENTITLEMENT
  # The entitlement will be directly delivered and a Twitch account is not needed for the offer.
  SES_ENTITLEMENT
  # Misspelling of EXTERNAL_OFFER.
  EXTERNAL @deprecated(reason: "Use EXTERNAL_OFFER instead")
  # The entitlement will be delivered via external means.
  EXTERNAL_OFFER
}

# OfferEligibility describes user's eligibility to purchase an Offer.
type OfferEligibility {
  # If the user is eligible for the Offer, then this is set to the
  # time at which the user's benefits would expire if the
  # Offer is purchased. If null, the benefits never expire.
  benefitsEndAt: Time
  # If the user is eligible for the Offer, then this is set to the
  # time at which the user's benefits would become available if the
  # Offer is purchased.
  benefitsStartAt: Time
  # A boolean that is true when the user is eligible for the Offer.
  isEligible: Boolean!
  # Allows tenants to override the maximum purchasable quantity for an offer
  # within a checkout session (used in purchase velocity cases).
  maxQuantityOverride: Int
  # Provides extra contextual details for the type of purchase.
  purchaseType: OfferPurchaseType!
  # If the user is ineligible for the Offer, then this code is set
  # as the reason why the user is ineligible.
  reasonCode: OfferIneligibilityReasonCode
}

# OfferIneligibilityReasonCode indicates why a user isn't eligible.
enum OfferIneligibilityReasonCode {
  # Not eligible because the user has already purchased this offer.
  ALREADY_PURCHASED
  # Not eligible because something about the transaction could not be verified.
  COULD_NOT_VERIFY
  # Offer would exceed user's max token balance.
  MAX_TOKEN_BALANCE
  # No ineligibility reason was given.
  NONE
  # The reason for ineligibility could not be resolved.
  OTHER
}

# OfferListing defines the charge model for a given listing.
type OfferListing {
  # The conditions around a user's cancellation of their purchase (e.g. refund policy).
  cancellationPolicy: CancellationPolicyType!
  # FIAT/non-FIAT based charge model OR 3P managed SKU.
  chargeModel: ChargeModel!
}

# The platform on which the Offer is valid.
enum OfferPlatform {
  # The web site.
  WEB
  # The iOS app.
  IOS
  # The Android app.
  ANDROID
  # The desktop app.
  DESKTOP
}

# Promotion is a modifier to an Offer.
type OfferPromotion {
  # End time of a promotion (empty if evergreen promotion).
  endAt: Time
  # Unique identifier for a Promotion.
  id: ID!
  # The OfferListing associated with this Promotion.
  listing: OfferListing!
    @deprecated(
      reason: "No longer used, currently left for backwards compatibility"
    )
  # Unique name for a Promotion.
  name: String!
  # Describes the priority of the Promotion (the higher the priorty, the more important the promo).
  priority: Int!
  # Describe the Promotions metadata to display to the client.
  promoDisplay: PromotionDisplay!
  # Start time of a promotion.
  startAt: Time!
}

# OfferPUrchaseType provides extra contextual details for the type of purchase.
enum OfferPurchaseType {
  # This offer is a default, standard purchase.
  DEFAULT_PURCHASE
  # This offer being purchased will be a tier upgrade from their current active tier.
  UPGRADE_RECURRING_SUB_TIER
  # This offer being purchased will be a tier downgrade from their current active tier.
  DOWNGRADE_RECURRING_SUB_TIER
  # This offer being purchased is future-dated.
  FUTURE_PURCHASE
}

# The authenticated user's relationship with the offer.
type OfferSelfEdge {
  # Returns any fraud-related checkout actions that the client must invoke.
  checkoutActions(
    quantity: Int!
    paymentSession: PaymentSession
  ): [CheckoutAction!]
  # Configs that initiate the user's checkout flow for this Offer.
  checkoutConfiguration: CheckoutConfiguration
  # Provides a list of eligible payment methods that the user can select for this offer.
  eligiblePaymentMethods: [EligiblePaymentMethod!]
}

# Enum indicating the current live state of a given Prime Gaming content offer.
enum OfferState {
  # The offer is no longer live and has expired.
  EXPIRED
  # The offer is currently live.
  LIVE
  # The offer will be live in the future.
  FUTURE
}

# Enum indicating the visual status of the offer to the user.
enum OfferStatus {
  # The user has not seen this offer card on the Crown.
  UNSEEN
  # The user has seen this offer card on the Crown.
  SEEN
  # The user has claimed this offer.
  CLAIMED
  # The user has dismissed this offer card from the Crown and can no longer see it.
  DISMISSED
  # A previous SEEN or DISMISSED status has been overridden to allow the offer card to be visible on the Crown.
  OVERRIDDEN
  # The user's offer status is in a errored state.
  ERROR
}

# OfferTagBinding defines a key-value pair.
type OfferTagBinding {
  # The key of the tag.
  key: String!
  # The value of the tag.
  value: String!
}

# OfferTagBindingInput defines a key-value pair.
input OfferTagBindingInput {
  # The key of the tag.
  key: String!
  # The value of the tag.
  value: String!
}

# Current state of the user in the onboarding process.
type Onboarding {
  # Retrieves a list of streams that have been selected for onboarding based on a user's followed games.
  # `first` is the number of streams PER FOLLOWED GAME to fetch.
  # `locale` is a language code that will filter streams by if there are viewers
  # with that language code (ex. "en-US", "es-ES", or "de-AT").
  # `languages` is list of language codes that will be used to filter streams by the broadcaster language. (ex. [EN, KO]).
  # `games` are a list of game ids that would replace the user's followed games for fetching the streams.
  onboardingStreams(
    first: Int = 3
    locale: String
    languages: [Language!]
    games: [String!]
  ): [Stream] @deprecated(reason: "This feature has been sunset.")
  # List of channel IDs skipped by a user during onboarding.
  skippedChannelIDs: [ID!] @deprecated(reason: "This feature is retired")
}

type OnsiteNotification {
  # Actions of the notification.
  actions: [OnsiteNotificationAction!]!
  # Body of the notification in Markdown format.
  body: String!
  # Category of the notification (only for dart ones).
  category: String
  # When this notification was created.
  createdAt: Time!
  # List of users that created this notification.
  creators: [User]!
  # Destination type to route users to when they interact with the notification on non-web clients.
  # Values include Homepage, ChannelPage, NotificationSettingsPage, and BroadcasterDashboard.
  destinationType: String
  # Determines where the notification will be displayed at front end.
  displayType: OnsiteNotificationDisplayType!
  # Optional extra notification content.
  # When type is "vodupload", extra is Video.
  # When type is "hotclipfollower", extra is Clip.
  # When type is "hotclip", extra is Clip.
  # When type is "subgiftreceived", extra is User.
  # When type is "vodcomment", extra is VideoComment.
  # When type is "vodcommentmod", extra is VideoComment.
  # When type is "vodcommentreply", extra is VideoComment.
  # When destination is "ChannelPage", extra is User.
  # When destination is "BrowseGame", extra is Game.
  # When destination is "ExternalLink", extra is OnsiteNotificationExternalLink.
  extra: OnsiteNotificationContent
  # ID of the notification.
  id: ID!
  # Whether this notification is read.
  isRead: Boolean!
  # Type of onsite render style.
  renderStyle: OnsiteNotificationRenderStyle!
  # A URL to a thumbnail image.
  thumbnailURL: String!
  # Type of notification.
  type: String!
  # When notification was last updated.
  updatedAt: Time!
}

type OnsiteNotificationAction {
  # Body of the notification action in plain text.
  body: String!
  # ID of the action.
  id: ID!
  # Label of the action.
  label: String!
  # ID of the modal that will open on click, if it is a modal CTA.
  modalID: ID!
  # Type of the notification action.
  type: String!
  # URL of the notification action.
  url: String!
}

type OnsiteNotificationConnection {
  # List of notifications.
  edges: [OnsiteNotificationEdge!]
  # Information about pagination in this connection.
  pageInfo: PageInfo
  # Notifications summary.
  summary: OnsiteNotificationsSummary
}

# Extra onsite notification content.
union OnsiteNotificationContent =
    Clip
  | Game
  | OnsiteNotificationExternalLink
  | User
  | Video
  | VideoComment
# Determines where the notification will be displayed at front end.
enum OnsiteNotificationDisplayType {
  # Notifications that will be displayed in the "My Twitch" tab.
  VIEWER
  # Notifications that will be displayed in the "My Channel" tab.
  CREATOR
}

type OnsiteNotificationEdge {
  # Opaque cursor describing this edge's position in the paginated list.
  cursor: Cursor
  # The notification.
  node: OnsiteNotification!
}

# Extra onsite notification content returned when the notification links to an external site.
type OnsiteNotificationExternalLink {
  # The link that the notification opens when clicked.
  url: String!
}

# Used to determine how to render the onsite notification.
enum OnsiteNotificationRenderStyle {
  # The default render style with no buttons and a single click CTA.
  DEFAULT
  # Rendered with two CTA buttons.
  TWO_BUTTONS
}

# Capabilities that a mobile client has for displaying onsite notifications.
enum OnsiteNotificationsCapability {
  # Mobile destination type Homepage.
  HOMEPAGE
  # Mobile destination type ChannelPage.
  CHANNEL_PAGE
  # Mobile destination type NotificationSettingsPage.
  NOTIFICATION_SETTINGS_PAGE
  # Mobile destination type BroadcasterDashboard.
  BROADCASTER_DASHBOARD
  # Mobile destination type BrowseGame.
  BROWSE_GAME
  # Mobile destination type ExternalLink.
  EXTERNAL_LINK
  # Mobile destination type WebOnly.
  WEB_ONLY
  # Mobile destination type WhisperThread.
  WHISPER_THREAD
  # Mobile destination type FriendRequest.
  FRIEND_REQUEST
  # Pushy notification type hotclip.
  HOT_CLIP
  # Pushy notification type hotclipfollower.
  HOT_CLIP_FOLLOWER
  # Pushy notification type vodupload.
  VOD_UPLOAD
  # Pushy notification type vodcomment.
  VOD_COMMENT
  # Pushy notification type vodcommentmod.
  VOD_COMMENT_MOD
  # Pushy notification type vodcommentreply.
  VOD_COMMENT_REPLY
  # Pushy notification type subgiftreceived.
  SUB_GIFT_RECEIVED
  # Pushy notification type dropsavailable.
  DROPS_AVAILABLE
  # Pushy notification type communityguidelineschange.
  COMMUNITY_GUIDELINES_CHANGE
  # Pushy notification type smartannouncement.
  SMART_ANNOUNCEMENT
  # Pushy notification type affiliateinvite.
  AFFILIATE_INVITE
}

type OnsiteNotificationsSummary {
  # Unread summary for creator display type.
  creatorUnreadSummary: OnsiteNotificationsUnreadSummary
  # Last time notifications were seen.
  lastSeenAt: Time
  # Number of unseen notifications.
  unseenCount: Int!
  # Unread summary for viewer display type.
  viewerUnreadSummary: OnsiteNotificationsUnreadSummary
}

# Contains summary for unread infomation.
type OnsiteNotificationsUnreadSummary {
  # Last time user marked all as read.
  lastReadAllAt: Time
  # Number of unread notifications.
  unreadCount: Int!
}

input OrderPanelsInput {
  ids: [ID!]!
}

type OrderPanelsPayload {
  # List of panels in their new order.
  panels: [Panel]
}

# A developer organization.
type Organization {
  # The bounty board campaigns that the company owns.
  bountyCampaigns(
    campaignID: ID
    status: BountyCampaignStatus
  ): BountyCampaignConnection
  # The brand portal settings for the company.
  brandPortalSettings: BrandPortalSettings
  # ID of the Company in the CurseForge Infrastructure.
  curseCompanyID: ID
  # Drop Campaigns developed by the organization.
  dropCampaigns: [DropCampaign!]
    @deprecated(reason: "Use Organization.drops instead")
  # Drop 2.0 Campaigns and Benefits configured for the organization.
  drops: OrganizationDrops!
  # The estimated viewer reach for the pool of broadcasters this company is considering targeting.
  estimatedBroadcasterViewerReach(
    gameNames: [String!]!
    targetAllBroadcasters: Boolean!
    targetVarietyBroadcasters: Boolean!
    streamLengthSeconds: Int
    targetAllCountries: Boolean = false
    targetAllGames: Boolean = false
    countries: [String!] = []
  ): BroadcasterViewerReach
  # The games associated with the company. Optionally include games that a company can use for Bounty Board
  # campaigns (ie. "Just Chatting" for trailer campaigns).
  games(includeBountyBoardGames: Boolean = false): [Game!]
  # The company's unique identifier.
  id: ID!
  # List of pending invites.
  invites(first: Int = 10, after: Cursor): OrganizationInviteConnection
  # Legacy Companies need to agree to the Drops Terms.
  isCampaignsEnabled: Boolean!
  # Legacy Companies are required to sign the Contract.
  isContractSigned: Boolean!
  # Indicates if the Company is a Legacy Company from the first iteration of the DevSite.
  isLegacy: Boolean!
  # A list of rbac users who are apart of an organization.
  members(
    first: Int = 10
    after: Cursor
    input: OrganizationMembersInput
  ): OrganizationMemberConnection
  # The human-readable name of the company.
  name: String!
  # Attributes related to the current user.
  self: OrganizationSelfEdge
  # Indicates if company is a developer, publisher or other.
  type: OrganizationType!
  # The Company URL for their Corporate Website.
  url: String!
}

# Status of company applications.
enum OrganizationAppilcationStatus {
  # Application is pending.
  PENDING
  # Application has been rejected.
  REJECTED
  # Application has been approved.
  APPROVED
  # Application has been deleted.
  DELETED
}

# OrganizationApplication is the application for requesting an organization be added to Twitch Developer Organizations.
type OrganizationApplication {
  # Email of the person creating the application.
  # Deprecated as we are no longer collecting contact email. Using TwitchID and Dart to send notifications instead.
  contactEmail: String
    @deprecated(reason: "No longer collecting contact email.")
  # The name of applying organization.
  organizationName: String!
  # Current status of the company application.
  status: OrganizationAppilcationStatus!
}

# OrganizationDrop links organizations to the campaigns it has configured
# and the benefits that it has created.
type OrganizationDrops {
  # The benefits created for this organization that can be added to the organization's drops.
  benefits: [DropBenefit!]
  # The campaigns configued for this organizaiton.
  campaigns: [DropCampaign!]
}

# An invitation to join a developer organization under a given role.
type OrganizationInvite {
  # When the invitation was created.
  createdAt: Time!
  # The date and time the invite will expire.
  expiresAt: Time!
  # The invites's unique identifier.
  id: ID!
  # User the invitation if for.
  invitee: User
  # User who created the invitation.
  inviter: User
  # ID of the organization the invitation is for.
  organizationID: ID!
  # Name of the organization the invitation is for.
  organizationName: String!
  # Role the invitation is for.
  role: OrganizationMemberRole!
}

# Paginated list of organization invites in an organization.
type OrganizationInviteConnection {
  # The elements of the paginated list.
  edges: [OrganizationInviteEdge!]!
  # Information about this page.
  pageInfo: PageInfo!
  # The total number of Organization invites.
  totalCount: Int!
}

# An element in a paginated list of organization invites.
# Contains metadata about the organization invites.
type OrganizationInviteEdge {
  # An opaque cursor identifying the edge's position in the paginted list.
  cursor: Cursor!
  # The organization invite.
  node: OrganizationInvite!
}

# Paginated list of organization invites for in a user.
type OrganizationInviteUserConnection {
  # The elements of the paginated list.
  edges: [OrganizationInviteEdge!]!
  # Information about this page.
  pageInfo: PageInfo!
  # The total number of Organization invites.
  totalCount: Int!
  # Whether or not the user is under the limit of allowed organization memberships.
  isWithinOrganizationMembershipLimit: Boolean
}

# A RBAC user.
type OrganizationMember {
  # Users email.
  email: String!
  # Users first name.
  firstName: String!
  # Twitch user id.
  id: ID!
  # Users last name.
  lastName: String!
  # Users role.
  role: OrganizationMemberRole!
  # Users title.
  title: String!
  # The Twitch user associated with the RBAC user.
  user: User
}

# A paginated list of organization member relationships.
type OrganizationMemberConnection {
  # The elements of the paginated list.
  edges: [OrganizationMemberEdge!]!
  # Information about this page.
  pageInfo: PageInfo!
  # The total number of Organization members.
  totalCount: Int!
}

# An element in a paginated list of organization member relationships.
# Contains metadata about the follow relationship between two users.
type OrganizationMemberEdge {
  # An opaque cursor identifying the edge's position in the paginted list.
  cursor: Cursor!
  # Date user joined organization.
  joinedAt: Time!
  # The user who is organization members.
  node: OrganizationMember!
}

# Role for an organization member.
enum OrganizationMemberRole {
  # Adiministrator role.
  ADMINISTRATOR
  # Developer role.
  DEVELOPER
  # Manager role.
  MANAGER
  # Marketer role.
  MARKETER
  # Owner Role.
  OWNER
  # Billing Manager Role.
  BILLING_MANAGER
  # Shadow Account Role.
  SHADOW_ACCOUNT
}

# Parameters for filtering OrganizationMembers.
input OrganizationMembersInput {
  # Filter members with this role.
  role: OrganizationMemberRole
}

# The relationship between the authenticated user and a game.
type OrganizationSelfEdge {
  # Whether or not the current user is able to add another to the organization.
  canAddMember: Boolean!
  # Whether or not the current user is able to leave the organization.
  canLeaveOrganization: Boolean!
  # Whether or not the current user is able to remove a member from the organization.
  canRemoveMember: Boolean!
  # Date user joined organization.
  joinedAt: Time!
  # The current users role in the organization.
  role: OrganizationMemberRole!
}

# Type of work an organization does.
enum OrganizationType {
  # Organization that developes games.
  GAME_DEVELOPER
  # Organization that publishes games.
  GAME_PUBLISHER
  # Organization that does other work.
  OTHER
  # Organization that works in brands/advertsing.
  BRANDS_ADVERTISING
  # Organization that works with broadcaster tools.
  BROADCASTER_TOOLS
}

# Friend requests sent from this user to other users.
type OutgoingFriendRequestConnection {
  # The friend request elements of this list.
  edges: [OutgoingFriendRequestEdge!]
  # Information about this page.
  pageInfo: PageInfo!
  # The total number of outgoing friend requests.
  totalCount: Int!
}

# A friend request sent from this user to another user.
type OutgoingFriendRequestEdge {
  # The time at which the friend request was sent.
  createdAt: Time!
  # An opaque cursor identifying the edge's position in the paginated list.
  cursor: Cursor!
  # The user to whom the friend request was sent.
  node: User
}

# Contains Overwatch League Team preferences.
type OverwatchLeagueTeamPreference {
  # Set of available teams for selection.
  availableTeamsSet: [OverwatchTeamPreferenceOption!]
  # Unique identifier for this set of Overwatch team preferences.
  id: ID!
  # The preferred team.
  selectedTeam: OverwatchTeamPreferenceOption
}

# Moment Details specific to the overwatch game.
type OverwatchMomentDetails {
  # One of "game_start" or "hero_change".
  event: String!
  # The hero the broadcaster is playing.
  heroName: String!
  # The role the broadcaster is playing.
  role: String!
}

# Contains an Overwatch team option to choose as the preferred team.
type OverwatchTeamPreferenceOption {
  # Unique identifier for this Overwatch team preference.
  id: ID!
  # The rewards associated with this team preference.
  rewards: [TournamentReward!]
  # The name of the team.
  teamName: String!
}

# OwnerChanletAttributes store configuration flags for child chanlets the channel owns.
type OwnerChanletAttributes {
  # Whether to show the child chanlets.
  isChanletFeatureEnabled: Boolean!
}

# PageInfo is a special field which contains information about the page,
# specifically the cursors which the page starts and ends, and whether or
# not the client can forward-paginate or backward-paginate.
#
# This is part of the Relay Cursor Connections Specification:
# https://facebook.github.io/relay/graphql/connections.htm.
type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
}

# Data about a paid upgrade for a subscription.
# ie. a user upgrades a 1-month gift to a recurring subscription.
type PaidUpgrade {
  # The id of the paid upgrade purchase. Used to cancel the paid upgrade.
  originID: ID!
  # The formatted price of the paid upgrade in USD.
  price: String! @deprecated(reason: "Transitioning to priceInfo instead")
  # PriceInfo holds the paid upgrade's pricing information such as currency, cost, and tax information.
  priceInfo(taxCountry: String): PriceInfo!
  # The date the paid upgrade begins.
  startsAt: Time!
  # Tier of upgraded product.
  tier: String!
}

# Panel is information about a single info panel for a channel.
interface Panel {
  # id is a unique identifier for the panel.
  id: ID!
  # type is the kind of panel.
  type: PanelType!
}

# The required configuration to activate a panel extension.
input PanelActivationInput {
  # The slot name of where the component extension should be displayed.
  slot: String!
}

# PanelType is the kind of panel.
enum PanelType {
  # DEFAULT panels contain one or more of the content values in `Panel` to display.
  DEFAULT
  # EXTENSION panels are placeholders for extension content.
  EXTENSION
}

# PanelView holds the view configuration of an extension if the panel anchor is supported.
type PanelView implements ExtensionView {
  # Specifies whether or not the extension has the ability to link to external websites.
  canLinkExternalContent: Boolean!
  # The extension developer configured height of the panel extension.
  height: Int!
  # Relative path of the HTML file to load for this view, used by devsite to specify the layout of assets.
  viewerPath: String!
  # The URL which should be loaded in for the extension.
  viewerURL: String!
}

# PanelViewInput holds the view configuration of an extension if the panel anchor is supported.
input PanelViewInput {
  # The extension developer configured height of the panel extension.
  height: Int!
  # Relative path of the HTML file to load for this view.
  viewerPath: String!
}

# DEPRECATED.
type Partnership {
  isPartner: Boolean @deprecated
}

# PartnershipApplication is a submitted partnership application.
type PartnershipApplication {
  # ID of the user that submitted the application,
  # provided purely for the convenience of invalidating GraphQL client caches.
  id: ID!
  # A submitted application currently can only be unresolved or resolved:
  #
  # - A null resolvedAt timestamp means that the application is unresolved and may be under review.
  #
  # - A non-null resolvedAt means that the application has been resolved, either approved or rejected.
  #   A user with an approved application may now start the partnership on-boarding flow.
  resolvedAt: Time
}

# PasswordStatus determines the current state of the users password.
enum PasswordStatus {
  # The users password has never been evaluated.
  NOT_EVALUATED
  # The users password meets requirements.
  VALID
  # The users password does not meet requirements.
  INVALID
  # Unknown password status.
  UNKNOWN
}

# Associated metrics for the "Path to Affiliate" quest.
type PathToAffiliate {
  # Average viewers needed to complete the quest.
  averageViewers: QuestGoalFloat
  # Image URL for the quest's badge.
  badgeURL: String
  # Time that this quest was completed.
  completedAt: Time
  # Number of followers needed to complete the quest. Evaluated at a 6 month
  # period. All other metrics are evaluated in 30 day periods.
  followers: QuestGoalInt
  # Number of hours streamed needed to complete the quest.
  hoursStreamed: QuestGoalFloat
  # Number of unique days needed to complete the quest.
  uniqueDaysStreamed: QuestGoalInt
  # Current state of the user's affiliate invitation.
  affiliateInvitationStatus: AffiliateInvitationStatus
}

# Associated metrics for the "Path to Partner" quest.
type PathToPartner {
  # Average viewers needed to complete the quest.
  averageViewers: QuestGoalFloat
  # Image URL for the quest's badge.
  badgeURL: String
  # Time that this quest was completed.
  completedAt: Time
  # Number of hours streamed needed to complete the quest.
  hoursStreamed: QuestGoalFloat
  # Time period that's being evaluated for the metrics/goals.
  questEvaluationInterval: QuestEvaluationInterval
  # Number of unique days needed to complete the quest.
  uniqueDaysStreamed: QuestGoalInt
}

# Payout Status is the payout status of the creator for all non-earnings related issues.
type PayableStatus {
  # Whether or not the user is able to be paid out.
  isPayable: Boolean!
}

# Types of credit cards supported.
enum PaymentCardType {
  # Visa.
  VISA
  # Mastercard.
  MASTERCARD
  # American Express.
  AMERICAN_EXPRESS
  # Discover.
  DISCOVER
}

# A monthly rollup of metrics that are relevant to incentive-based contracts for
# some partnered streamers.
type PaymentIncentiveMetricsRollup {
  # A measure of how much advertising time broadcasters have during their live
  # streams.
  advertisingDensity: Float!
  # The number of live hours the user streamed for the month.
  liveHoursBroadcast: Float!
  # The number of live minutes watched for the month.
  liveMinutesWatched: Float!
  # The start time for the monthly rollup. These times are in the Pacific Time
  # Zone and the monthly rollups begin in this time zone. Rather than
  # converting to local time, clients should inform end users of this timing
  # quirk and perform custom parsing on these values to show the current year
  # and month in Pacific Time.
  timestamp: Time
  # The number of VOD minutes watched the user has for the month.
  vodMinutesWatched: Float!
}

# Payment instrument used through the payment provider.
enum PaymentInstrumentType {
  # Credit or debit card.
  CREDIT_CARD
  # Pay with Amazon.
  AMAZON
  # Pay with Paypal.
  PAYPAL
  # Pay with Google In-App Billing.
  GOOGLE_IAB
  # Pay with Apple In-App Purchase.
  APPLE_IAP
  # Xsolla only.
  SKRILL
  # Xsolla only.
  YANDEX
  # Xsolla only.
  WEBMONEY
  # Xsolla default.
  UNKNOWN
  # Pay with Wallet.
  WALLET
  # Pay with bank account.
  DIRECT_DEBIT
}

# Type of payment method a user has used to buy products on Twitch, such as subs.
type PaymentMethod {
  # Country (ISO-3166) associated to the billing info for the customer's payment method.
  billingCountry: String
  # Email associated with customer's Amazon/Paypal account.
  billingEmail: String
  # If payment type is card, then the type of card used is shown here.
  cardType: PaymentCardType
  # ID of the payment method that can be referenced by other systems.
  chargeInstrumentID: ID!
  # Credit card expiration month, if paymentType is CREDIT_CARD.
  expirationMonth: Int
  # Credit card expiration year, if paymentType is CREDIT_CARD.
  expirationYear: Int
  # External payment method ID (the ID recorded by the payment provider)
  # We can guarantee its uniqueness since it is external from our systems.
  extMethodID: ID
  # Whether or not payment method has restrictions.
  isRestricted: Boolean!
  # Credit card last four digits, if paymentType is CREDIT_CARD.
  lastFour: String
  # The payment scheme used by this payment method.
  paymentScheme: PaymentScheme
  # Payment type used via the payment provider.
  paymentType: PaymentInstrumentType!
  # One of the payment providers that Twitch currently supports.
  provider: PaymentProvider!
  # List of purchase profiles associated with this payment method.
  purchaseProfiles: [PurchaseProfile!]
  # List of recurring payments associated with this payment method.
  # New schema to eventually replace purchase profiles.
  recurringPaymentDetails: [RecurringPaymentDetail!]
}

# The list of availability statuses for a payment method.
enum PaymentMethodAvailabilityStatus {
  # Available status.
  AVAILABLE
  # Degraded status.
  DEGRADED
  # Full outage status.
  FULL_OUTAGE
}

# Type of payment providers.
enum PaymentProvider {
  # Unknown payment provider.
  UNKNOWN
  # (Deprecated) Paypal payment provider now a payment method provided by Recurly.
  PAYPAL
  # (Deprecated) Paypal payment provider.
  PAYPAL_RT
  # Recurly payment provider, allows payments with credit card, amazon, paypal.
  RECURLY
  # Xsolla payment provider, usually provides Iframe for users to go through checkout process.
  XSOLLA
  # (Deprecated) Xsolla payment provider, usually provides Iframe for users to go through checkout process.
  XSOLLA_V3
  # Zuora payment provider, supports credit card payments.
  ZUORA
  # Twitch Prime used to buy product on Twitch.
  PRIME
  # Google In-App Billing, for Android transactions.
  GOOGLE_IAB
  # Apple In-App Purchases for iOS transactions.
  APPLE_IAP
  # Sub tokens, which can be redeemed for channel subscriptions.
  SUB_TOKEN
}

type PaymentProviderConfigs {
  # Configs to initiate Recurly library for the user for purchase checkout or payment method update.
  recurly: RecurlyConfigs!
  # Xsolla configs include the iframe URL for purchase checkout or payment method update.
  xsolla: XsollaConfigs!
  # Configs for initiating Zuora credit card payments or payment method update.
  zuora: ZuoraConfigs!
}

# The payment scheme supported.
enum PaymentScheme {
  # SEPA.
  SEPA
  # BACS.
  BACS
}

# Inputs for PaymentSession.
input PaymentSession {
  # Payment's Tracking Checkout ID.
  checkoutSessionID: ID
  # User's device ID.
  deviceID: ID
  # Twilight's storage device ID.
  localStorageDeviceID: ID
  # Offer Session ID.
  offerSessionID: ID
  # Twilight's Page Session ID.
  pageSessionID: ID
  # Twilight's Tab Session ID.
  tabSessionID: ID
}

# There are legacy and new data sources that contain similar payment transaction data. This type aims to merge several
# data sources into one to expose a consistent payment history for each Twitch user.
type PaymentTransaction {
  # Currency for the price.
  currency: String
  # Price in smallest subunit for the currency, such as 499.
  grossAmount: Int
  # The divisor used to derive the gross amount.
  grossAmountDivisor: Int
  # Payment ID such as PPT321281 or POPT3278183712.
  id: ID!
  # Whether this payment transaction was made to purchase a gift for someone else or not.
  isGift: Boolean!
  # The payment method that was used to generate this payment transaction.
  paymentMethod: PaymentMethod!
  # Payment transaction purchased product details.
  product: PaymentTransactionProduct!
  # PurchaseOrderID for the payment.
  purchaseOrderID: ID
  # Time the purchase payment was recognized at.
  purchasedAt: Time!
  # Quantity of the purchase.
  quantity: Int!
  # The recipient Twitch user of the product purchased by the payment transaction, if applicable.
  recipient: User
}

# A paginated list of payment transactions, and its metadata.
type PaymentTransactionConnection {
  # The list of payment transactions on this page.
  edges: [PaymentTransactionEdge!]
  # The payment date of the earliest PaymentTransaction among all possible pages.
  firstPurchasedAt: Time
  # The payment date of the latest PaymentTransaction among all possible pages.
  lastPurchasedAt: Time
  # Information about this page of payment transactions.
  pageInfo: PageInfo!
  # The total number of payment transactions in the overall collection.
  totalCount: Int
}

# Filter and sorting options for querying all transactions for a Twitch purchaser.
input PaymentTransactionConnectionCriteriaInput {
  # Only show transactions purchased after this date.
  purchasedAfter: Time
  # Only show transactions purchased before this date.
  purchasedBefore: Time
  # Sort transactions by... defaults to date desc.
  sortBy: PaymentTransactionSort = PURCHASE_DATE_DESC
  # Only show transactions that purchased products of a certain type, defaults to ALL.
  type: PaymentTransactionTypeFilter = ALL
  # Purchaser ID.
  userID: ID!
}

# An element in a paginated list of payment transactions, and its metadata.
type PaymentTransactionEdge {
  # Offset acting as a cursor.
  cursor: Cursor!
  # The element node.
  node: PaymentTransaction
}

# Payment transaction purchased product details.
type PaymentTransactionProduct {
  # Number of digital goods wrapped into a product.
  bundleSize: Int!
  # The name of the product.
  name: String!
  # Some products have owners. For example, the owner of the `Lirik - Tier 1 Subscription` product is Lirik.
  owner: User
  # Some products have tiers, such as subs.
  tier: String
  # What type of product the payment was made for.
  type: PaymentTransactionType!
}

# Possible sort orders for lists of payment transactions.
enum PaymentTransactionSort {
  # Sort the payment transactions descending by price.
  PRICE_DESC
  # Sort the payment transactions ascending by price.
  PRICE_ASC
  # Sort by purchase date descending.
  PURCHASE_DATE_DESC
  # Sort by purchase date ascending.
  PURCHASE_DATE_ASC
}

# Payment transaction type.
enum PaymentTransactionType {
  # Transaction for a subscription type.
  SUBSCRIPTION
  # Transaction for a bits type.
  BITS
  # Transaction for a sub token.
  SUB_TOKEN
  # Transaction for gift cards.
  GIFT_CARD
  # Transaction for celebration.
  CELEBRATION
  # Transaction for an unknown type.
  UNKNOWN
}

# Select the kind of transactions.
enum PaymentTransactionTypeFilter {
  # Only return payment transactions that associated with subscription products.
  SUBSCRIPTIONS
  # Only return payment transactions that are associated with subtoken purchases and redemptions.
  SUB_TOKEN
  # The default filter (no filter).
  ALL
}

# Payout Information.
type Payout {
  # Payout History Information.
  history: PayoutHistory
}

# Payout Balance is the amount accrued by the user since their last Payout.
type PayoutBalance {
  # Currency for the user.
  currency: String!
  # Amount of total earnings accrued since last payout for user.
  currentPayoutBalanceAmount: Float!
  # Month for the current payout balance.
  month: Int!
  # Year for the current payout balance.
  year: Int!
}

# Enumerates valid payout categories.
enum PayoutCategory {
  # Assigned if the user has a payout plan for the affiliate program.
  AFFILIATE
  # Assigned if the user has a payout plan for the extensions developer program.
  EXTENSIONS_DEVELOPER
  # Assigned if the user has a payout plan for the partner program.
  PARTNER
}

# Payout History Information.
type PayoutHistory {
  # Url for Tipalti payout history iframe.
  iframeURL: String
}

# PayoutInvite describes a user's invite to a payout program.
type PayoutInvite {
  # The payout program category the user has been invited to.
  category: PayoutOnboardingCategory
  # A PayoutInvite's unique ID.
  id: ID!
  # Whether or not this payout invite is for the affiliate program.
  isForAffiliate: Boolean!
  # Whether or not this payout invite is for the extensions developer program.
  isForExtensionsDeveloper: Boolean!
  # Whether or not this payout invite is for the partner program.
  isForPartner: Boolean!
  # Whether or not the payout invite was created through the legacy onboarding flow.
  isLegacy: Boolean!
  # The payout onboarding workflow for this payout invite.
  workflow: PayoutOnboardingWorkflow
}

# PayoutOnboardingCategory enumerates valid categories for payout onboarding.
enum PayoutOnboardingCategory {
  # Assigned for payout onboarding flows to enroll a user into the affiliate program.
  AFFILIATE
  # Assigned for payout onboarding flows to enroll a user into the partner program with the "standard" payout plan.
  STANDARD_PARTNER
  # Assigned for payout onboarding flows to enroll a user into the partner program with the "premium" payout plan.
  PREMIUM_PARTNER
  # Assigned for payout onboarding flows to enroll a user into the partner program with a "custom" payout plan.
  CUSTOM_PARTNER
  # Assigned for payout onboarding flows to enroll a user into the extensions developer program.
  EXTENSIONS_DEVELOPER
  # Assigned for payout onboarding flows to enroll a user into an unpaid partner program.
  UNPAID_PARTNER
}

# PayoutOnboardingStep enumerates valid payout onboarding steps.
enum PayoutOnboardingStep {
  # User needs to complete their registration step.
  REGISTRATION_NOT_STARTED
  # User needs to agree to their payout agreement.
  AGREEMENT_NOT_STARTED
  # User needs to submit their royalty tax interview.
  ROYALTY_TAX_INTERVIEW_NOT_STARTED
  # User submitted their royalty tax interview and is waiting for it to be accepted.
  ROYALTY_TAX_INTERVIEW_PENDING
  # User submitted their royalty tax interview but additional action by the user is required before completion.
  ROYALTY_TAX_INTERVIEW_ACTION_REQUIRED
  # User submitted their royalty tax interview and received mismatch errors.
  ROYALTY_TAX_INTERVIEW_MISMATCH
  # User submitted their royalty tax interview and received errors while it was processed.
  ROYALTY_TAX_INTERVIEW_FAILED
  # User has completed their royalty tax interview and needs to complete their service tax interview.
  SERVICE_TAX_INTERVIEW_NOT_STARTED
  # User submitted their service tax interview and is waiting for it to be accepted.
  SERVICE_TAX_INTERVIEW_PENDING
  # User submitted their service tax interview but additional action by the user is required before completion.
  SERVICE_TAX_INTERVIEW_ACTION_REQUIRED
  # User submitted their service tax interview and received mismatch errors.
  SERVICE_TAX_INTERVIEW_MISMATCH
  # User submitted their service tax interview and received errors while it was processed.
  SERVICE_TAX_INTERVIEW_FAILED
  # User neeeds to setup how they want to get paid out.
  PAYOUT_METHOD_NOT_STARTED
  # User submitted their payout method and is waiting for it to be accepted.
  PAYOUT_METHOD_PENDING
  # User is waiting for a final approval from the payout onboarding reviewers.
  REVIEW_PENDING
  # User has completed their payout onboarding.
  COMPLETED
  # User has canceled their payout onboarding workflow.
  CANCELED
  # User has a pending upgrade to their payout agreement.
  AGREEMENT_PENDING_UPGRADE
}

# PayoutOnboardingWorkflow describes the workflow details while a user is onboarding into a payout program.
type PayoutOnboardingWorkflow {
  # The current step at which this workflow is at.
  currentStep: PayoutOnboardingStep!
  # A PayoutOnboardingWorkflow's unique ID.
  id: ID!
  # The URL for a user to update their payout settings. A redirectURL is the URL
  # where the user will be redirected to after updating their payout settings.
  payoutSettingsURL(redirectURL: String): String!
  # The registration information submitted by the user for this workflow.
  registration: PayoutRegistration
  # Describes a user's tax interview information while completing their payout onboarding.
  taxInterview(type: TaxInterviewType!, returnURL: String!): TaxInterview
  # Lists the fields that were mismatched during the registration and tax interview steps.
  taxMismatchErrors: [TaxMismatchError!]
  # The timestamp when the workflow was most recently updated.
  timestamp: Time!
}

# Describes the payout plan a user has when enrolled into a payout program.
type PayoutPlan {
  # The category applied for this payout plan.
  category: PayoutCategory!
  # Describes whether or not this payout plan is receiving revenue.
  isReceivingRevenue: Boolean!
  # Lists tags to further describe this type of payout plan.
  tags: [PayoutPlanTag!]
}

# Enumerates valid payout plan tags.
enum PayoutPlanTag {
  # Assigned if the user has the "standard" payout plan.
  STANDARD
  # Assigned if the user has the "premium" payout plan.
  PREMIUM
  # Assigned if the user has the "custom" payout plan.
  CUSTOM
  # Assigned if the user has a payout plan created through the legacy onboarding flow.
  LEGACY
  # Assigned if user has an esports payout plan. Twitch pays them lump sum when
  # they get rewarded from competing in a Twtich sponsored event.
  ESPORTS
}

# PayoutRegistration describes the personal information a user submitted while onboarding into a payout program.
type PayoutRegistration {
  # Birthdate submitted by the user while registering into a payout program.
  birthdate: Time!
  # City submitted by the user while registering into a payout program.
  city: String!
  # Company Name submitted by the user while registering into a payout program.
  companyName: String
  # Country Code (ISO-3166) submitted by the user while registering into a payout program.
  countryCode: String!
  # Email submitted by the user while registering into a payout program.
  email: String!
  # First Name submitted by the user while registering into a payout program.
  firstName: String!
  # Last Name submitted by the user while registering into a payout program.
  lastName: String!
  # Middle Name submitted by the user while registering into a payout program.
  middleName: String
  # Parent Email submitted by the under age user while registering into a payout program.
  parentEmail: String
  # Parent Name submitted by the under age user while registering into a payout program.
  parentName: String
  # Postal submitted by the user while registering into a payout program.
  postal: String
  # State Code submitted by the user while registering into a payout program.
  stateCode: String
  # Primary Address submitted by the user while registering into a payout program.
  streetAddress: String!
  # Secondary Address submitted by the user while registering into a payout program.
  streetAddress2: String
}

type PayWithAmazonConfigs {
  # Used to configure PWA gateway and identify requests to Amazon.
  clientID: ID!
  # Frontend only has access to production PWA environment so this helps QA.
  isProduction: Boolean!
  # Also known as merchant ID, which identifies the account accepting payments.
  sellerID: ID!
}

# Data about a pending future subscription.
# ie. a user turns a 1-month gift into a recurring subscription.
type PendingSubscription {
  # Whether the pending sub is cancelable.
  isCancelable: Boolean!
  # The id of the pending subscription purchase. Used to cancel the paid upgrade.
  originID: ID!
  # The formatted price of the pending subscription in USD.
  price: String! @deprecated(reason: "Transitioning to priceInfo instead")
  # PriceInfo holds the pending subscription's pricing information such as currency, cost, and tax information.
  priceInfo(taxCountry: String): PriceInfo!
  # The date the pending subscription begins.
  startsAt: Time!
  # Tier of pending subscription.
  tier: String!
  # The type of pending subscription. Ie GIFT_TO_PAID for a gift to paid conversion.
  type: PendingSubType!
}

# Denotes the type of pending subscription.
enum PendingSubType {
  # This pending subscription was a conversion from a gift sub to a paid sub.
  GIFT_TO_PAID
  # This pending subscription was a conversion from a DNRd sub to a renewing sub.
  DNR_TO_RESUB_RECURRING
  # This pending subscription was a conversion from a DNRd sub to a one month sub.
  DNR_TO_RESUB_NONRECURRING
  # This pending subscription was a conversion from a prime sub to a paid sub.
  PRIME_TO_PAID
}

# The permanent emote modifiers available to set.
enum PermanentEmoteModifier {
  # Unknown emote modifier.
  UNKNOWN
  # BlackWhite emote modifier.
  BLACK_WHITE
  # HorizontalFlip emote modifier.
  HORIZONTAL_FLIP
  # Sunglasses emote modifier.
  SUNGLASSES
  # Thinking emote modifier.
  THINKING
  # Squished emote modifier.
  SQUISHED
}

# Describes the section(follows, recommendation ...) for a current user in the navigation bar.
type PersonalSection {
  # Returns the list of contents in this section, nil if there is an error.
  items: [PersonalSectionItem!]
  # The localized title for the personal section.
  title: PersonalSectionTitle!
  # Describes the section (FOLLOWED, RECOMMENDED, POPULAR ...).
  type: PersonalSectionType!
}

# Describes the personal channel for the current user.
type PersonalSectionChannel {
  # Either live stream or vod depending on whether the stream in live.
  content: PersonalSectionChannelContent
  # Describes how to label channels, if a label is necessary.
  label: PersonalSectionChannelLabel!
  # Unique id per channel used in client tracking.
  trackingID: ID!
  # The channel (user object of channel).
  user: User
}

# Content metadata for either live stream or list of vod.
union PersonalSectionChannelContent = Stream | VideoConnection
# Describes how to label channels in combined sections. This enum is closely related
# to - but separate from - the PersonalSectionType enum. Some sections may not have labels
# and some labels may not have sections.
enum PersonalSectionChannelLabel {
  # Use no label.
  NONE
  # Use label for recommended channel.
  RECOMMENDED
  # Use label for similar channel.
  SIMILAR
  # Use label for followed channel.
  FOLLOWED
  # Use label for popular channel.
  POPULAR
}

# Input to personal section query.
input PersonalSectionInput {
  # Name of the channel the user is watching. Used to present similar channels.
  contextChannelName: String
  # Provides additional context used to influence recommendations.
  recommendationContext: RecommendationsContext
  # Requested sections eg: follows, recommendation, popular.
  sectionInputs: [PersonalSectionType!]!
}

# The types of content(channel, category ...) that can be contained in a PersonalSectionItem.
union PersonalSectionItem = PersonalSectionChannel
# A personal section token type that contains text.
type PersonalSectionTextToken {
  # The text to display for this token.
  value: String!
}

# The title for the personal section.
type PersonalSectionTitle {
  # The localizedFallback title, only to be used if localizedTokens is nil.
  localizedFallback: String!
  # The localized section title in the form of a list of tokens. [Maximum of 2 tokens].
  localizedTokens: [PersonalSectionTitleToken!]
}

# The content of a personal section title token.
union PersonalSectionTitleToken = PersonalSectionTextToken | User
# Describes the type in personal sections.
enum PersonalSectionType {
  # Returns the list of followed channels if the user is authenticated.
  FOLLOWED_SECTION
  # Returns the list of recommended channels.
  RECOMMENDED_SECTION
  # Returns the list of popular channels.
  POPULAR_SECTION
  # Returns the list of similar channels.
  SIMILAR_SECTION
}

# The phase state signifies the progress of the phase in the competition.
enum PhaseState {
  # No lobbies are currently actively playing in the phase.
  UNSTARTED
  # Some or all the lobbies in the phase are actively playing.
  PLAYING
  # All lobbies in the phase are done playing.
  FINISHED
  # Lobby state is unknown.
  UNKNOWN
}

type PhotoOEmbed implements OEmbed {
  authorName: String
  authorURL: String
  cacheAge: Int
  height: Int!
  inputURL: String!
  providerName: String
  providerURL: String
  thumbnail: ThumbnailOEmbed
  title: String
  type: String!
  url: String!
  version: String!
  width: Int!
}

# Stream Platform.
union Platform = PlayStation
type PlatformEventSetting {
  # Whether the setting is enabled for the given platform.
  isEnabled: Boolean!
  # The name of the platform. ("email", "push", etc..).
  platformName: String!
  # The exact state of the setting. ("on", "off", "friends_only", etc).
  settingState: String!
}

# Stream platform type.
enum PlatformType {
  all
  ps4
  xbox
}

# Access token that determines playback experience for a video.
type PlaybackAccessToken {
  # The signature of the token.
  signature: String!
  # Token that encodes information about the user's access to a video.
  value: String!
}

# Optional parameters to pass in when fetching a playback access token.
input PlaybackAccessTokenParams {
  # If the video should not be loaded over HTTPS.
  disableHTTPS: Boolean
  # If the user has adblock enabled.
  hasAdblock: Boolean
  # The platform the user is watching the video on.
  platform: String!
  # The player backend being used to serve video.
  playerBackend: String
  # The type of player the user is watching from.
  playerType: String!
}

type Playing implements Activity {
  # The game being played.
  game: Game
  # This activity's type, i.e. "PLAYING".
  type: ActivityType
}

# Stream metadata for PlayStation.
type PlayStation {
  platform: String
  title: SCETitle
  updatedAt: Time
  user: SCEUser
}

# A poll users can vote in.
type Poll {
  # A choice specified by a choice id.
  choice(id: ID!): PollChoice
  # A list of choices users can vote for.
  choices: [PollChoice!]!
  # User that created the poll.
  # Mods and editors can make polls on behalf of a broadcaster.
  createdBy: User
  # Amount of seconds from when the poll starts to when it ends.
  # Since a broadcaster can end a poll early ("terminate a poll"), it may be possible for endedAt - startedAt != duration.
  durationSeconds: Int!
  # Time when the poll ended.
  # Null if the poll is still active.
  endedAt: Time
  # User that ended the poll. Mods and editors can end polls on behalf of a broadcaster.
  # Null if no user manually ended the poll.
  endedBy: User
  # ID of poll.
  id: ID!
  # Whether the poll is viewable by other users.
  isViewable: Boolean!
  # User who owns this poll. The poll will appear on their channel.
  ownedBy: User
  # Amount of milliseconds before the poll ends.
  # 0 when the polls is ended.
  remainingDurationMilliseconds: Int!
  # The authenticated user's relationship with this poll.
  # Main use case is to check if the user has voted in the poll already.
  # Null if un-authenticated user is making this query.
  self: PollSelfEdge
  # A map of poll settings.
  settings: PollSettings!
  # Time when poll started.
  startedAt: Time!
  # The status of the poll.
  status: PollStatus!
  # Title of poll.
  title: String!
  # A breakdown of the different tokens used in this poll.
  tokens: PollTokenBreakdown!
  # The top Bits contributor for the poll.
  topBitsContributor: PollTopBitsContributor
  # The top Community Points contributor for the poll.
  topCommunityPointsContributor: PollTopCommunityPointsContributor
  # The top Bits contributor for the poll.
  topContributor: PollTopContributor
    @deprecated(reason: "Use topBitsContributor instead.")
  # Total number of unique voters that have voted in this poll.
  totalVoters: Int!
  # A breakdown of the different votes cast in this poll.
  votes: PollVoteBreakdown!
}

# A choice in a poll that users can vote for.
type PollChoice {
  # ID of choice.
  id: ID!
  # The authenticated user's relationship with this choice.
  self: PollChoiceSelfEdge!
  # The title of the choice.
  title: String!
  # A breakdown of the different tokens used for this choice.
  tokens: PollTokenBreakdown!
  # Total number of unique voters that have voted for this choice.
  totalVoters: Int!
  # A list of voters for this choice.
  # Only the poll's ownerID and their mods/editors can search for this.
  voters(
    first: Int = 15
    after: Cursor
    sort: PollVoterConnectionSort = VOTES
    direction: PollVoterConnectionSortDirection = DESC
  ): PollChoiceVoterConnection
  # A breakdown of the different votes cast for this choice.
  votes: PollVoteBreakdown!
}

# A connection between poll choice and the authenticated user.
type PollChoiceSelfEdge {
  # The voter object pertaining to the authenticated user.
  voter: PollVoter
}

# A connection between poll and voters and metadata.
type PollChoiceVoterConnection {
  # The list of voters in this poll / choice.
  nodes: [PollVoterConnectionEdge!]!
}

# A connection between poll and metadata.
type PollConnection {
  # The list of polls for the user.
  edges: [PollEdge!]
  # Information about pagination in this connection.
  pageInfo: PageInfo!
}

# A page entry, that contains the Poll item and a cursor to return from the query to allow pagination.
type PollEdge {
  # Cursor used for next query.
  cursor: Cursor!
  # The underlying poll voter.
  node: Poll!
}

# A connection between a poll and the authenticated user.
type PollSelfEdge {
  # The voter object pertaining to the authenticated user.
  voter: PollVoter
}

# Poll Settings.
type PollSettings {
  # Bits votes poll settings.
  bitsVotes: PollSettingsBitsVotes!
  # Channel Points votes poll settings.
  communityPointsVotes: PollSettingsCommunityPointsVotes!
  # ID of poll settings.
  id: ID!
  # Multichoice voting poll settings.
  multichoice: PollSettingsMultichoice!
  # Subscriber multiplier poll settings.
  subscriberMultiplier: PollSettingsSubscriberMultiplier!
    @deprecated(reason: "Subscriber multipliers are no longer supported.")
  # Subscriber only poll settings.
  subscriberOnly: PollSettingsSubscriberOnly!
    @deprecated(reason: "Subscriber-only polls are no longer supported.")
}

# Bits votes poll settings.
type PollSettingsBitsVotes {
  # Cost of bits for a vote.
  cost: Int!
  # Whether the poll allows for users to use bits for votes.
  isEnabled: Boolean!
}

# Channel Points votes poll settings.
type PollSettingsCommunityPointsVotes {
  # Cost of channel points for a vote.
  cost: Int!
  # Whether the poll allows for users to use channel points for votes.
  isEnabled: Boolean!
}

# Multichoice voting enabled poll setting.
type PollSettingsMultichoice {
  # Whether the poll has multichoice voting enabled.
  isEnabled: Boolean!
}

# Subscriber multiplier poll settings.
# Deprecated: subscriber multipliers are no longer supported.
type PollSettingsSubscriberMultiplier {
  # Whether the poll has a subscriber multipler.
  isEnabled: Boolean!
}

# Subscriber only poll settings.
# Deprecated: subscriber-only polls are no longer supported.
type PollSettingsSubscriberOnly {
  # Whether the poll is subscriber only.
  isEnabled: Boolean!
}

# Possible sort orders for lists of polls.
enum PollSort {
  # Sort the polls by time.
  START_TIME
}

# The status of the poll.
enum PollStatus {
  # Encountered some poll status that we do not know how to handle BibleThump.
  UNKNOWN
  # Poll is running. Users can vote. Results are publicly visible.
  ACTIVE
  # Poll ran its entire duration and "naturally" completed. Users cannot vote. Results are publicly visible.
  COMPLETED
  # Poll was manually ended ("terminated") by a user. Users cannot vote. Results are publicly visible.
  TERMINATED
  # Poll has ended and is no longer publicly visible. Users cannot vote. Results are not publicly visible.
  ARCHIVED
  # Poll has been moderated by Twitch and is no longer viewable, even to the poll
  # owner. Users cannot vote. Results are not visible to any user.
  MODERATED
}

# A breakdown of tokens used/by for this poll/choice/user.
type PollTokenBreakdown {
  # Total number of bits used.
  bits: Int!
  # Total number of community points used.
  communityPoints: Int!
  # ID of token breakdown.
  id: ID!
}

# Top contributor to the poll and the bits they contributed.
type PollTopBitsContributor {
  # Bits amount contributed.
  bitsAmount: Int!
  # Top contributor to the poll.
  user: User
}

# Top contributor to the poll and the community points they contributed.
type PollTopCommunityPointsContributor {
  # Community Points amount contributed.
  communityPointsAmount: Int!
  # Top contributor to the poll.
  user: User
}

# Top contributor to the poll and the bits they contributed.
# Deprecated: use PollTopBitsContributor instead.
type PollTopContributor {
  # Bits amount contributed.
  bitsAmount: Int!
  # Top contributor to the poll.
  user: User
}

# A breakdown of votes cast for/by this poll/choice/user.
type PollVoteBreakdown {
  # Total number of base votes.
  base: Int!
  # Total number of votes due to bits contributions.
  bits: Int!
  # Total number of votes due to Community Points contributions.
  communityPoints: Int!
  # ID of vote breakdown.
  id: ID!
  # Total number of votes across all different vote types.
  total: Int!
}

# A voter taking part in a poll and associated information.
type PollVoter {
  # The Choices this voter voted for.
  choices: [PollVoterChoice!]!
  # id of the voter in the poll.
  id: ID!
  # The Poll this voter voted in.
  poll: Poll
  # A breakdown of the different tokens used by the voter in the poll.
  tokens: PollTokenBreakdown!
  # The User object relating to this voter.
  user: User
  # A breakdown of the different votes this voter used in the poll.
  votes: PollVoteBreakdown!
}

# A choice a voter made taking part in a poll.
type PollVoterChoice {
  # The id of the PollVoterChoice.
  id: ID!
  # The poll choice.
  pollChoice: PollChoice
  # A breakdown of the different tokens used by the voter.
  tokens: PollTokenBreakdown!
  # A breakdown of the different votes this voter used.
  votes: PollVoteBreakdown!
}

# A connection between poll and voters and metadata.
type PollVoterConnection {
  # The list of voters in this poll / choice.
  nodes: [PollVoterConnectionEdge!]!
}

# A page entry, that contains the PollVoter item and a cursor to return from the query to allow pagination.
type PollVoterConnectionEdge {
  # Cursor used for next query.
  cursor: Cursor!
  # The underlying poll voter.
  node: PollVoter!
}

# Possible sort orders for lists of voters.
enum PollVoterConnectionSort {
  # Sort the voters by # of votes.
  VOTES
  # Sort the voters by time of creation.
  CREATED_DATE
  # Sort the voters by amount of Bits on vote.
  BITS
  # Sort the voters by amount of channel points.
  CHANNEL_POINTS
}

# Possible sort directions for lists of voters.
enum PollVoterConnectionSortDirection {
  # Sort in descending order.
  DESC
  # Sort in ascending order.
  ASC
}

# The tokens that are used on a vote.
input PollVoteTokensInput {
  # The amount of bits used for this vote.
  bits: Int!
  # The amount of channel points used for this vote.
  channelPoints: Int!
}

type Post {
  # The user that created this post.
  author: User
  # The content of the post as entered by the user and annotated with links and emotes.
  body: MessageBody
  # Time the post was created by the user.
  createdAt: Time
  # Collection of embedable content attached to this post.
  embeds: [PostEmbed]
  # This Post's unique feeds ID.
  id: ID!
  # Is this post deleted.
  isDeleted: Boolean
  # The reactions associated with this post.
  reactions: [Reaction]
  # Data related to the current user.
  self: PostSelfConnection
}

# TODO: Add events.
union PostEmbed =
    Clip
  | LinkOEmbed
  | PhotoOEmbed
  | RichOEmbed
  | Video
  | VideoOEmbed
type PostPermissionSet {
  # True if the current user is allowed to delete this post.
  canDelete: Boolean!
}

type PostSelfConnection {
  # Permissions that the current user has on this post.
  permissions: PostPermissionSet
}

# A single Prediction made by a user on a Prediction Event.
type Prediction {
  # The Event that this Prediction relates to.
  event: PredictionEvent
  # The unique identifier of the Prediction.
  id: ID!
  # Whether the Prediction's results have been acknowledged by the user. Null if the Prediction has not been resolved yet.
  isResultAcknowledged: Boolean
  # The Outcome that was Predicted.
  outcome: PredictionOutcome
  # The number of points that the user spent on this Prediction.
  points: Int!
  # The number of points won by the user for this Prediction. Null if the Prediction has not been resolved yet.
  pointsWon: Int
  # The timestamp of when the user initially made this Prediction.
  predictedAt: Time!
  # The result of this Prediction. Null if the Prediction has not been resolved or refunded yet.
  result: PredictionResult
  # The timestamp of when the user most recently updated this Prediction.
  updatedAt: Time!
  # The user that made this Prediction.
  user: User
}

# An Event that users can make Predictions on.
type PredictionEvent {
  # The channel that the Prediction Event belongs to. Null if this is Event is not tied to a channel.
  channel: Channel
  # The timestamp of when the Event was created.
  createdAt: Time!
  # The creator of the Event. Null if the Event was created by an automatic process or an admin.
  createdBy: PredictionEventActor
  # The timestamp of when the Event was resolved or canceled. Null if the Event is not resolved or canceled yet.
  endedAt: Time
  # The user or extension that resolved or canceled the Event. Null if this was triggered by an automatic process or
  # by an admin, or if the Event is not resolved or canceled yet.
  endedBy: PredictionEventActor
  # Unique identifier of the Prediction Event.
  id: ID!
  # The timestamp of when the Event was locked. Null if the Event is still active.
  lockedAt: Time
  # The user or extension that locked the Event. Null if this was triggered by an automatic process or by an admin,
  # or if the Event is stillactive.
  lockedBy: PredictionEventActor
  # The Outcomes available for predicting in this Event.
  outcomes: [PredictionOutcome!]!
  # The length of the prediction window (the duration that the Event accepts predictions) in seconds.
  predictionWindowSeconds: Int!
  # The relationship between this Prediction Event and the logged in user.
  self: PredictionEventSelfEdge
  # The current status of the Event.
  status: PredictionEventStatus!
  # The title of the Event.
  title: String!
  # The Outcome that ended up being selected as the "correct" Outcome. Null if the Event has not been resolved yet.
  # This Outcome will also be present as one of the outcomes in the "outcomes" field.
  winningOutcome: PredictionOutcome
}

# Someone or something that is capable of performing actions on a Prediction Event.
union PredictionEventActor = ExtensionClient | User
# Paginated list of Prediction Events for a channel.
type PredictionEventConnection {
  # The elements in the list.
  edges: [PredictionEventEdge!]!
  # Information about this page.
  pageInfo: PageInfo!
}

# Element in a list of Prediction Events.
type PredictionEventEdge {
  # Opaque cursor describing this edge's position in the paginated list.
  cursor: Cursor!
  # The Prediction Event.
  node: PredictionEvent!
}

# The relationship between a Prediction Event and the logged in user.
type PredictionEventSelfEdge {
  # The user's Prediction on the Event. Null if the user does not have a Prediction on the Event.
  prediction: Prediction
  # A restriction on the user participating in this Event. Null if there are no
  # restrictions. If non-null, the user can only participate in Spectator Mode.
  restriction: UserPredictionEventRestriction
}

# Possible statuses for a Prediction Event.
enum PredictionEventStatus {
  # Event is actively accepting new predictions.
  ACTIVE
  # Event is no longer accepting new predictions, and is awaiting resolution.
  LOCKED
  # Event has been resolved, and is in the process of paying out winners.
  RESOLVE_PENDING
  # Event has been resolved, the winning Option has been determined, and winners have received their Channel Points.
  RESOLVED
  # Event has been canceled, and is in the process of refunding participants.
  CANCEL_PENDING
  # Event has been canceled and all users have been refunded.
  CANCELED
}

# A single Outcome that users can choose in a Prediction Event.
type PredictionOutcome {
  # The color of this Outcome.
  color: PredictionOutcomeColor!
  # The unique identifier of the Prediction Outcome.
  id: ID!
  # The title of the Event.
  title: String!
  # The top predictors (sorted by most points spent) of this Outcome. Empty if no users have predicted this Outcome.
  topPredictors: [Prediction!]!
  # The total number of points that have been spent predicting this Outcome.
  totalPoints: Int!
  # The total number of users that have predicted this Outcome.
  totalUsers: Int!
}

# The possible colors for a Prediction Outcome.
enum PredictionOutcomeColor {
  # Blue.
  BLUE
  # Pink.
  PINK
  # Green.
  GREEN
  # Orange.
  ORANGE
  # Grey.
  GREY
  # Purple.
  PURPLE
}

# Possible result types for a Prediction.
enum PredictionResult {
  # The Prediction was incorrect.
  LOSE
  # The Prediction was canceled and refunded.
  REFUND
  # The Prediction was correct.
  WIN
}

# DEPRECATED.
type Premiere {
  # The Premiereâ€™s identifier.
  id: ID! @deprecated(reason: "Premieres as a product has been deprecated")
  # The paginated items in the premiere. At this time, they will all be VoDs.
  # A maximum of 100 items will be returned per request.
  items(first: Int = 10, after: Cursor): PremiereConnection
    @deprecated(reason: "Premieres as a product has been deprecated")
  # The archived video. Only populated if the premiere is in state SUCCESS.
  pastPremiere: Video
    @deprecated(reason: "Premieres as a product has been deprecated")
  # Status of the premiere.
  status: PremiereStatus!
    @deprecated(reason: "Premieres as a product has been deprecated")
  # The user who this premiere belongs to.
  user: User @deprecated(reason: "Premieres as a product has been deprecated")
}

# DEPRECATED.
# Paginated list of videos.
type PremiereConnection {
  # The list of items in this page.
  edges: [PremiereItemEdge]
    @deprecated(reason: "Premieres as a product has been deprecated")
  # Information about this page of videos.
  pageInfo: PageInfo
    @deprecated(reason: "Premieres as a product has been deprecated")
  # The total number of items in the premiere.
  totalCount: Int
    @deprecated(reason: "Premieres as a product has been deprecated")
}

# DEPRECATED.
# The types of objects that can be contained in a premiere.
union PremiereItem = Video
# DEPRECATED.
# A page entry, that contains a premiere item and a cursor to return
# from the query to allow pagination.
# NOTE: this should have been named PremiereEdge.
type PremiereItemEdge {
  # Cursor is a cursor.
  cursor: Cursor!
    @deprecated(reason: "Premieres as a product has been deprecated")
  # Node is a node.
  node: PremiereItem!
    @deprecated(reason: "Premieres as a product has been deprecated")
}

# DEPRECATED.
enum PremiereStatus {
  # An unscheduled premiere.
  UNSCHEDULED @deprecated(reason: "Premieres as a product has been deprecated")
  # A scheduled premiere.
  SCHEDULED @deprecated(reason: "Premieres as a product has been deprecated")
  # A cancelled premiere.
  CANCELLED @deprecated(reason: "Premieres as a product has been deprecated")
  # A premiere that has been started.
  STARTED @deprecated(reason: "Premieres as a product has been deprecated")
  # A successfully completed premiere.
  SUCCESS @deprecated(reason: "Premieres as a product has been deprecated")
  # A failed premiere. Examples of failed premieres are premieres that attempt to run
  # prior to the video being processed (or failed processing,) or the event failing
  # in the middle due to technical difficulties.
  FAILED @deprecated(reason: "Premieres as a product has been deprecated")
  # An unknown status to ensure we are able to return something.
  UNKNOWN @deprecated(reason: "Premieres as a product has been deprecated")
}

# Domain of dev insights report.
enum PresignDevInsightsReportURLDomain {
  # Report for a game.
  GAME
  # Report for an extension.
  EXTENSION
  # Report for a drop.
  DROP
}

# Input for presignDevInsightsReportURL mutation.
input PresignDevInsightsReportURLInput {
  # Domain of report, for a GAME or EXTENSION or DROP.
  domain: PresignDevInsightsReportURLDomain!
  # Resource ID. Depending on domain,it is the GameID or ExtensionID or DropsCampaignID
  id: ID!
  # Type of report, default is OVERVIEW_V2.
  type: PresignDevInsightsReportURLReportType
  # Organization ID where the report is being requested. This may be empty, for example for personal extensions.
  orgID: ID
}

# URL info that can be used to upload the image.
type PresignDevInsightsReportURLPayload {
  # URL to be used by the client to download the CSV report.
  # Expires in 5 minutes.
  url: String
}

# Type of dev insights report.
enum PresignDevInsightsReportURLReportType {
  # Default report type, used for games and extensions.
  OVERVIEW_V2
  # Drops report that returns top 10 streamers for campaigns.
  DROPS_CAMPAIGNS_TOP_STREAMERS
  # Drops report that returns overview of campaigns.
  DROPS_CAMPAIGNS_OVERVIEW
  # Drops report that returns overview of drops.
  DROPS_CAMPAIGNS_DROPS_OVERVIEW
}

# Generic Price Information that supports taxing and multi region pricing.
# LONG-TERM NOTE: using Int (32 bit) as a price field can cause issue when we sell products locally
# e.g. 2147483648 (2^31) Lao Att = 253132 USD cent
# Therefor, if we sell product which price more than $2500 in Laos currency. We will need to fix this.
type PriceInfo {
  # The currency associated with the price of a subscription product.
  currency: Currency!
  # The description associated with pricing information.
  description: String!
  # The discounted total also broken down by price and tax.
  discount: DiscountBreakdown
  # The ISO-4217 wording of deriving price.
  exponent: Int!
  # Identifier used for caching.
  id: ID!
  # If the tax is already included in price.
  isTaxInclusive: Boolean!
  # The numerical price of a subscription product.
  price: Int!
  # The tax rate of localized product.
  tax: Int!
  # The total price given price and tax.
  total: Int!
}

# Wrapper around standard Emoticons for Prime Smilies Emoticons.
type PrimeEmoticons {
  # Name for the currently enabled Emoticon set selected by the user.
  currentSetName: PrimeEmoticonsSetName!
  # All Prime Emoticon Sets of emote values (id, token, setId).
  emoticonSets: [SmiliesSet!]
}

# The Names for the smilies Emoticon sets supported by Prime.
enum PrimeEmoticonsSetName {
  # Emotes that are granted to all users with Robot faces. Group id is #0 and emoticons start at id #1.
  ROBOTS
  # Emotes that are granted via Prime with Turbo faces.
  PURPLE
  # Emotes that are granted via Prime with Monkey faces.
  MONKEYS
}

# Prime Digital Content Offers are displayed to users on Twitch via Offers in the top nav.
type PrimeOffer {
  # Unique Identifier for an offer used by the Catalog service.
  catalogOfferID: ID!
  # Hint describing the current availability state of the claim for the user.
  claimHint: ClaimHint!
  # Instructions string in Markdown displayed after offer is claimed to use or redeem.
  claimInstructions: String!
  # Content metadata for the given offer.
  content: PrimeOfferContent
  # The method of offer entitlement.
  deliveryMethod: OfferDeliveryMethod!
  # Description string in Markdown used in info block for Offer.
  description: String!
  # Unique Identifier for an offer.
  id: ID!
  # Offer image asset URL.
  imageURL: String!
  # Ranking for which the offer should be displayed, ordered ASC -1 through 99 where -1 value indicates top priority.
  priority: Int!
  # The connection for whether the user is entitled to the offer.
  self: PrimeOfferSelfConnection
  # Tags related to the offer such as Free Games with Prime (FGWP).
  tags: [String!]!
  # Primary Title for Offer.
  title: String!
}

# An Object containing metadata for Digital Content.
type PrimeOfferContent {
  # Content Categories for the game, displayed in info.
  categories: [String!]!
  # If the content has an external marketing page (Blizzard, Retail, etc), some offers will have no external URL.
  externalURL: String
  # The Game metadata.
  game: Game
  # The publisher of the content.
  publisher: String!
  # Content SKU list for the offer.
  skus: [String!]!
}

# The requesting user's eligibility for a given Prime Gaming content offer.
# These fields map directly to eligibility rules used by SCES to calculate eligibility.
# They are true if the user is eligible under the specified rule.
type PrimeOfferEligibility {
  # Boolean indicating if the user can claim the offer, determined by the included eligibility rules.
  canClaim: Boolean!
  # LinkedAccountRule
  # True if the user has the required account link, if applicable.
  hasRequiredAccount: Boolean!
  # Boolean indicating if the user has already claimed the offer.
  isClaimed: Boolean!
  # MarketplaceRule
  # True if the user is in one of the offer's eligible marketplaces.
  isInEligibleMarketplace: Boolean!
  # PrimeGamingRule
  # True if the user is Prime Gaming enabled.
  isPrimeGaming: Boolean!
  # ClaimLimitRule
  # True if the user has not exceeded the claim limit for the offer.
  isUnderClaimLimit: Boolean!
  # OfferWindowRule
  # True if the time is within the offer's available window.
  isWithinOfferWindow: Boolean!
  # State of the offer: EXPIRED, LIVE, FUTURE.
  offerState: OfferState!
  # The visual status of the offer to the user, UNSEEN, SEEN, CLAIMED, DISMISSED, OVERRIDDEN, ERROR.
  status: OfferStatus!
}

# The connection between the user and their offer entitlement state.
type PrimeOfferSelfConnection {
  # The data (link, text, or claim code) for the entitlement that was created.
  claimData: String!
  # Indicates whether the user has the entitlement to the offer.
  hasEntitlement: Boolean!
  # The visual status of the offer to the user, UNSEEN, SEEN, CLAIMED, DISMISSED, OVERRIDDEN.
  status: String!
}

# Represents a Prime Gaming content offer with the requesting user's eligibility information.
# These offers are displayed on the Crown menu on Twitch.tv.
type PrimeOfferWithEligibility {
  # Unique Identifier for an offer used by the Catalog service.
  catalogOfferID: ID!
  # Instructions string in Markdown displayed after offer is claimed to use or redeem.
  claimInstructions: String!
  # Content metadata for the given offer.
  content: PrimeOfferContent
  # The method of offer entitlement.
  deliveryMethod: OfferDeliveryMethod!
  # Description string in Markdown used in info block for Offer.
  description: String!
  # Unique Identifier for an offer.
  id: ID!
  # Offer image asset URL.
  imageURL: String!
  # Describes the user's eligibility for the requested offer.
  offerEligibility: PrimeOfferEligibility
  # Ranking for which the offer should be displayed, ordered ASC -1 through 99 where -1 value indicates top priority.
  priority: Int!
  # Tags related to the offer such as Free Games with Prime (FGWP).
  tags: [String!]!
  # Primary Title for Offer.
  title: String!
}

# PrimePayoutDetail shows the detailed breakdown of the prime payouts for a given user.
type PrimePayoutDetail {
  # currency for the payout number above.
  currency: Currency!
  # currentPrimePayout is the payout that will be made in this specific payout cycle.
  currentPrimePayout: CurrentPrimePayout!
  # deferredPrimePayout is part of the earning that was earned this month but will not be paid out this month.
  deferredPrimePayout: DeferredPrimePayout!
  # month when this payout will be made.
  month: Int!
  # year when this payout will be made.
  year: Int!
}

# PrimePayoutDetails shows the history of prime payout detail.
type PrimePayoutDetails {
  # primePayoutHistory is the history of prime payout details for a user.
  primePayoutHistory: [PrimePayoutDetail!]!
}

# Metadata relevant to Prime copy or marketing that needs to be scheduled.
type PrimePromotion {
  # externalURL is a string with the destination URL.
  externalURL: String
  # id is the unique identifier for the PrimePromotion.
  id: ID!
  # isExternalLink is boolean that indicates whether the text should be a link.
  isExternalLink: Boolean!
  # text is a string field containing the user visible text for a dynamic/changing string.
  text: String!
}

# Prime Settings related data for a given user.
type PrimeSettings {
  # This type's unique identifier.
  id: ID!
  # If true, chat notifications will be sent on Prime Credit Token Channel Subscriptions.
  isSubCreditChatNotificationEnabled: Boolean!
  # The currently chosen Emoticon Set for the Prime User that are Smilies.
  primeEmoticons: PrimeEmoticons
}

# Information about the authenticated user's Prime subscription credit benefit.
type PrimeSubCreditBenefit {
  # Checks when the authenticated user's Prime subscription credit will renew.
  renewalDate: Time
  # Checks if the authenticated user has the Prime benefit for 30-day subscription credit renewals.
  willRenew: Boolean
}

# Information about the Amazon user's Prime Video benefit.
type PrimeVideoBenefit {
  # Error when the authentication token is expired.
  error: WatchPartyError
  # True if the user has valid access.
  isValid: Boolean
}

# Contains rating information for Prime Video content.
type PrimeVideoRating {
  # Number of votes.
  count: Int!
  # Fractional number of stars.
  stars: Float!
}

# PrivacyLawName is the privacy law.
enum PrivacyLawName {
  # Privacy law CCPA.
  CCPA
  # Privacy GDPR.
  GDPR
  # Rest of World.
  ROW
}

# The enumerated error reasons when processing payment made for the purchase of an offer.
enum ProcessAndroidPaymentErrorCode {
  # User is ineligible to purchase.
  INELIGIBLE
  # Unable to process payment due to an invalid argument.
  INVALID_ARGUMENT
  # An unexpected internal server error occurred.
  INTERNAL_SERVER_ERROR
  # Must have auth credentials to purchase an offer.
  UNAUTHENTICATED
  # Transaction had already been processed.
  ALREADY_HANDLED
}

# ProcessAndroidPaymentInput contains the necessary fields to process an Android payment.
input ProcessAndroidPaymentInput {
  # User IDs of the gift purchase recipients (if the Offer is a gift).
  giftRecipientUserIDs: [ID!]
  # The ID of the Offer.
  offerID: ID!
  # The ID of the user making the purchase.
  purchasingUserID: ID!
  # The number of units purchased.
  quantity: Int!
  # The receipt data required to process Android purchases.
  receiptData: AndroidReceiptDataInput!
  # The static and dynamic bindings of the attributes on an Offer.
  tagBindings: [OfferTagBindingInput!]!
  # The purchase tracking data.
  trackingData: AndroidPaymentTrackingDataInput
}

# ProcessAndroidPaymentPayload returns the order created for the purchase.
type ProcessAndroidPaymentPayload {
  # Reason why a Purchase Order failed to be created if an error occurred.
  error: ProcessAndroidPaymentErrorCode
  # The Purchase Order created for this txn process attempt.
  purchaseOrder: PurchaseOrder
}

# The enumerated error reasons when processing payment made for the purchase of an offer.
enum ProcessIOSPaymentErrorCode {
  # User is ineligible to purchase.
  INELIGIBLE
  # Unable to process payment due to an invalid argument.
  INVALID_ARGUMENT
  # Unable to process payment due to a missing transaction.
  NOT_FOUND
  # An unexpected internal server error occurred.
  INTERNAL_SERVER_ERROR
  # Must have auth credentials to purchase an offer.
  UNAUTHENTICATED
  # Transaction had already been processed.
  ALREADY_HANDLED
}

# ProcessIOSPaymentInput contains the necessary fields to process a payment from the iOS platform.
input ProcessIOSPaymentInput {
  # The ID of the user making the purchase.
  purchasingUserID: ID!
  # The ID of the Offer that was used for the purchase.
  offerID: ID!
  # The static and dynamic bindings of the attributes on an Offer.
  tagBindings: [OfferTagBindingInput!]!
  # The receipt data required to process iOS purchases.
  receiptData: IOSReceiptDataInput!
  # The purchase tracking data.
  trackingData: IOSPaymentTrackingDataInput
  # User IDs of the gift purchase recipients (if the Offer is a gift).
  giftRecipientUserIDs: [ID!]
  # The number of units purchased.
  quantity: Int!
}

# ProcessIOSPaymentPayload returns the order created for the purchase.
type ProcessIOSPaymentPayload {
  # The error code representing the reason why the requested Purchase Order failed
  # to be created. Populated only if an error occurred, nil otherwise.
  error: ProcessIOSPaymentErrorCode
  # The Purchase Order record created for this transaction attempt.
  purchaseOrder: PurchaseOrder
}

# A benefit the user receives when purchasing a product from the product catalog.
interface ProductCatalogBenefit {
  # The identifier of the benefit.
  id: ID!
}

# A product appearing in the product catalog.
interface ProductCatalogItem {
  # A list of benefits the user will receive when purchasing the product.
  benefits: [ProductCatalogBenefit!]
  # A description of the product.
  description: String
  # The identifier of the product.
  id: ID!
  # A list of offers available for purchasing the product.
  offers: [Offer!]
  # The owner (ex: channel) of the product.
  owner: ID!
  # The title of the product.
  title: String!
}

# Contains the product's checkout price and tax info for a purchase and error if a final price cannot be determined.
type ProductPurchase {
  # The price and tax breakdown for the purchase.
  checkoutPriceSummary: CheckoutPriceSummary
  # Error when the final price could not be retrieved for a product.
  errorCode: ProductPurchaseErrorCode
  # The region from which the tax was calculated.
  taxRegion: TaxRegion
}

# Possible errors when retrieving product purchase info.
enum ProductPurchaseErrorCode {
  # The user is unauthorized to retrieve the purchase info.
  USER_UNAUTHORIZED
  # PricingID not found.
  PRICING_ID_NOT_FOUND
  # Cannot determine the user residence.
  UNKNOWN_USER_RESIDENCE
  # Billing info not found for the user.
  BILLING_INFO_NOT_FOUND
  # User ineligible to make corresponding purchase.
  PURCHASE_INELIGIBLE
  # Unexpected error occurred.
  UNKNOWN
}

# ProgramAgreement describes the End User License Agreement associated with a user's current payout plan.
type ProgramAgreement {
  # Agreement body in HTML.
  body: String!
  # Agreement type accepted by the user.
  type: PayoutOnboardingCategory!
  # Agreement version (e.g. "v1").
  version: String!
  # Agreement start date.
  startDate: Time!
  # Agreement end date.
  endDate: Time!
}

# Types that can only be displayed for an Offer Promotion.
enum PromoDiscountType {
  # No Discount type to be shown.
  DISCOUNT_TYPE_NONE
  # Percent Discount type to be shown.
  DISCOUNT_TYPE_PERCENT
}

# Data used to display promotional discounts to the client.
type PromotionDisplay {
  # Describes the discount percent to display to the client.
  discountPercent: Float
  # Describes the type of discount that will be applied to the client.
  discountType: PromoDiscountType!
}

# Moment Details specific to the PUBG game.
type PUBGMomentDetails {
  # bucket is the player count bucket for aggregations.
  bucket: Int!
  # One of "game_start" or "player_count".
  event: String!
  # The game mode for the moment.
  gameMode: String!
  # The maximum player count in this period.
  maxPlayerCount: Int!
  # The minimum player count in this period.
  minPlayerCount: Int!
}

# PublishClipError is an error associated with the publishClip mutation.
type PublishClipError {
  message: String
}

# PublishClipInput edits the clip with the provided slug via segments.
input PublishClipInput {
  # The number of seconds into the clip's raw media the preview image is set to.
  previewOffsetSeconds: Float
  # The segments describing the desired changes to apply to the newly edited clip.
  segments: [ClipSegmentInput!]!
  # The slug uniquely identifying the clip to edit.
  slug: ID!
  # The new title this clip will be updated to.
  title: String
}

# PublishClipPayload returns the edited clip or an error.
type PublishClipPayload {
  # The clip with its updated properties.
  clip: Clip
  # The error when the clip fails to publish.
  error: PublishClipError
}

# Publish a Competition.
input PublishCompetitionInput {
  # ID of the Competition we want to update.
  id: ID!
}

# Data that was mutated after the competition was updated.
type PublishCompetitionPayload {
  # The competition which was updated.
  competition: Competition
}

# Errors for publishing subscription emotes.
type PublishSubscriptionEmoteError {
  # The associated error code.
  code: PublishSubscriptionEmoteErrorCode!
}

# Possible error codes returned for publishing subscription emotes.
enum PublishSubscriptionEmoteErrorCode {
  # The product has no available empty emote slots.
  EMOTE_LIMIT_REACHED
  # Only the product owner is allowed to upload emotes.
  INVALID_OWNER
  # The emote code submitted collides with an existing emote code.
  EMOTE_CODE_ALREADY_EXISTS
  # The emote code submitted is unacceptable (contains offensive, banned, or "bad" words, which violates guidelines).
  EMOTE_CODE_UNACCEPTABLE
  # The user cannot own any more emotes of this type.
  USER_OWNED_EMOTE_LIMIT_REACHED
  # Data for least one of the image sizes is not provided or invalid.
  INCOMPLETE_EMOTE_IMAGE_DATA
  # The emote code suffix submitted contains invalid characters.
  INVALID_CODE_SUFFIX
  # The upload emote image could not be parsed.
  INVALID_IMAGE_UPLOAD
  # The uploaded emote image could not be found.
  EMOTE_IMAGE_NOT_FOUND
  # There were not enough image assets supplied for the selected asset type.
  NOT_ENOUGH_EMOTE_IMAGE_ASSETS
  # There were more image assets supplied than required for the selected asset type.
  TOO_MANY_EMOTE_IMAGE_ASSETS
  # The selected emote asset type was invalid.
  INVALID_EMOTE_ASSET_TYPE
  # A static image asset was not supplied, but is required for the selected asset type.
  EMOTE_MISSING_STATIC_ASSET
  # An animated image asset was not supplied, but is required for the selected asset type.
  EMOTE_MISSING_ANIMATED_ASSET
  # Other errors returned from the service.
  UNKNOWN_ERROR
}

# The data needed to finalize the creation of a Subscription Emote.
input PublishSubscriptionEmoteInput {
  # The type of image asset for the emote.
  assetType: EmoteAssetType
  # The custom suffix of the emote code. When appended to the channel's emote prefix this will form the full emote code.
  codeSuffix: String!
  # A list containing the image IDs for all assets needed for the emote.
  imageAssets: [EmoteImageAssetInput!]
  # DEPRECATED: Use imageAssets instead. The ID of the 28x28px emote ("1x") image file previously uploaded to upload service.
  imageID1x: ID
  # DEPRECATED: Use imageAssets instead. The ID of the 56x56px emote ("2x") image file previously uploaded to upload service.
  imageID2x: ID
  # DEPRECATED: Use imageAssets instead. The ID of the 112x112px emote ("4x")
  # image file previously uploaded to upload service.
  imageID4x: ID
  # The ProductID of the subscription product which this emote will be associated with.
  productID: ID!
}

# Results of the subscription emote publish.
type PublishSubscriptionEmotePayload {
  # The newly created emote if successful.
  emote: Emote
  # Service error, if any.
  error: PublishSubscriptionEmoteError
}

# Parameters to get details about a purchasable offer for the current logged in user.
input PurchasableOfferParams {
  # CountryCode for the offer. It will need to be in ISO 3166 Alpha-2 format(e.g. "US", "BR", "HK").
  countryCode: String
  # List of gift recipient IDs if the offer is giftable.
  giftRecipientIDs: [ID!]
  # The ID of the Offer.
  offerID: ID!
  # The ID of the Promotion attached to a Purchasable Offer (optional).
  promotionID: ID
  # The static and dynamic bindings of the attributes on an Offer.
  tagBindings: [OfferTagBindingInput!]
}

# Category of product that can be purchased.
enum PurchaseableProductType {
  # Subscription product.
  SUBSCRIPTION
  # Bits product.
  BITS
}

# Set of purchase Ineligibility reasons.
enum PurchaseIneligibilityReason {
  # User already has an active subscription to this product.
  HAS_ACTIVE_SUBSCRIPTION
  # Not applicable as user is eligible to make a purchase.
  NOT_APPLICABLE
}

# The enumerated error reasons when purchasing an offer.
enum PurchaseOfferErrorCode {
  # User is ineligible to purchase.
  INELIGIBLE
  # An unexpected internal server error occurred.
  INTERNAL_SERVER_ERROR
  # User's payment method is invalid.
  INVALID_PAYMENT_METHOD
  # Must have auth credentials to purchase an offer.
  UNAUTHENTICATED
}

# PurchaseOfferInput contains the necessary fields to purchase an offer.
input PurchaseOfferInput {
  # Data to facilitate the Fraud analysis.
  billingAuthInfo: BillingAuthInfo
  # User IDs of the gift purchase recipients (if the Offer is a gift).
  giftRecipientUserIDs: [ID!]
  # The ID of the Offer.
  offerID: ID!
  # Payments' session tracking.
  paymentSession: PaymentSession!
  # The ID of the user making the purchase.
  purchasingUserID: ID!
  # The number of units purchased.
  quantity: Int!
  # The static and dynamic bindings of the attributes on an Offer.
  tagBindings: [OfferTagBindingInput!]!
  # Tenant-specific tracking params.
  tenantTracking: String
}

# PurchaseOfferPayload returns the order created for the purchase.
type PurchaseOfferPayload {
  # Reason why a Purchase Order failed to be created if an error occurred.
  error: PurchaseOfferErrorCode
  # The Purchase Order created for this purchase attempt.
  purchaseOrder: PurchaseOrder
}

# PurchaseOrder is the record of a purchase made by a user.
type PurchaseOrder {
  # The action token ID used to facilitate the 3D Secure flow.
  actionTokenID: ID
  # The reason for a purchase order failure, if it failed.
  failureReason: PurchaseOrderFailureReason
  # The ID of the Purchase Order.
  id: ID!
  # The state of the Purchase Order.
  state: PurchaseOrderState!
}

# The enumerated failure reasons for a purchase order failure.
enum PurchaseOrderFailureReason {
  # Bank declined the charge.
  BANK_DECLINED
  # Failed to entitle the benefit. User was refunded if a charge occurred.
  ENTITLEMENT_FAILED
  # User is ineligible to purchase.
  INELIGIBLE
  # User's payment method is invalid.
  INVALID_PAYMENT_METHOD
  # System error.
  SYSTEM_ERROR
  # Unknown failure reason.
  UNKNOWN
}

# PurchaseOrderState is the current state of the Purchase Order.
enum PurchaseOrderState {
  # The Purchase Order is in an unknown state.
  UNKNOWN
  # The Purchase Order flow has been initiated and is at its starting state.
  INITIATED
  # The Purchase Order has a scheduled future-dated payment to complete the purchase.
  PAYMENT_PENDING
  # The Purchase Order has been paid and fulfillment has been kicked off.
  FULFILLMENT_INITIATED
  # The Purchase Order has been successfully fulfilled.
  SUCCESS
  # The Purchase Order failed and requires 3DS2 verification.
  THREE_D_SECURE_CHALLENGE_REQUIRED
  # The Purchase Order failed.
  FAILED
  # The Purchase Order's benefit cancellation has been kicked off.
  CANCEL_BENEFITS_INITIATED
  # The Purchase Order's benefits have been fully cancelled.
  BENEFITS_CANCELLED
  # A refund has been kicked off for the Purchase Order.
  REFUND_INITIATED
  # A refund has been successfully applied to the Purchase Order.
  REFUND_APPLIED
  # A refund has failed to the Purchase Order.
  REFUND_FAILED
}

# Purchase profile of a recurring or non-recurring subscription that a user bought.
type PurchaseProfile {
  # Cancels the entitled benefit and refunds if isRefundable is true.
  cancelledAt: Time
  # Date this purchase profile was created.
  createdAt: Time!
  expiresAt: Time
  # Usually the Twitch user's ID, but recorded by the payment provider.
  extPurchaserID: ID
  # The external subscription ID recorded by the payment provider.
  extSubscriptionID: ID
  # ID of the Purchase Profile in Payments team database.
  id: ID!
  isExpired: Boolean
  # Whether this purchase profile was gifted.
  isGift: Boolean
  # Whether this purchase profile is being paid for.
  isPaying: Boolean!
  isRecurring: Boolean!
  isRefundable: Boolean
  paidAt: Time
  # Product type of the purchase.
  productType: SubscriptionProductType!
  purchasedAt: Time
  # Twitch purchaser's email.
  purchaserEmail: String!
  # Twitch purchaser's user ID.
  purchaserID: ID!
  # Twitch purchaser's real name.
  purchaserName: String
  # Currency for the renewalPrice, e.g. "USD".
  renewalCurrency: String
  # Expected renewal price of the product in the smallest subunit of the currency, e.g. "499".
  renewalPrice: Int
  # Different from cancellation in that it stops renewal but let's user keep the benefit until it expires.
  renewalStoppedAt: Time
  # State of the purchase profile. i.e. cancelling the purchase profile can set state to 'cancelled'.
  state: PurchaseProfileState!
  # Subscription benefit associated with this purchase profile, if still active.
  subscriptionBenefit: SubscriptionBenefit
  # Date this purchase profile was last updated.
  updatedAt: Time
  # Whether this purchase profile will renew in the future and charge the user's payment method.
  willRenew: Boolean!
}

enum PurchaseProfileState {
  ACTIVE
  CANCELLED
  INACTIVE
  MIGRATED
}

# Root fields to access the Twitch API.
type Query {
  # Get the context that corresponds to an upcoming ad request made client side.
  adContext(context: AdRequestContext!): AdContext
  # Get a single AdCreative.
  adCreative(adSystem: String!, creativeID: ID!): AdCreative
  # Get all tags.
  allTags(first: Int = 5, after: Cursor, tagScope: TagScope): TagConnection
  # Get AutoMod evaluation of text using AutoMod rule.
  automodContent(input: AutoModContentInput!): AutoModContent
  # A list of global chat badges.
  badges: [Badge]
  # Gets a list of Bits offers for a logged out user, for use on the Bits landing page.
  bitsOffers: [BitsOffer!]
  # Returns a challenge by its ID.
  challenge(id: ID!): ChannelChallenge
  # Get a list of the most recent changelog items.
  changelogEntries(limit: Int = 15): [ChangelogEntry!]
  # Get a channel by ID or name.
  channel(id: ID, name: String): Channel
  # Get a channel/viewer pair by login.
  channelViewer(userLogin: String!, channelLogin: String!): ChannelViewer
  # Get a list of channels, either by IDs or by their names.
  channels(ids: [ID!], names: [String!]): [Channel]
  # Get the ban status of a usser with respect to a channel's chat room.
  chatRoomBanStatus(channelID: ID!, userID: ID!): ChatRoomBanStatus
  # GlobalCheerConfig contains information about (1) How to display Cheers and (2) What Cheermotes are globally available.
  cheerConfig: GlobalCheerConfig!
  # Get the logged-in user's authorizations for a client ID.
  clientAuthorization(id: ID!): ClientAuthorization
  # Get a clip by slug.
  clip(slug: ID!): Clip
  # Get the state of a cloud broadcast for the given broadcastID.
  cloudBroadcast(id: ID!): CloudBroadcast
  # Get the capabilities of a single cloud broadcast provider.
  cloudBroadcastProvider(id: ID!): CloudBroadcastProvider
  # Get a single collection (playlist) item by its ID.
  collection(id: ID!, options: CollectionOptions): Collection
  # Gets competition by ID.
  competition(id: ID!): Competition
  # The features the user has access to when organizing competitions with the Versus product.
  competitionOrganizerCapabilities: CompetitionOrganizerCapability
  # Gets a paginated list of competitions, commonly by its state. If state is
  # UNKNOWN, the query will default to LIVE competitions.
  competitions(
    first: Int = 10
    after: Cursor
    state: CompetitionState = UPCOMING
  ): CompetitionConnection
  # Get a privacy consent status from a user, e.g. GDPR or CCPA.
  consent(consentSessionID: ID!): Consent
  # Get a content tag by tag ID.
  contentTag(id: ID!): Tag
  # Get content tags by tag IDs.
  contentTags(ids: [ID!]): [Tag!]
  # Get a single copyright claim by id, null if not found.
  copyrightClaim(id: ID!): CopyrightClaim
  # Get the copyright claims filed against a channel given the channel id.
  copyrightClaims(
    channelID: ID!
    first: Int = 10
    after: Cursor
  ): CopyrightClaimConnection
  # Get a Creator Camp article.
  creatorCampArticle(id: ID!, category: String!): CreatorCampArticle
  # Get a Creator Camp category.
  creatorCampCategory(id: ID!): CreatorCampCategory
  # Get information populated in the Creator Dashboard.
  creatorDashboard(
    startAt: Time!
    endAt: Time!
    period: TimeSeriesPeriod!
  ): CreatorDashboard
  # Get information for the Creator Home page.
  creatorHome(channelID: ID): CreatorHome
  # Get the chanel/viewer pair with the current user and the channelID.
  currentChannelViewer(channelID: ID!): ChannelViewer
  # The currently authenticated user.
  # Returns null if the user is not authenticated.
  currentUser: User
  # Fetch a single directory by name and type.
  directory(name: String!, type: DirectoryType!): Directory
  # Fetch a single drop by ID. This could be either an event or time based drop.
  drop(id: ID!): DropType
  # Fetch a single drop benefit by ID.
  dropBenefit(id: ID!, ownerID: ID!): DropBenefit
  # Fetch a single drop campaign by ID.
  dropCampaign(id: ID!): DropCampaign
  # Determine the currently logged in users eligibility for the specified drop.
  dropEligibility(dropInstanceID: ID!): DropEligibility
  # Get an emote by ID.
  emote(id: ID!): Emote
  # Get the current set of emote modifiers.
  emoteModifiers: [CommunityPointsEmoteModifier!]
  # Get an emote set by ID.
  emoteSet(id: ID!): EmoteSet
  # Experiment properties for temporary use.
  experiment: Experiment
  # Get an Extension by ID. Optionally, provide a specific version. If no version is provided,
  # the released version of that extension is returned.
  extension(id: ID!, version: String): Extension
  # Get an ExtensionCarousel by ID. The default carousel can be loaded by providing the ID: "default".
  extensionCarousel(id: ID!): ExtensionCarousel
  # Fetch a paginated list of Extension Categories. Each Category will provide the first ten
  # extensions sorted by popularity in that category.
  extensionCategories(
    first: Int = 10
    after: Cursor
  ): ExtensionCategoryConnection
  # Fetch a single category. Both slugs and ids are valid inputs for getting a category.
  extensionCategory(id: ID!): ExtensionCategory
  # Fetch a single Extension Client by ID.
  # An ExtensionClient is the authorization component of an extension.
  # Returns Null if the current user doesn't have access to the extension.
  extensionClient(id: ID!): ExtensionClient
  # Fetch a paginated list of Extension Clients.
  extensionClients(organizationID: ID, after: Cursor): ExtensionClientConnection
  # Fetch an ExtensionManifest by ID and version.
  extensionManifest(id: ID!, version: String!): ExtensionManifest
  # Fetch a paginated list of ExtensionManifests.
  extensionManifests(id: ID!, after: Cursor): ExtensionManifestConnection
  # Fetch a Summary of the state of an extension. The Cursor is used to page extension manifests.
  extensionManifestsSummary(id: ID!, after: Cursor): ExtensionManifestsSummary
  # extensionRatingsCSVReportPresignedURL asks the ExtensionRatings backend if the given report is completed, and if
  # so, to generate and return a presigned S3 URL that the devsite can use to allow the user to download it.
  # If the URL is not ready yet, the response will be an empty string.
  extensionRatingsCSVReportPresignedURL(
    reportFilename: String!
  ): ExtensionRatingsCSVReportPresignedURL
  # Fetch the authentication settings for a particular extension.
  extensionSecrets(extensionID: ID!): ExtensionSecretsInfo
  # Fetch an ExtensionVersionDiscoveryManifest by ID and version.
  extensionVersionDiscoveryManifest(
    id: ID!
    version: String!
  ): ExtensionVersionDiscoveryManifest
  # Search extensions by text found in the Extension name, description or summary. The results are
  # always returned in order of popularity. By default, all RELEASED and IN_TEST extensions are returned.
  # Pass RELEASED as the value of 'state' to only return extensions in the RELEASED state.
  extensions(
    first: Int = 10
    after: Cursor
    search: String
    state: ExtensionStateFilter
  ): ExtensionConnection
  # Fetch the sections & content that should be featured on mobile
  # `language` is a letter code for the language the requesting user speaks (e.g. "en").
  featuredContentSections(language: String!): [FeaturedContentSection!]
  # Fetch streams that are featured on the front page, ordered by featurePriority ascending.
  # DEPRECATED: `geolocation` is computed based on GeoIP with a fallback value of "US" and should be omitted
  # `language` is a letter code for the language the requesting user speaks (ex. "en")
  # By default returns 6 streams.
  featuredStreams(
    first: Int = 6
    geolocation: String
    language: String
    acceptedMature: Boolean = true
  ): [FeaturedStream]
  # Fetch VODs that should be featured on the homepage
  # `language` is a letter code for the language the requesting user speaks (e.g. "en").
  featuredVideos(first: Int = 2, language: String!): [FeaturedVideo]
    @deprecated(reason: "Subject to change")
  # Get a Feed by ID.
  feed(id: ID!): Feed @deprecated
  # Convert a URL to an object that can be embedded into Twitch feeds.
  feedEmbed(url: String!): FeedEmbed @deprecated
  # Get a feed item by ID.
  feedItemContent(id: ID!): FeedItemContent @deprecated
  # Get a single game as identified by its name or ID. At least one parameter must be provided.
  game(name: String, id: ID): Game
  # Fetch games based on a variety of sorting options.
  # By default returns 10 games, sorted by highest ccu.
  # DEPRECATED field arguments: locale, tags
  # Use GameOptions instead.
  games(
    first: Int = 10
    after: Cursor
    options: GameOptions
    locale: String
    tags: [String!]
  ): GameConnection
  # Get whether a username is available for registration.
  isUsernameAvailable(username: String!): Boolean
  # Get key code information given a key code.
  key(code: String!, countryOfResidence: String): Claimable
  # Get a chat message by its id.
  message(id: ID!): Message
  # Get a list of the most recent Mod View Newsfeed items.
  modViewNewsfeedEntries(first: Int = 10): [ModViewNewsfeedEntry!]
  # Returns a developer organization by ID.
  # User must be apart of the organization.
  organization(id: ID!): Organization
  # Gets a pending Twitch Developer Organization application of the currently authenticated user.
  # This is deprecated due to multi-org and ability to have multiple applications.
  pendingOrganizationApplication: OrganizationApplication
    @deprecated(reason: "Use pendingOrganizationApplications instead.")
  # Gets a pending Twitch Developer Organization applications of the currently authenticated user.
  pendingOrganizationApplications: [OrganizationApplication!]
  # Get a list of sections(follows, recommendation) for the current user
  # may not return all the requested section e.g requesting following section for logged out user.
  personalSections(input: PersonalSectionInput!): [PersonalSection!]
  # Returns a poll by its ID.
  poll(id: ID!): Poll
  # Returns a Prediction Event by its ID.
  predictionEvent(id: ID!): PredictionEvent
  # Get Current PrimeOffers for a given region based on country code (request info or query param)
  # optional dateOverride to provide offers that would be displayed on that date
  # optional countryCode to provide offers that are displayed for that country
  # optional locale to provide offers displayed for the supplied locale.
  primeOffers(
    dateOverride: Time
    countryCode: String
    locale: String
  ): [PrimeOffer!]!
  # Retrieve currently live Prime Gaming offers for a given region using the new eligibility architecture.
  # If provided, dateOverride is used to specify offers that would be live on the given date.
  # If provided, countryCode is used to specify offers that would be live in the given region.
  # If provided, locale is used to specify the offer content language for the given locale.
  primeOffersWithEligibility(
    dateOverride: Time
    countryCode: String
    locale: String
  ): [PrimeOfferWithEligibility!]!
  # Retrieve currently live Prime Gaming offers for a given region.
  # This query retrieves offer data without eligibility or entitlement information.
  # If provided, dateOverride is used to specify offers that would be live on the given date.
  # If provided, countryCode is used to specify offers that would be live in the given region.
  # If provided, locale is used to specify the offer content language for the given locale.
  primeOffersWithoutEligibility(
    dateOverride: Time
    countryCode: String
    locale: String
  ): [PrimeOffer!]!
  # PrimePromotions data - query supports optional identifiers for promotion strings but default behavior will use
  # countryCode and userID to find available marketing promotions. For whitelisted QA users dateOverride can be provided.
  primePromotions(ids: [ID!], dateOverride: Time): [PrimePromotion]!
  # PrimeVideoBenefit returns a user's prime video benefits from Amazon. Requires an LWA token.
  primeVideoBenefit(accessToken: String!): PrimeVideoBenefit
  # Get details about a purchasable offer for the current logged in user.
  # This field can only be requested if an OAuth token is supplied with the request.
  # If the OAuth token is not supplied or if the offer does not exist, this will return null.
  purchasableOffer(params: PurchasableOfferParams!): Offer
  # Fetch radio content based on the content type, optionally filtered by an Amazon Standard Identification Number.
  radioContent(contentType: RadioContentType!, id: ID): RadioContent
    @deprecated(reason: "Use specific user.radio queries instead.")
  # Fetch a group of recommended games.
  # `recRequestID` is a tracking id created by the caller. This should be unique per request.
  # `location` defines the source location of the recommended streams request (e.g. "TV_APPS").
  # `context` contains parameters that are used to personalize recommendations (e.g. "Platform").
  recommendedGames(
    first: Int = 6
    recRequestID: ID!
    location: String!
    context: RecommendationsContext!
  ): RecommendedGamesConnection
  # Fetch a group of recommended streams.
  # `recRequestID` is a tracking id created by the caller. This should be unique per request.
  # `location` defines the source location of the recommended streams request (e.g. "LEFT_NAV").
  # `context` contains parameters that are used to personalize recommendations (e.g. "Platform").
  # `filters` is an optional parameter that can be used to filter recommendation results.
  recommendedStreams(
    first: Int = 6
    recRequestID: ID!
    location: String!
    context: RecommendationsContext!
    filters: StreamRecommendationsFilters
  ): RecommendedStreamsConnection
  # Holds configuration necessary for calling Recurly.
  recurlyConfigs(paymentSession: PaymentSession): RecurlyConfigs
  # Get a message rejected by chat.
  rejectedChatMessage(id: ID!): RejectedChatMessage
  # Get a list of valid reasons for a content type.
  reportReasons(content: ReportContentType!): [ReportReason!]
  # Get a list of valid country and ToS reasons for a content types.
  reportToSAndCountryReasons(
    content: ReportContentType!
  ): ReportToSAndCountryReasons
  # Metadata about the request to the API.
  requestInfo: RequestInfo!
  # Get a room by its ID.
  room(id: ID!): Room
  # Get a schedule segment by ID. Additional options can be provided to get the segment relative to a
  # different time or timezone.
  scheduleSegment(id: ID!, options: ScheduleSegmentOptions): ScheduleSegment
  # Get search results for a user's query.
  search(
    userQuery: String!
    platform: String!
    options: SearchOptions
  ): SearchResult @deprecated(reason: "Use the 'searchFor' query instead.")
  # Search for tags to apply to a channel.
  searchApplicableTags(userQuery: String!, limit: Int = 15): [Tag!]
  # Get search results for categories/games.
  searchCategories(
    query: String!
    first: Int = 25
    after: Cursor
  ): SearchCategoriesConnection
  # Search for category tags to filter categories in Browse.
  searchCategoryTags(userQuery: String!, limit: Int = 15): [Tag!]
  # Get gql search results for a user's query.
  searchFor(
    userQuery: String!
    platform: String!
    options: SearchForOptions
    target: SearchForTarget
    requestID: ID
  ): SearchFor
  # Search for tags to filter live channels in Browse.
  searchLiveTags(userQuery: String!, categoryID: ID, limit: Int = 15): [Tag!]
  # Get Live Streams in search by user query.
  searchStreams(
    userQuery: String!
    first: Int = 25
    after: Cursor
  ): SearchStreamConnection
  # Get search suggestions for a user's query.
  searchSuggestions(
    queryFragment: String!
    requestID: ID
  ): SearchSuggestionConnection
  # Get users by query in search. for search page product use searchFor instead.
  searchUsers(
    userQuery: String!
    hasSubscriptionProductsOnly: Boolean
    first: Int = 25
    after: Cursor
  ): SearchUserConnection
  # Fetch shelves to display on the homepage.
  # DEPRECATED field arguments: platform (use context.platform), langWeightedCCU.
  shelves(
    requestID: String!
    platform: String!
    langWeightedCCU: Boolean
    first: Int
    itemsPerRow: Int = 12
    context: RecommendationsContext
  ): ShelfConnection
  # Get paginated short video feed.
  shortVideoFeed(
    first: Int = 3
    after: Cursor
    options: ShortVideoFeedOptions
  ): ShortVideoFeedConnection @deprecated
  # Whether or not the Twitch Developers CSAT callout should appear for the currently authenticated user.
  shouldShowDevsiteCSAT: Boolean
  # Get a squad stream by ID.
  squadStream(id: ID!): SquadStream
  # The playback access token that determines whether the user can watch the live stream
  # Fetched for both authed and unauthed users.
  streamPlaybackAccessToken(
    channelName: String!
    params: PlaybackAccessTokenParams!
  ): PlaybackAccessToken
  # Fetch live streams, ordered by the number of viewers descending.
  # languages can be empty or null, which will imply all the languages are included on the results.
  # tags are an array of tag ID as optional filters for streams.
  # DEPRECATED field arguments: platformType, languageTags, tags
  # Use StreamOptions instead.
  streams(
    first: Int = 10
    after: Cursor
    options: StreamOptions
    platformType: PlatformType = all
    languages: [Language!]
    input: StreamMetadataFilterInput
    tags: [String!]
  ): StreamConnection
  # Get a subscription product by its name. See product name examples below. The productName uniquely identifies a product.
  #
  # e.g. "meclipse", "meclipse_2000", "meclipse_3000", these are respectively, the tier 1, 2, and 3 subscription product
  # names for the user with login "shroud".
  subscriptionProduct(productName: String!): SubscriptionProduct
  # Get all avaialble token bundle products available for the user.
  # CountryCode will need to be in ISO 3166 Alpha-2 format(e.g. "US", "BR", "HK").
  subscriptionTokenBundleProducts(
    countryCode: String
    channelID: ID
  ): [SubscriptionTokenBundleProduct!]
  # Gets the Token Product Config.
  subscriptionTokenProductConfig: SubscriptionTokenProductConfig
  # Gets a list of cloud broadcast providers that can be used by clients to start a broadcast via the provider.
  supportedCloudBroadcastProviders: [CloudBroadcastProviderKey!]
  # Get the logged in user's available hero assets.
  supportedHeroAssets: [HeroAsset!]!
  # Get the verticals available for a particular user.
  supportedVerticals(
    recommendationsContext: RecommendationsContext!
  ): [VerticalDirectory!]
  # Gets a team by its Twitch name.
  team(name: String!): Team
  # Gets a list of sorted top tags aggregated from all tags applied to current live channels.
  topTags(limit: Int = 5): [Tag!]
  # Get localized metadata for any twitch's website url.
  urlMetadata(url: String!): URLMetadata
  # Get a user by their ID or login.
  # If no ID or login is provided, null is returned.
  # Lookup type can tell the resolver to include all users (inclusing deleted and
  # suspended accounts) on the lookup, defaults to only retrieve active users.
  user(id: ID, login: String, lookupType: UserLookupType = ACTIVE): User
  # Fetch the user by a specific attribute.
  userByAttribute(input: UserByAttribute!): User
  # Get the settings associated with a user's uploaded emotes.
  userEmoteSettings(userID: ID!): EmoteSettings
  # Fetch a user by their ID, or receive a reason indicating
  # why the user could not be retrieved.
  userResultByID(id: ID!): UserResult
  # Fetch a user by their login, or receive a reason indicating
  # why the user could not be retrieved.
  userResultByLogin(login: String!): UserResult
  # Get a list of users, either by their logins or by their IDs.
  users(ids: [ID!], logins: [String!]): [User]
  # Get a verification request given an opaqueID.
  # These are generally email verification requests, but could be phone-numbers in the future.
  verificationRequest(opaqueID: ID!): VerificationRequest
  # Get content for a vertical directory by its ID.
  verticalDirectory(
    id: ID!
    recommendationsContext: RecommendationsContext!
    contentMin: Int!
    contentMax: Int!
  ): VerticalDirectory
  # Get content for a vertical subdirectory filtered by one or more context IDs (ex: category ID, tag ID).
  verticalSubDirectory(
    id: ID!
    contentContext: VerticalSubDirectoryContentContext
    recommendationsContext: RecommendationsContext!
    contentMin: Int!
    contentMax: Int!
  ): VerticalSubDirectory
  # Get a video by its ID.
  # By default, Video queries only return public videos.
  # If the owner should also see their own private videos, set includePrivate flag in the `options` input.
  # This flag does not include other people's private videos.
  video(id: ID, options: VideoOptions): Video
  # A paginated list of comments against id, videoID, or channelID.
  videoComments(
    first: Int
    after: Cursor
    last: Int
    Before: Cursor
    id: String
    videoID: String
    channelID: String
  ): VideoCommentConnection
  # Get the current or past video ingest metadata such as bitrates and codecs by its ID and channelID.
  # Optional customerID for staffs.
  videoIngestSession(
    id: ID!
    channelID: ID!
    customerID: ID
  ): VideoIngestSession
  # Get the current video ingest metadata such as bitrates and codecs starting a
  # specified number of seconds ago by channelID. Optional customerID for staffs.
  videoIngestSessionLatest(
    channelID: ID!
    customerID: ID
    secondsAgo: Int!
  ): VideoIngestSession
  # Get the current or past video ingest metadata such as bitrates and codecs by
  # time range and channelID. Optional customerID for staffs.
  videoIngestSessions(
    channelID: ID!
    customerID: ID
    startedAt: Time!
    endedAt: Time!
  ): [VideoIngestSession!]
  # The playback access token that determines whether the user can watch the video.
  # Fetched for both authed and unauthed users.
  videoPlaybackAccessToken(
    id: ID!
    params: PlaybackAccessTokenParams!
  ): PlaybackAccessToken
  # Get a list of videos in order of descending popularity.
  videos(
    first: Int = 10
    after: Cursor
    broadcastType: BroadcastType
    language: Language
  ): VideoConnection
  # Get a list of Prime Video items for Watch Parties.
  watchPartyItems(
    first: Int = 20
    after: Cursor
    accessToken: String
    options: WatchPartyItemSearchOptions
  ): WatchPartyItemConnection
  # Get a whisper thread by ID.
  whisperThread(id: ID): WhisperThread
}

# Interval that a quest is being evaluated for.
type QuestEvaluationInterval {
  # Duration of the interval (in days).
  durationInDays: Int!
  # End time of the interval.
  endTime: Time!
  # Start time of the interval.
  startTime: Time!
}

# Progress towards a particular quest goal.
type QuestGoalFloat {
  # Current progress towards quest goal.
  current: Float!
  # Number needed to complete the quest goal.
  goal: Float!
}

# Progress towards a particular quest goal.
type QuestGoalInt {
  # Current progress towards quest goal.
  current: Int!
  # Number needed to complete the quest goal.
  goal: Int!
}

# The quests associated with a user.
type Quests {
  # "Build a Community" quest.
  buildACommunity: BuildACommunity
  # "It Begins" quest.
  itBegins: ItBegins
  # "Path to Affiliate" quest.
  pathToAffiliate: PathToAffiliate
  # "Path to Partner" quest.
  pathToPartner: PathToPartner
}

# Twitch Radio access.
type Radio {
  # Twitch Radio account information for the user.
  account: RadioAccount!
  # Fetch the requesting user's currently playing radio content.
  currentlyPlaying: RadioCurrentlyPlaying!
    @deprecated(reason: "Use 'currentRadioTrack' in 'channel' instead.")
  # Fetch a radio playlist by ID. Tracks can be requested here, but can be slow to respond.
  playlist(id: ID!): RadioPlaylist
  # Fetch all, or filtered subset of, radio playlists. Cannot request track data from this query.
  playlists(filter: RadioPlaylistFilter): [RadioPlaylist!]!
  # Fetch the requesting user's recently played radio content ids. Optionally filtered by type.
  recentlyPlayed(filter: RadioRecentlyPlayedFilter): [RadioRecentlyPlayed!]!
  # Fetch a radio station by ID. Returns the initial queue with a token to get the next tracks if no pageToken is passed.
  station(id: ID!, pageToken: String, numberOfTracks: Int): RadioStation
  # Fetch all radio stations.
  stations: [RadioStation!]!
}

# Amazon Music user information for a Twitch user using Twitch Radio.
type RadioAccount {
  # The Twitch user's ID as known in Amazon Music.
  customerID: ID!
  # The unique Amazon client device identifier for this user and service.
  deviceID: ID!
  # ISO 3166-1 alpha-2 country code territory of the user in Amazon Music.
  musicTerritory: String!
  # User token to authenticate with Amazon services
  amazonAccessToken: String!
  tokenExpiresAt: Time!
}

# A Twitch Radio Album.
type RadioAlbum {
  # The album's unique id (an Amazon Standard Identification Number).
  id: ID!
  # URL to the album's main image.
  imageURL: String!
  # The album name.
  name: String!
}

# A Twitch Radio artist.
type RadioArtist {
  # The creator channel.
  channel: Channel
  # The creator channel id.
  creatorChannelID: ID
  # The artist's unique id (an Amazon Standard Identification Number).
  id: ID!
  # The artist name.
  name: String!
}

# A container for Twitch Radio content request results.
type RadioContent {
  # The requested playlists.
  items: [RadioContentItem!]
}

# The types of radio content that can be requested (e.g., playlists, stations, tracks, etc).
union RadioContentItem = RadioPlaylist | RadioRecentlyPlayed
# A Twitch Radio LinkFire Input Response for Content Promotion.
type RadioContentPromotion {
  # Text on the redirect button.
  buttonText: String!
  # Icon for the media service having dark/light theme assets. Formats supported: PNG, SVG. Default value is SVG.
  icon(format: RadioIconFormat = SVG): RadioIconThemeAssets!
  # IconURL for the media service. Formats supported: PNG, SVG. Default value is SVG.
  iconURL(format: RadioIconFormat = SVG): String!
    @deprecated(reason: "Use 'icon' instead.")
  # Rank to order the icons.
  rank: Int!
  # Title of the service.
  title: String!
  # URL to redirect to the service.
  url: String!
}

# The different Twitch Radio collection types that can be requested.
enum RadioContentType {
  # Retrieve playlists, can be filtered by ASIN.
  PLAYLIST
  # Retrieve the user's recently played playlists.
  RECENTLY_PLAYED
}

# Content currently playing in the client for a user.
type RadioCurrentlyPlaying {
  # The radio content promotion json data.
  contentPromotions: [RadioContentPromotion!]
  # Whether the track is currently playing or not.
  isCurrentlyPlaying: Boolean!
  # The Track Details of the currently playing track.
  track: RadioTrack
}

# The types of content we can register current plays for.
enum RadioCurrentlyPlayingType {
  # A radio playlist.
  PLAYLIST
  # A radio station.
  STATION
}

# The currently playing radio track addition result.
type RadioCurrentTrackResponse {
  # Radio currently Playing Track is added Successfully or not.
  isSuccess: Boolean!
}

# Icon Formats for the media service.
enum RadioIconFormat {
  # PNG Icon for the media service.
  PNG
  # SVG Icon for the media service.
  SVG
}

# Theme for the media service assets.
type RadioIconThemeAssets {
  # Dark theme Asset URL.
  darkURL: String!
  # Light theme Asset URL.
  lightURL: String!
}

# A Twitch Radio playlist.
type RadioPlaylist {
  # Curator of the playlist.
  curator: String!
  # Playlist's Description.
  description: String!
  # The playlist's unique id (an Amazon Standard Identification Number).
  id: ID!
  # URL to the playlist's main image.
  imageURL: String!
  # Is the playlist featured.
  isFeatured: Boolean!
  # The playlist's title.
  title: String!
  # List of tracks in the playlist.
  tracks: [RadioTrack!]
}

# Filters for querying the playlists.
enum RadioPlaylistFilter {
  # Get all playlists.
  ALL
  # Get only featured playlists.
  FEATURED
}

# Content recently played in the client.
type RadioRecentlyPlayed {
  # The type of content the ID maps to.
  contentType: RadioRecentlyPlayedType!
  # The id of the recently played item.
  id: ID!
  # Recently played playlist metadata.
  playlist: RadioPlaylist
  # Recently played station metadata.
  station: RadioStation
  # The time this ID was last recently played by the current user.
  updatedAt: Time!
}

# Filter for recentlyPlayed.
enum RadioRecentlyPlayedFilter {
  # Get all recently played items.
  ALL
  # Retrieve only playlists.
  PLAYLISTS
}

# The types of content we can register recent plays for.
enum RadioRecentlyPlayedType {
  # A radio playlist.
  PLAYLIST
  # A radio station.
  STATION
}

# A Twitch Radio station.
type RadioStation {
  # The station's unique id (an Amazon Standard Identification Number).
  id: ID!
  # URL to the station's main image.
  imageURL: String!
  # Is the station featured.
  isFeatured: Boolean!
  # Page token to be passed back to the Client Gateway when requesting additional tracks.
  pageToken: String
  # The station's title.
  title: String!
  # List of tracks in the station.
  tracks: [RadioTrack!]
}

# A Twitch Radio track.
type RadioTrack {
  # The track album.
  album: RadioAlbum!
  # The track artists.
  artists: [RadioArtist!]!
  # The duration of the track in seconds.
  duration: Int!
  # Track's Genre.
  genre: String!
  # The track's unique id (an Amazon Standard Identification Number).
  id: ID!
  # Industry standard track's unique id.
  isrc: String!
  # The title of the track.
  title: String!
}

# A raid represents a broadcaster directing their viewers to another channel
# in a synchronized "raid" on the channel after a countdown during which
# each viewer has a chance to opt out of the raid.
#
# Raids are created by a broadcaster from their dashbboard where they can search
# and select the channel they wish to target. Once selected the raid takes counts
# down to prepare after which the broadcaster can tell the raid to "Go", redirecting
# all joined raiders to the target channel.
type Raid {
  # Timestamp of raid announcement.
  announceAt: Time
  # Timestamp of raid go time.
  goAt: Time
  # The ID of the raid.
  id: ID!
  # Channel hosting the raid.
  sourceChannel: User
  # Target of the raid.
  targetChannel: User
  # Number of viewers in raid.
  viewerCount: Int
}

# A user's raid settings.
type RaidSettings {
  # Determines what other channels can raid this channel.
  incomingRaidsPolicy: IncomingRaidsPolicy!
}

# An integer range with a minimum and a maximum.
type Range {
  # The maximum value of the Range.
  max: Int!
  # The minimum value of the Range.
  min: Int!
}

# Possible errors returned by the RateExtension mutation.
enum RateExtensionError {
  # Internal service error eg. database timeout.
  INTERNAL_ERROR
}

# RateExtensionInput submits a user's rating and feedback on a Twitch extension.
input RateExtensionInput {
  # The ID of the extension being rated.
  extensionClientID: ID!
  # The version of the extension being rated.
  extensionVersion: String!
  # Whether the user recommends the extension or not.
  isRecommended: Boolean!
  # Indicates from where the user submitted the rating.
  location: ExtensionRatingLocation!
  # The ID of the user performing the rating.
  userID: ID!
}

# The result of a rateExtension mutation.
type RateExtensionPayload {
  # The error if the mutation fails to submit the extension rating.
  error: RateExtensionError
  # The resulting ExtensionRating record.
  rating: ExtensionRating
}

union ReactableContent = Clip | Post | Stream | Video
type Reaction {
  # count of users that reacted with a particular Emote.
  count: Int!
  # The Emote associated with the Reaction.
  emote: Emote!
  # The authenticated user's relationship with this reaction.
  self: ReactionSelfConnection!
}

type ReactionSelfConnection {
  # Did the authenticated user react.
  hasReacted: Boolean!
}

input ReadNotificationsInput {
  # IDs of the notifications to set as read. The minimum number is 1 and the maximum is 100.
  ids: [ID!]!
}

type ReadNotificationsPayload {
  # The amount of notifications that were set to read.
  count: Int!
  # The notifications that were set to read. Only ID and isRead are accessible.
  notifications: [OnsiteNotification]!
}

# Feedback from a user about a piece of content.
type RecommendationFeedback {
  # Reason for feedback.
  category: RecommendationFeedbackCategory!
  # Feedback target.
  content: RecommendationFeedbackContent
  # Recommendation Feedback ID. Generated from the type, category, content id, and user id.
  id: ID!
  # Last time this feedback was given.
  lastUpdated: Time!
  # Feedback target type.
  type: RecommendationFeedbackType!
  # Feedback giver.
  user: User
}

# Reason for feedback.
enum RecommendationFeedbackCategory {
  # Only returned when there is an issue. Shouldn't be returned, should not be used for fetching.
  UNSPECIFIED
  # The user is not interested in this type of content.
  NOT_INTERESTED
  # The user finds this type of content to be offensive.
  OFFENSIVE
  # The user has already seen this content.
  ALREADY_WATCHED
  # Used when the other reasons do not capture the reason a user is giving feedback.
  OTHER
}

# Connection between a user and recommendation feedback.
type RecommendationFeedbackConnection {
  # Contains the edges for the recommendation feedback.
  edges: [RecommendationFeedbackEdge!]
  # Contains pagination metadata.
  pageInfo: PageInfo!
}

# Feedback target.
union RecommendationFeedbackContent = Channel | Game | Video
# Edge containing the node and cursor for recommendation feedback items.
type RecommendationFeedbackEdge {
  # Cursor for the feedback edge.
  cursor: Cursor!
  # Node for the feedback edge.
  node: RecommendationFeedback
}

# Feedback target type.
enum RecommendationFeedbackType {
  # Only returned when there is an issue. Shouldn't be returned, should not be used for fetching.
  UNSPECIFIED
  # Feedback given about channels.
  CHANNEL
  # Feedback given about a game / category.
  CATEGORY
  # Feedback given about a shelf.
  SHELF
  # Feedback given about a video.
  VOD
}

type Recommendations {
  # The recommended community gifting quantities to display to the user when they intend to gift subscriptions.
  # The trackingID is not a unique ID for the recommendations, but a passthrough
  # value for backend logging to link to purchases made by the user after being
  # shown these recommendations.
  communityGiftQuantities(trackingID: ID!): [Int!]
  # A list of recommended friends.
  friends: [RecommendedFriend]
  # Live recommendations.
  # recRequestID is a tracking id created by the caller. Should be unique per request.
  liveRecommendations(
    first: Int = 10
    recRequestID: String!
    language: String!
    location: String
    context: RecommendationsContext
  ): LiveRecommendationConnection
  # Stream recommendations.
  streams(first: Int = 10): RecommendedStreamConnection
    @deprecated(reason: "use a specific recommendation instead")
  # A list of recommended VODs.
  videos(first: Int = 10, after: Cursor): RecommendedVideoConnection
    @deprecated(reason: "this feature has been sunset")
}

# RecommendationsContext define parameters which can control recommendations logic.
# Clients should strive to fill in as many fields as possible for the highest quality recommendaitons.
# Many of these fields should be identical to what is sent in pageview events:
# https://blueprint.di.xarth.tv/#/schema/pageview.
input RecommendationsContext {
  # The 'app_window_height' field sent in pageview events.
  appWindowHeight: Int
  # The 'app_window_width' field sent in pageview events.
  appWindowWidth: Int
  # The 'client_app' field sent in pageview events.
  clientApp: String
  # Optional ISO country code, defaults to use the country code from the geoip of the request.
  country: String
  # The 'location' field sent in pageview events (signifying the location on the site or app).
  location: String
  # Web, ios, android, etc.
  platform: String
  # The 'referrer_domain' field sent in pageview events.
  referrerDomain: String
  # The 'viewport_height' field sent in pageview events.
  viewportHeight: Int
  # The 'viewport_width' field sent in pageview events.
  viewportWidth: Int
}

type RecommendedFriend {
  # Reason why this recommendation was made.
  reason: String
  # The user recommended to be a friend of the source user.
  user: User
}

# The response of a recommended games request which contains a list of recommended games.
type RecommendedGamesConnection {
  # A list of recommended games.
  edges: [RecommendedGamesEdge!]
  # Per-generation tracking id for identifying a recommendation model.
  generationID: ID!
  # As pagination is currently not supported by the backend, this will always be the zero value.
  pageInfo: PageInfo!
  # Unique tracking id per response.
  responseID: ID!
}

# The content to render from a recommended game.
type RecommendedGamesEdge {
  # As pagination is currently not supported by the backend, this will always be the zero value.
  cursor: Cursor!
  # The underlying game content to render.
  node: Game
  # Globally unique id per category used in client tracking.
  trackingID: ID!
}

interface RecommendedStream {
  # The recommended stream.
  stream: Stream
  # The type of recommendation. Different types contain different metadata about why the recommendation was made.
  type: StreamRecommendationType
}

# NOTE: this type will soon be removed.
type RecommendedStreamConnection {
  # This field is deprecated.
  nodes: [RecommendedStream] @deprecated(reason: "This field has been sunset")
}

# The response of a recommended streams request which contains a list of recommended streams.
type RecommendedStreamsConnection {
  # A list of recommended streams.
  edges: [RecommendedStreamsEdge!]
  # Per-generation tracking id for identifying a recommendation model.
  generationID: ID!
  # As pagination is currently not supported by the backend, this will always be the zero value.
  pageInfo: PageInfo!
  # Unique tracking id per response.
  responseID: ID!
}

# The content to render from a recommended stream.
type RecommendedStreamsEdge {
  # As pagination is currently not supported by the backend, this will always be the zero value.
  cursor: Cursor!
  # The underlying stream content to render.
  node: Stream
  # Globally unique id per stream used in client tracking.
  trackingID: ID!
}

type RecommendedVideoConnection {
  edges: [RecommendedVideoEdge]
  pageInfo: PageInfo
  # A unique ID for this generated list of recommendations.
  setID: String
}

type RecommendedVideoEdge {
  cursor: Cursor
  node: Video
}

# Record ad event error.
type RecordAdEventError {
  # Error from recording ad event.
  code: RecordAdEventErrorCode!
}

# Enumeration of RecordAdEvent error status codes.
enum RecordAdEventErrorCode {
  # The RAd token in the request was not valid.
  INVALID_TOKEN
  # The event payload was invalid.
  INVALID_JSON
  # An internal error has occurred, other than a 500.
  UNKNOWN_ERROR
}

# The input for recording an ad event.
input RecordAdEventInput {
  # The ad event name.
  eventName: String!
  # Ad details JSON encoded as a string.
  eventPayload: String!
  # The RAd service token used for validation.
  radToken: String!
}

# The payload returned after recording an ad event.
type RecordAdEventPayload {
  # Error from mutation, if one exists.
  error: RecordAdEventError
}

type RecurlyConfigs {
  # For interacting with the Braintree gateway and Paypal (supported by Recurly).
  braintreeClientAuthorization: String!
  # For interacting with Pay With Amazon gateway (supported by Recurly).
  payWithAmazonConfigs: PayWithAmazonConfigs!
  # Sent to Recurly to identify requests.
  publicKey: String!
}

# Payment Method information for a recurring payment.
# An abstraction for a set of Payments models, existing here to surface to the Payments Management Page.
type RecurringPaymentDetail {
  # Time that the payment will attempt to renew.
  expiresAt: Time
  # Product type of the purchase.
  productType: SubscriptionProductType!
  # Currency for the renewalPrice, e.g. "USD".
  renewalCurrency: String
  # Expected renewal price of the product in the smallest subunit of the currency, e.g. "499".
  renewalPrice: Int
  # Divisor for renewalPrice for display: e.g. "100" for USD.
  renewalPriceDivisor: Int
  # Subscription benefit, if still active.
  subscriptionBenefit: SubscriptionBenefit
  # Twitch user ID, owner of the entitlement benefit.
  ticketOwnerID: ID
  # Twitch user ID, owner of the channel that was subscribed to.
  # Can be null if product type is Turbo.
  ticketProductOwnerID: ID
  # Whether this subscription will renew in the future and charge the user's payment method.
  willRenew: Boolean!
}

# Redeem claimable error.
type RedeemClaimableError {
  # Error code while redeeming.
  code: RedeemClaimableErrorCode!
}

# Redeem claimable error status codes.
enum RedeemClaimableErrorCode {
  # The request has been throttled.
  REQUEST_THROTTLED
  # The user is not allowed to redeem this key.
  UNAUTHORIZED
  # The key has already been claimed.
  ALREADY_CLAIMED
  # Unknown error being returned from service.
  UNKNOWN
  # Invalid PIN/Claimable.
  # Currently only used for Gift Card PINs.
  INVALID_PIN
  # PIN already redeemed.
  # Currently only used for Gift Card PINs.
  ALREADY_REDEEMED
  # User can't redeem due to wallet balance limit
  # Currently only used for Gift Card PINs.
  EXCEEDED_WALLET_BALANCE
  # Two Factor Auth is required past a certain balance
  # for fraud mitigation. Currently only used for Gift Card PINs.
  TWO_FACTOR_REQUIRED
  # Unsupported Country of Residence
  # Currently only used for Gift Card PINs.
  INVALID_COUNTRY_OF_RESIDENCE
  # User excedded redemption velocity limit.
  # Currently only used for Gift Card PINs.
  EXCEEDED_VELOCITY_LIMIT
}

# The input for claiming a key code.
input RedeemClaimableInput {
  # Optional param for user's self-declared country of residence.
  # Currently only used for Gift Card Redemptions.
  countryOfResidence: String
  # The key code that needs to be claimed.
  keyCode: String!
}

# The payload returned after claiming a key code.
type RedeemClaimablePayload {
  # Possible errors returned from the service for this mutation.
  error: RedeemClaimableError
  # The updated key information.
  key: Claimable
}

# An error from redeeming a custom Community Points reward in a channel.
type RedeemCommunityPointsCustomRewardError {
  # An identifier for the error that occurred.
  code: RedeemCommunityPointsCustomRewardErrorCode
}

# The possible reasons redeeming a custom Community Points reward in a channel could fail.
enum RedeemCommunityPointsCustomRewardErrorCode {
  # The reward was not found.
  NOT_FOUND
  # The current user is not allowed to redeem this reward in this channel.
  FORBIDDEN
  # The user does not have sufficient points to redeem the reward.
  NOT_ENOUGH_POINTS
  # The client-provided properties (title, cost, or prompt) did not match the reward's true properties.
  PROPERTIES_MISMATCH
  # The client is retrying a redemption with a transaction id that has already been redeemed.
  DUPLICATE_TRANSACTION
  # The client is retrying a redemption with a transaction id that is currently being redeemed in another request.
  TRANSACTION_IN_PROGRESS
  # The reward is disabled.
  DISABLED
  # The stream is not live.
  STREAM_NOT_LIVE
  # The reward has hit its maximum number of redemptions per stream.
  MAX_PER_STREAM
  # The user is banned and cannot redeem rewards.
  USER_BANNED
  # The redemption message contained a blocked phrase.
  CHANNEL_SETTINGS
  # The redemption message starts with a '/' like a chat command.
  MESSAGE_IS_COMMAND
  # An unknown error occurred.
  UNKNOWN
  # The reward has hit its maximum number of redempetions per user per stream.
  MAX_PER_USER_PER_STREAM
  # The reward is currently under a cooldown.
  GLOBAL_COOLDOWN
}

# Input for redeeming a custom Community Points reward in a channel.
input RedeemCommunityPointsCustomRewardInput {
  # The channel ID that the reward is being redeemed in.
  channelID: ID!
  # The cost that the client expects this reward to cost.
  # If this cost is different from the reward's true cost, the request will fail.
  cost: Int!
  # The prompt that the client expects this reward to have.
  # If this prompt is different from the reward's true prompt, the request will fail.
  # Should be null if the reward does not have a prompt.
  prompt: String
  # The unique reward ID.
  rewardID: ID!
  # For rewards that require text input, this is the user-supplied text.
  # Discarded if the reward does not require text input.
  textInput: String
  # The title that the client expects this reward to have.
  # If this title is different from the reward's true title, the request will fail.
  title: String!
  # Client-set identifier for the transaction. This ID should be universally unique.
  transactionID: ID!
}

# The response from redeeming a custom Community Points reward in a channel.
type RedeemCommunityPointsCustomRewardPayload {
  # An error that occurred while redeeming a custom Community Points reward in a channel.
  error: RedeemCommunityPointsCustomRewardError
  # The newly created redemption.
  redemption: CommunityPointsCustomRewardRedemption
}

# RedeeemCreatorGiftsInput the input for redeeming subscriptions from a creator's balance.
input RedeemCreatorGiftsInput {
  # The amount of balance to redeem. This value must be greater than 0 and less than the creator's
  # standing balance.
  amount: Int!
}

# RedeemCreatorGiftsPayload the output of redeeming subscriptions from a creator's balance.
type RedeemCreatorGiftsPayload {
  # The container for creator gifts the creator has.
  creatorGifting: CreatorGifting
}

type RedeemRitualTokenError {
  code: RedeemRitualTokenErrorCode!
}

enum RedeemRitualTokenErrorCode {
  # Token is not in a status that can be redeemed.
  TOKEN_NOT_AVAILABLE
  # Token does not exist.
  TOKEN_NOT_FOUND
  # User is not a follower and tried redeeming the token in a follower-only chat.
  FOLLOWER_ONLY_MODE_ENFORCEMENT_FAILED
  # User is not a subscriber and tried redeeming the token in a subs-only chat.
  SUB_ONLY_MODE_ENFORCEMENT_FAILED
  # User is banned in the channel.
  USER_CHAT_BANNED
  # User is timed out in the channel.
  USER_CHAT_TIMED_OUT
}

# RedeemRitualTokenInput is the input when redeeming a ritual token.
input RedeemRitualTokenInput {
  # The channel to redeem the token in.
  channelID: ID!
  # User-specified text to send with the token redemption.
  messageText: String
  # The type of ritual to be redeemed.
  type: RitualTokenType!
}

# RedeemRitualTokenPayload is the response when redeeming a ritual token.
type RedeemRitualTokenPayload {
  error: RedeemRitualTokenError
  token: RitualToken
}

# RedeemSubscriptionInput creates a new subscription redemption input.
input RedeemSubscriptionInput {
  # The channelID to which the user is currently subscribed to and is allowing to redeem a subscription.
  fromChannelID: ID!
  # The channelID to which the user wants to redeem their subscription to.
  targetChannelID: ID!
  # The User who is trying to redeem the subscription.
  userID: ID!
}

# RedeemSubscriptionPayload returns a status code indicating whether the update was successful or not.
type RedeemSubscriptionPayload {
  # A code indicating why the redemption of subscription failed, if it did.
  errorCode: RedeemSubscriptionResponseErrorCode
  # The Subscription Product that the user has been entitled to.
  product: SubscriptionProduct
}

# An Error indicating why the submit failed, if it did.
enum RedeemSubscriptionResponseErrorCode {
  # The Channel ID is invalid.
  INVALID_CHANNEL
  # The User is not Eligible to Redeem Subscription to this Channel.
  NOT_ELIGIBLE
  # Something unexpected occured when Redeeming the Subscription.
  UNKNOWN
  # The User has already redeemed the subscription offerd by the channel.
  USER_HAS_REDEEMED_SUBSCRIPTION
  # The channel the user is trying to redeem from has not been off-boarded.
  CHANNEL_NOT_OFF_BOARDED
  # The user already has an existing subscription to the target channel they are trying to redeem to.
  USER_HAS_EXISTING_SUBSCRIPTION
  # The target Channel the user is trying to redeem to is Invalid.
  REDEEM_CHANNEL_INVALID
  # The user is not subscribed to the channel that is being off-boarded.
  USER_NOT_SUBSCRIBED_TO_OFF_BOARDED_CHANNEL
}

input RedeemTrueXAdInput {
  # args are parameters describing the engagement the user just completed for bits.
  args: String!
  # signature is a digital signature protecting the integrity of `args`.
  signature: String!
  # targetID is the `User.id` of the channel where the user is watching the ad.
  targetID: ID
  # trueXAd is descriptive information about the engagement that was just shown.
  # This information is useful for logging errors on the server-side.
  trueXAd: TrueXAd
}

type RedeemTrueXAdPayload {
  # currentUser is the authenticated user object which includes the updated
  # `Wallet` info after the message bits have been spent.
  currentUser: User
  # grantedBits is the number of bits the user earned from this engagement.
  grantedBits: Int!
}

# How to group the referral sources.
enum ReferralsDimension {
  # Return referrals grouped by platforms.
  PLATFORM
  # Return referrals grouped by country.
  COUNTRY
  # Return referrals grouped by channel.
  CHANNEL
  # Return referrals grouped by internal source.
  INTERNAL
  # Return referrals grouped by external source.
  EXTERNAL
}

# Which subset of referrals to return.
enum ReferralsFilter {
  # Return all referral sources.
  ALL
  # Return live video play referrals from external sources, filtered by the web platform.
  EXTERNAL_LIVE_WEB
  # Return live video play referrals from internal channels, filtered by the web platform.
  INTERNAL_CHANNEL_LIVE_WEB
  # Return live video play referrals from internal sources, filtered by the web platform.
  INTERNAL_LIVE_WEB
}

# The required input for an RefreshExtensionToken mutation.
input RefreshExtensionTokenInput {
  # The id of the channel the extension is currently installed on.
  channelID: ID!
  # The ID of the extension that the user is refreshing their token for.
  extensionID: ID!
  # The current extension jwt being refreshed.
  jwt: String
}

# The result of a RefreshExtensionToken mutation.
type RefreshExtensionTokenPayload {
  # Error from an RefreshExtensionToken Call.
  error: String
  # The user's new token.
  token: ExtensionToken
}

# RegenerateStreamKeyInput is input required to regenerate a broadcaster's stream key.
input RegenerateStreamKeyInput {
  # channelID of the broadcaster.
  channelID: ID!
}

# RegenerateStreamKeyPayload contains the VideoStreamSettings with updated stream key.
type RegenerateStreamKeyPayload {
  # The updated video stream for channel.
  channel: Channel
}

# RegenerateVerificationCodeInput is input required to regenerate a user's verification code in EVS.
input RegenerateVerificationCodeInput {
  # Address that the user is verifying. This will most likely be an email address or phone number.
  address: String!
  # Key for the entity associated with the address. This is generally the Twitch ID of the user.
  key: String!
}

# RegenerateVerificationCodePayload is the VerificationRequest document returned from EVS on success.
type RegenerateVerificationCodePayload {
  # The updated verification request.
  request: VerificationRequest
}

# RegisterPayoutInformationError describes the error that occured when registering
# a user's payout information during payout onboarding.
type RegisterPayoutInformationError {
  # Code to describe error that occurred while registering payout information.
  code: RegisterPayoutInformationErrorCode!
  # Lists any field names that have an invalid format.
  invalidFields: [RegisterPayoutInformationFieldName!]
}

# Enumerates possible errors when registering payout information.
enum RegisterPayoutInformationErrorCode {
  # Must have auth credentials to register payout information.
  UNAUTHENTICATED
  # User does not have permission to register payout information for the targeted user.
  FORBIDDEN
  # One or more fields have an invalid format.
  INVALID_FORMAT
  # An internal error has occurred.
  INTERNAL_ERROR
}

# Enumerates vaid field names when registering payout information.
enum RegisterPayoutInformationFieldName {
  # Assigned if Birthdate is given in invalid format.
  BIRTHDATE
  # Assigned if City is given in invalid format.
  CITY
  # Assigned if Company Name is given in invalid format.
  COMPANY_NAME
  # Assigned if Country Code is given in invalid format.
  COUNTRY_CODE
  # Assigned if Email is given in invalid format.
  EMAIL
  # Assigned if First Name is given in invalid format.
  FIRST_NAME
  # Assigned if Last Name is given in invalid format.
  LAST_NAME
  # Assigned if Middle Name is given in invalid format.
  MIDDLE_NAME
  # Assigned if Postal is given in invalid format.
  POSTAL
  # Assigned if State Code is given in invalid format.
  STATE_CODE
  # Assigned if Primary Address is given in invalid format.
  STREET_ADDRESS
  # Assigned if Secondary Address is given in invalid format.
  STREET_ADDRESS_2
  # Assigned if Parent Name is given in invalid format.
  PARENT_NAME
  # Assigned if Parent Email is given in invalid format.
  PARENT_EMAIL
}

# RegisterPayoutInformationInput is the input required to register a user's payout information during payout onboarding.
input RegisterPayoutInformationInput {
  # Birthdate submitted by the user while registering into a payout program.
  birthdate: Time!
  # City submitted by the user while registering into a payout program.
  city: String!
  # Company Name submitted by the user while registering into a payout program.
  companyName: String
  # Country Code (ISO-3166) submitted by the user while registering into a payout program.
  countryCode: String!
  # Email submitted by the user while registering into a payout program.
  email: String!
  # First Name submitted by the user while registering into a payout program.
  firstName: String!
  # Last Name submitted by the user while registering into a payout program.
  lastName: String!
  # Middle Name submitted by the user while registering into a payout program.
  middleName: String
  # Parent Email submitted by the under age user while registering into a payout program.
  parentEmail: String
  # Parent Name submitted by the under age user while registering into a payout program.
  parentName: String
  # Postal submitted by the user while registering into a payout program.
  postal: String
  # State Code submitted by the user while registering into a payout program.
  stateCode: String
  # Primary Address submitted by the user while registering into a payout program.
  streetAddress: String!
  # Secondary Address submitted by the user while registering into a payout program.
  streetAddress2: String
  # TargetUserID is the ID of the user whose payout information will be registered.
  targetUserID: ID!
}

# RegisterPayoutInformationPayload is the updated workflow after registration is accepted.
type RegisterPayoutInformationPayload {
  # Describes error that occured when registering payout information.
  error: RegisterPayoutInformationError
  # New workflow state.
  workflow: PayoutOnboardingWorkflow
}

# Error returned during a invalid user request.
type RegisterTwoFactorConfirmationError {
  # Error code returned by the backend.
  code: RegisterTwoFactorConfirmationErrorCode!
  # The localized external error message.
  message: String!
}

# The possible error enums returned while trying to confirm registeration for two factor authentication.
enum RegisterTwoFactorConfirmationErrorCode {
  # The user needs to re-authenticate to perform this operation.
  REAUTH_NEEDED
  # The user cannot confirm two factor registration since the initial registration was never started or has expired.
  REGISTRATION_NOT_STARTED
  # The one time password provided is invalid.
  INVALID_OTP
  # The one time password provided is missing.
  MISSING_OTP
  # The phone number provided is used for too many Twitch accounts.
  LIMIT_REACHED
  # The user does not have a verified email.
  EMAIL_NOT_VERIFIED
  # Something unexpected occured.
  UNKNOWN_ERROR
}

# The required input for a registerTwoFactorConfirmation mutation.
input RegisterTwoFactorConfirmationInput {
  # The one time password required to complete two factor registration.
  oneTimePassword: String!
  # The ID of the user that is requesting to complete registration of two factor authentication.
  userID: ID!
}

# The result of a registerTwoFactorConfirmationPayload mutation.
type RegisterTwoFactorConfirmationPayload {
  # New access token returned for clients to use after turning on 2FA.
  accessToken: String
  # Whether the user's two factor account ID is associated to multiple twitch accounts.
  isTwoFactorAccountShared: Boolean
  # error code and localized error.
  error: RegisterTwoFactorConfirmationError
}

# Error returned during a invalid user request.
type RegisterTwoFactorError {
  # Error code returned by the backend.
  code: RegisterTwoFactorErrorCode!
  # The localized external error message.
  message: String!
}

# The possible error enums returned while trying to register for two factor authentication.
enum RegisterTwoFactorErrorCode {
  # The user needs to re-authenticate to perform this operation.
  REAUTH_NEEDED
  # Phone number was not provided.
  MISSING_PHONE_NUMBER
  # Phone number was not valid.
  INVALID_PHONE_NUMBER
  # The user has requested to register for two factor authentication too many times.
  REQUEST_THROTTLED
  # The user does not have a verified email.
  EMAIL_NOT_VERIFIED
  # Something unexpected occured.
  UNKNOWN_ERROR
}

# The required input for a registerTwoFactor mutation.
input RegisterTwoFactorInput {
  # The phone number used for two factor registration.
  phoneNumber: String!
  # The ID of the user that is requesting to register for two factor authentication.
  userID: ID!
}

# The result of a registerTwoFactorPayload mutation.
type RegisterTwoFactorPayload {
  # error code and localized error.
  error: RegisterTwoFactorError
}

# The registration type signifies the policy for participants to join the competition.
enum RegistrationType {
  # Competition that any Twitch user can join.
  OPEN
  # Competition that only invited participants can join.
  INVITATIONAL
  # Open competition where only followers of the channel can join.
  FOLLOWERS
  # Open competition where only subscribers of the channel can join.
  SUBSCRIBERS
  # Open competition where only followers and subscribers of the channel can join.
  FOLLOWER_AND_SUBSCRIBERS
  # Unknown type.
  UNKNOWN
}

type RejectedChatMessage {
  # Original message's raw body.
  body: String
  # Optional list of fragments from the messages's body that lead to the message rejection.
  failedFragments: [String]
  # The ID of the message.
  id: ID
  # Specifies if a action by a moderator has been taken on the message.
  isResolved: Boolean @deprecated(reason: "Use status field instead")
  # The extracted caught message.
  message: Message
  # The user that created the message.
  sender: User
  # Status of the message.
  status: CaughtMessageStatus!
  # The channel where the message was originally sent.
  target: User
}

input RejectFriendRequestInput {
  # The authenticated user will reject the friend request sent by the user with an ID equal to targetID.
  targetID: ID!
}

type RejectFriendRequestPayload {
  # The user whose friend request was just rejected.
  user: User
}

# Errors from rejectSquadStreamInvitation mutation.
type RejectSquadStreamInvitationError {
  # Error from request to reject invitation.
  code: RejectSquadStreamInvitationErrorCode!
}

# Possible errors from this mutation.
enum RejectSquadStreamInvitationErrorCode {
  # Invitation to be rejected does not exist.
  INVITATION_NOT_FOUND
  # Squad associated with the invitation does not exist.
  SQUAD_NOT_FOUND
  # User does not have permissions to reject invitation.
  UNAUTHORIZED
  # Invitation not in pending state cannot be rejected.
  INVITATION_CANNOT_BE_REJECTED
}

# Inputs to the rejectSquadStreamInvitation mutation.
input RejectSquadStreamInvitationInput {
  # ID of the invitation to be rejected.
  invitationID: ID!
}

# Outputs from the rejectSquadStreamInvitation mutation.
type RejectSquadStreamInvitationPayload {
  # Error from mutation if exists.
  error: RejectSquadStreamInvitationError
  # The rejected invitation.
  invitation: SquadStreamInvitation
}

# RejectSquadStreamOutOfNetworkInvitationsError is the error associated with a rejectSquadStreamOutOfNetworkInvitations.
type RejectSquadStreamOutOfNetworkInvitationsError {
  # The associated error code.
  code: RejectSquadStreamOutOfNetworkInvitationsErrorCode!
}

# RejectSquadStreamOutOfNetworkInvitationsErrorCode are the possible errors that this mutation returns.
enum RejectSquadStreamOutOfNetworkInvitationsErrorCode {
  # The user is not authorized to reject invitations on behalf of the recipient.
  UNAUTHORIZED
}

# Inputs to the rejectSquadStreamOutOfNetworkInvitations mutation.
input RejectSquadStreamOutOfNetworkInvitationsInput {
  # ID of the user whose out of network invitations will be rejected.
  recipientID: ID!
}

# Outputs from the rejectSquadStreamOutOfNetworkInvitations mutation.
type RejectSquadStreamOutOfNetworkInvitationsPayload {
  # The possible error returned from the service.
  error: RejectSquadStreamOutOfNetworkInvitationsError
}

# RemoveAutohostChannelsInput remove channelIDs from a user's list to autohost.
input RemoveAutohostChannelsInput {
  # ChannelIDs that will be removed from the list to autohost.
  channelIDs: [ID!]!
  # UserID to update autohost list for.
  userID: ID!
}

# RemoveAutohostChannelsPayload returns the user whose autohostChannels field had been updated.
type RemoveAutohostChannelsPayload {
  # User whose autohostChannels field had been updated.
  user: User
}

# RemoveCollectionItemInput accepts a collectionID and item ID and parameters to remove the item from a collection.
input RemoveCollectionItemInput {
  # The id of the collection.
  collectionID: ID!
  # The id of the item of which will be added to the collection.
  itemID: ID!
  # The type of item ie. video.
  itemType: String!
}

# The response from removing an item from a collection.
type RemoveCollectionItemPayload {
  # The newly updated collection.
  collection: Collection
}

# RemoveCompetitionPhaseInput contains the inputs required to remove a phase.
input RemoveCompetitionPhaseInput {
  # The competition id of the competition.
  competitionID: ID!
  # The id of the competition phase.
  phaseID: ID!
}

# RemoveCompetitionPhasePayload is the success response for removing a phase.
type RemoveCompetitionPhasePayload {
  # The new state of competition after removing a phase.
  competition: Competition
  # Used for competition mutation errors.
  error: CompetitionError
}

# Remove a player from a Competition. If you remove a player that is part of a
# team, the player will removed from the team as well. If that player is a captain
# of the team, the team will no longer have a captain.
input RemoveCompetitionPlayerInput {
  # Unique Competition ID.
  competitionID: ID!
  # Twitch user id of the player.
  userID: ID!
}

# Indication that the player was removed.
type RemoveCompetitionPlayerPayload {
  # The new state of competition after removing a competition player from the competition.
  competition: Competition
  # Used for competition mutation errors.
  error: CompetitionError
}

# Inputs for removing a competition team from a competition.
input RemoveCompetitionTeamInput {
  # ID of the competition.
  competitionID: ID!
  # ID of the team.
  teamID: ID!
}

# RemoveCompetitionTeamPayload is the success response removing a competition team from the competition.
type RemoveCompetitionTeamPayload {
  # The new state of competition after removing a competition team from the competition.
  competition: Competition
  # Used for competition mutation errors.
  error: CompetitionError
}

# RemoveEditorError contains details about a client error that occurred.
type RemoveEditorError {
  # The type of error that occurred when revoking a user's editor status.
  code: RemoveEditorErrorCode!
}

# RemoveEditorErrorCode defines a client error that occurred while removing an editor.
enum RemoveEditorErrorCode {
  # The channel does not exist.
  CHANNEL_NOT_FOUND
  # The target user does not exist.
  TARGET_USER_NOT_FOUND
}

# RemoveEditorInput contains the parameters to revoke the editor status from a user for a channel.
input RemoveEditorInput {
  # The channel from which the editor status of the user will be revoked.
  channelID: ID!
  # The ID of the user whose editor status will be revoked.
  # Either targetUserID or targetUserLogin must be provided.
  targetUserID: ID
  # The login of the user whose editor status will be revoked.
  # Either targetUserID or targetUserLogin must be provided.
  targetUserLogin: String
}

# RemoveEditorPayload is the response after attempting to revoke the editor status of a user.
type RemoveEditorPayload {
  # The channel for which the editor status of the target user is removed.
  channel: User
  # The client error that has occurred.
  # Null if the operation is successful.
  error: RemoveEditorError
  # The user whose editor status was revoked.
  targetUser: User
}

# Error returned after attempting to remove an emote from its group.
type RemoveEmoteFromGroupError {
  # The error code associated with this error.
  code: RemoveEmoteFromGroupErrorCode!
}

# Possible error codes for RemoveEmoteFromGroupError.
enum RemoveEmoteFromGroupErrorCode {
  # The specified emote does not exist.
  EMOTE_NOT_FOUND
  # The user is not allowed to remove this emote from its group.
  PERMISSION_DENIED
  # Unknown error.
  UNKNOWN
}

# The input for remove emote from group.
input RemoveEmoteFromGroupInput {
  # ID of the emote to be removed from its group.
  emoteID: ID!
}

# Result of remove emote from group.
type RemoveEmoteFromGroupPayload {
  # The updated emote if successful.
  emote: Emote
  # Error returned after attempting to remove an emote from its group.
  error: RemoveEmoteFromGroupError
}

# RemoveOrganizationMemberError is the error associated with a RemoveOrganizationMember.
type RemoveOrganizationMemberError {
  # The associated error code.
  code: RemoveOrganizationMemberErrorCode!
}

# RemoveOrganizationMemberErrorCode defines a client error that occurred while removing an organization member.
enum RemoveOrganizationMemberErrorCode {
  # User does not have permission to remove another member.
  PERMISSION_DENIED
  # The user to be removed does not exist.
  USER_NOT_FOUND
  # Can not remove this user because it is assigned as an extension billing manager. Need to unassign first.
  ASSIGNED_BILLING_MANAGER
  # Deprecated: code not used, a resolver error is returned instead.
  INTERNAL_ERROR
}

# Inputs to the removeOrganizationMember mutation.
input RemoveOrganizationMemberInput {
  # The ID of the organization.
  organizationID: ID!
  # The twitch ID of the organization member.
  userID: ID!
}

# Outputs from the removeOrganizationMember mutation.
type RemoveOrganizationMemberPayload {
  # The possible error returned from the service.
  error: RemoveOrganizationMemberError
  # The user who is removed from organization.
  targetUser: User
}

input RemoveReactionInput {
  emoteID: ID!
  entityID: ID!
}

type RemoveReactionPayload {
  content: ReactableContent!
}

# RemoveSquadStreamMemberError is the error associated with a removeSquadStreamMember.
type RemoveSquadStreamMemberError {
  # The associated error code.
  code: RemoveSquadStreamMemberErrorCode!
}

# RemoveSquadStreamMemberErrorCode are the possible errors that this mutation returns.
enum RemoveSquadStreamMemberErrorCode {
  # The user is not authorized to remove members from the squad.
  UNAUTHORIZED
  # The user to be removed is not in the squad specified.
  USER_NOT_IN_SQUAD
}

# Inputs to the removeSquadStreamMember mutation.
input RemoveSquadStreamMemberInput {
  # The user ID of the member that should be removed from the squad stream.
  memberUserID: ID!
  # The ID of the squad stream.
  squadStreamID: ID!
}

# Outputs from the removeSquadStreamMember mutation.
type RemoveSquadStreamMemberPayload {
  # The possible error returned from the service.
  error: RemoveSquadStreamMemberError
  # The updated squad stream.
  squadStream: SquadStream
}

# Inputs for removing a stucco (from the library).
# - Active stuccos cannot be removed, they have to be inactive first (not part of a stucco pack).
input RemoveStuccoInput {
  # ID of the channel the stucco is removed from.
  channelID: ID!
  # Unique ID of the stucco to be removed.
  stuccoID: ID!
}

# The output payload for removing a stucco, returns the library of stuccos after removal.
type RemoveStuccoPayload {
  # The list of stuccos available in the channel's library after removal.
  stuccos: [Stucco!]
}

# RenewalPolicy defines whether the charge model will renew or not.
enum RenewalPolicy {
  # Will not renew automatically.
  NO_RENEW
  # Will renew automatically.
  AUTO_RENEW
  # Unknown renewal policy.
  UNKNOWN
}

# ReorderCollectionItemInput accepts a collectionID and item ID and parameters to update the item order of a collection.
input ReorderCollectionItemInput {
  # The id of the collection.
  collectionID: ID!
  # The id of the item of which will be moved in the collection.
  itemID: ID!
  # The type of item ie. video.
  itemType: String!
  # The new position of the item.
  position: Int!
}

# The response from reordering an item in a collection.
type ReorderCollectionItemPayload {
  # The newly updated collection.
  collection: Collection
}

input ReportContentInput {
  # Content type being reported.
  content: ReportContentType!
  # ID of the content being reported.
  contentID: ID!
  # The description of the report.
  description: String!
  # Extra (content specific) data for the report.
  extra: String!
  # Extra arguments required for NetzDG reporting.
  netzDGArgs: ReportContentNetzDGInput
  # The reason ID for the report.
  reason: ID!
  # ID of the user being reported.
  targetID: ID!
  # The path taken through the report wizard.
  wizardPath: [String!]
}

# Valid values for ReportContentNetzDGInput.contentDirectedTo.
enum ReportContentNetzDGContentDirectedTo {
  # The reported content is directed at the reporter.
  ME
  # The reported content is directed at someone the reporter represents.
  SOMEONE_I_REPRESENT
  # The reported content is directed at someone else.
  SOMEONE_ELSE
}

# Extra fields that are required for NetzDG reporting.
input ReportContentNetzDGInput {
  # Who the reporter thinks the offending content is directed to.
  contentDirectedTo: ReportContentNetzDGContentDirectedTo!
  # The email address of the reporter.
  reporterEmail: String!
  # Who the reporter is reporting on behalf of.
  reportingFor: ReportContentNetzDGReportingFor!
}

# Valid values for ReportContentNetzDGInput.ReportingFor.
enum ReportContentNetzDGReportingFor {
  # The reporter is reporting for themselves.
  MYSELF
  # The reporter is reporting on behalf of a complaints office.
  COMPLAINTS_OFFICE
  # The report is reporting on behalf of an agency of the german government.
  GOVERNMENT_AGENCY
}

type ReportContentPayload {
  # Content type that was reported.
  content: ReportContentType!
  # ID of the content that was reported.
  contentID: ID!
}

# Types of content that can be reported.
enum ReportContentType {
  # Report against a channel feed comment.
  CHANNEL_FEED_COMMENT_REPORT
  # Report against a channel feed post.
  CHANNEL_FEED_POST_REPORT
  # Report against a chat message.
  CHAT_REPORT
  # Report against a channel's channel points.
  CHANNEL_POINTS_REPORT
  # Report against a clip.
  CLIP_REPORT
  # (Deprecated) Report against a vod collection.
  COLLECTION_REPORT
  # (Deprecated) Report against a curse private group.
  CURSE_PRIVATE_GROUP
  # (Deprecated) Report against a curse public group.
  CURSE_PUBLIC_GROUP
  # (Deprecated) Report against a curse whisper.
  CURSE_WHISPER
  # Report against an emote.
  EMOTE_REPORT
  # Report against an oracle event.
  EVENT_REPORT
  # Report against an extension.
  EXTENSION_REPORT
  # Report against a live up notification.
  LIVE_UP_REPORT
  # Report against a livestream.
  LIVESTREAM_REPORT
  # Report against a poll.
  POLL_REPORT
  # Report against a raid.
  RAID_REPORT
  # Report against a reward redemption.
  REWARD_REDEMPTION_REPORT
  # Report against a chatroom.
  ROOM_REPORT
  # Report against sings group name.
  SINGS_GROUP_NAME_REPORT
  # Report against sings group biography.
  SINGS_GROUP_BIO_REPORT
  # Report against sings group chat.
  SINGS_GROUP_CHAT_REPORT
  # Report against a sings group vod comment.
  SINGS_VOD_COMMENT_REPORT
  # Report against sings duet seed.
  SINGS_DUET_SEED_REPORT
  # Report against an unban request.
  UNBAN_REQUEST_REPORT
  # Report against a live user.
  USER_REPORT
  # Report against a twitch vod comment.
  VOD_COMMENT_REPORT
  # Report against a twitch vod.
  VOD_REPORT
  # Report against a whisper. Deprecated in favor of the whisperReport mutation.
  WHISPER_REPORT @deprecated(reason: "use whisperReport mutation instead.")
}

# Information detailing the twitch content that is alledgedly infringing upon a copyrighted work.
input ReportedContent {
  # URL of the content.
  url: String!
  # The reported content's type.
  type: ReportedContentType!
  # If the reported content is of type past livestream, broadcastTime indictates when the reported stream was live.
  broadcastTime: Time
  # The timestamps where the infringement alledgedly occured for livestreams and vods.
  timestamps: [CopyrightTimeOffset!]
}

# Alledgedly infringing content types [livestream, vod, clip].
enum ReportedContentType {
  # The alledgedly infringing content is of type LIVESTREAM.
  ONGOING_LIVESTREAM
  # Content is of type past livestream (not currently broadcasting).
  PAST_LIVESTREAM
  # The alledgedly infringing content is of type VOD.
  VOD
  # The alledgedly infringing content is of type CLIP.
  CLIP
  # The alledgedly infringing content type is of type OTHER.
  OTHER
}

# A valid reason for a report.
type ReportReason {
  # The unique ID of the reason.
  id: ID!
  # Whether or not this report reason is in-scope for a country-specific law.
  isApplicableToCountryRegulations: Boolean!
  # The displayed text for this reason localized based on Accept-Language.
  text: String!
}

# A valid country and ToS reasons for a report.
type ReportToSAndCountryReasons {
  # The countryCode of the country-specific reporting flow that applies to the user.
  # If null then there is no relevant country-specific reporting flow for the user.
  countryCode: String
  # Localized string that should be displayed to the user as a disclosure that their report.
  # Falls under given legislation, and may be viewed by legal authorities.
  disclosureText: String
  # The list of report reasons that apply for the content type.
  toSAndCountryReasons: [ReportReason!]!
}

# Possible error reasons returned by reportWhisper mutation.
enum ReportWhisperErrorReason {
  # Invalid user ID.
  INVALID_USER_ID
  # There are no whispers from the target user to the reporter.
  NO_WHISPERS_FROM_TARGET_USER
  # The reporter is currently rate limited.
  RATE_LIMITED
  # Unauthorized.
  UNAUTHORIZED
  # Unknown error.
  UNKNOWN
}

# Input to the reportWhisper mutation.
input ReportWhisperInput {
  # The description of the report.
  description: String!
  # The reason option for the report.
  reason: String!
  # ID of the user being reported.
  targetID: ID!
  # The path taken through the report wizard.
  wizardPath: [String!]
}

# Payload returned from the reportWhisper mutation.
type ReportWhisperPayload {
  # Reports aren't queryable in GQL, so only an error is returned.
  error: ReportWhisperPayloadError
}

# Error type that may be returned returned from the reportWhisper mutation.
type ReportWhisperPayloadError {
  # Reason that the report wasn't created.
  reason: ReportWhisperErrorReason!
}

input ReportWhisperThreadInput {
  # Reason why the user is reporting the thread.
  reason: String
  # ID of user being reported.
  targetUserID: ID!
  # ID of thread to report.
  threadID: ID!
}

type ReportWhisperThreadPayload {
  thread: WhisperThread!
}

# Metadata about a GraphQL request.
type RequestInfo {
  # The country code where the request originated. Defaults to "US" if geoip lookup fails.
  countryCode: String!
  # Whether the request came from a country belonging to the European Union.
  fromEU: Boolean!
  # The IP address where the request originated.
  ipAddress: String
  # Whether the request came from a country belonging to the European Economic Area.
  isFromEEA: Boolean!
}

type RequestRitualTokenError {
  code: RequestRitualTokenErrorCode!
}

enum RequestRitualTokenErrorCode {
  # Token is not in a status that can be requested.
  TOKEN_NOT_AVAILABLE
  # Token does not exist.
  TOKEN_NOT_FOUND
}

# RequestRitualTokenInput is the input when requesting a ritual token.
input RequestRitualTokenInput {
  # The channel to request a ritual token in.
  channelID: ID!
  # The type of ritual token to request.
  type: RitualTokenType!
}

# RequestRitualTokenPayload is the response when requesting a ritual token.
type RequestRitualTokenPayload {
  error: RequestRitualTokenError
  token: RitualToken
}

# ResendVerificationEmailInput is input required to resend the verification email.
input ResendVerificationEmailInput {
  # ID of the user to resend a verification email to.
  userID: ID!
}

# ResendVerificationEmailPayload is the output after resending a verification email.
type ResendVerificationEmailPayload {
  # The modified user.
  user: User
}

# Error returned during an invalid username reset request.
type ResetUsernameCodeError {
  # Error code returned by the backend.
  code: ResetUsernameErrorCode!
}

# Possible error codes returned from a username reset.
enum ResetUsernameErrorCode {
  # Authorization token is not valid.
  TOKEN_INVALID
  # Too many attempts to update login.
  REQUESTS_THROTTLED
  # Login is not available.
  LOGIN_UNAVAILABLE
  # Login is too short.
  LOGIN_TOO_SHORT
  # Login is too long.
  LOGIN_TOO_LONG
  # Login contains characters that are not allowed.
  LOGIN_CONTAINS_INVALID_CHARACTERS
  # Unrecognized error returned from the backend service.
  UNKNOWN_ERROR
}

# Input for a username reset.
input ResetUsernameInput {
  # The new login for the user.
  login: String!
  # The authorization token for the username reset.
  resetUsernameToken: String!
}

# The result of a username reset.
type ResetUsernamePayload {
  # Error code for error from returned the username reset.
  error: ResetUsernameCodeError
  # The modified username for the user.
  login: String
}

# An error returned from the resolvePredictionEvent mutation.
type ResolvePredictionEventError {
  # Code describing the error.
  code: ResolvePredictionEventErrorCode!
}

# Possible error codes from the resolvePredictionEvent mutation.
enum ResolvePredictionEventErrorCode {
  # The current user is forbidden from resolving this Prediction Event.
  FORBIDDEN
  # This Prediction Event has already either been resolved or canceled, and as such this action cannot be taken.
  EVENT_ENDED
  # An unknown error occurred.
  UNKNOWN
}

# Input for resolving a Prediction Event (and paying out all of the users who predicted correctly).
input ResolvePredictionEventInput {
  # The unique identifier of the Prediction Event to resolve.
  eventID: ID!
  # The unique identifier of the Prediction Outcome to select as the winner.
  outcomeID: ID!
}

# Payload for resolving a prediciton event.
type ResolvePredictionEventPayload {
  # If present, there was an error with the request.
  error: ResolvePredictionEventError
  # The resolved Prediction Event.
  predictionEvent: PredictionEvent
}

# A restriction for a specific resource.
type ResourceRestriction {
  # The list of exemptions for a given resource restriction.
  exemptions: [ResourceRestrictionExemption!]
  # The restriction's unique identifier.
  id: ID!
  # The list of options that were applied at time of creation for a given resource restriction.
  options: [ResourceRestrictionOption!]!
  # The type of restriction on this resource.
  type: ResourceRestrictionType!
}

# Exemption information for a specific resource restriction.
type ResourceRestrictionExemption {
  # The list of description data a user make take to become exempt for the given restriction.
  actions: [ResourceRestrictionExemptionAction!]
  # The time that the restriction is no longer active.
  endsAt: Time
  # The keys needed for a given restriction.
  keys: [String!]
  # The time that the restriction becomes active.
  startsAt: Time
  # The type of exemption.
  type: ResourceRestrictionExemptionType!
}

# Description data for clients to get for user actions to get exempt.
type ResourceRestrictionExemptionAction {
  # Name of the action need. e.g. Ticket Product short name.
  name: String!
  # The human readable title of the restriction.
  title: String!
}

# An enumeration of the different exemption types.
enum ResourceRestrictionExemptionType {
  # The restriction is exempt for an unknown reason.
  UNKNOWN
  # The restriction is exempt for all users.
  ALL
  # The restriction is exempt for staff accounts.
  STAFF
  # The restriction is exempt for site admins.
  SITE_ADMIN
  # The restriction is exempt for owning a product.
  PRODUCT
  # The restriction is exempt for viewers that are in the same org as the channel owner.
  ORGANIZATION_MEMBER
  # The restriction is exempt for the preview duration.
  PREVIEW
  # The restriction is exempt for channel moderators.
  CHANNEL_MODERATOR
  # The restriction is exempt for channel VIPs.
  CHANNEL_VIP
}

# An enumeration of the different restriction options.
enum ResourceRestrictionOption {
  # Allows users holding the channel VIP role to access the resource.
  ALLOW_CHANNEL_VIP
  # Allows users holding the channel moderator role to access the resource.
  ALLOW_CHANNEL_MODERATOR
  # Allows only users with tier 3 subscriptions to access the resource.
  ALLOW_TIER_3_ONLY
  # Allows only users with tier 2 and 3 subscriptions to access the resource.
  ALLOW_TIER_2_AND_3_ONLY
  # Allows users with any tier subscriptions to access the resource.
  ALLOW_ALL_TIERS
}

# An enumeration of the different restriction types.
enum ResourceRestrictionType {
  # The resource is restricted for an unknown reason.
  UNKNOWN
  # The resource is restricted by a subscription.
  SUB_ONLY_LIVE
  # The resource is restricted by the All-Access Pass.
  ALL_ACCESS_PASS
  # The resource is restricted by the organization membership logic in RBAC.
  ORGANIZATION_ACCESS_ONLY
}

# Inputs to the respondToTeamInvitation mutation.
input RespondToTeamInvitationInput {
  # Whether the user accepts or declines the team invite.
  accepted: Boolean!
  # The team whose invite the user will be responding to.
  teamID: ID!
  # The authenticated user who will respond to the team invitation with an ID equal to userID.
  userID: ID!
}

# Outputs from the respondToTeamInvitation mutation.
type RespondToTeamInvitationPayload {
  # The user who just accepted a team invitation.
  user: User
}

# An enumeration of the different restriction types.
enum RestrictionResource {
  # For non-live video content, e.g. VODs.
  VIDEO
  # For live video content.
  LIVE
}

# A recent resub token to use for sending a special message.
type ResubNotification {
  # The number of months of total subbing.
  cumulativeTenureMonths: Int!
  # A unique ID for the resub notification.
  id: ID!
  # The number of months of consecutive subbing.
  months: Int!
  # The number of months of consecutive subbing.
  streakTenureMonths: Int!
  # The token to use when submitting a sub/resub message.
  token: String!
  # If the resub notification is caused by a gift or not
  isGiftSubscription: Boolean!
  # Gifter who gave the gift, null if no gifter or anon
  gifter: User
}

# The possible erors when resuming a schedule.
enum ResumeScheduleError {
  # Not authorized to resume this schedule.
  PERMISSION_DENIED
  # The schedule was not found.
  NOT_FOUND
}

# The input to resume a schedule.
input ResumeScheduleInput {
  # The id of the schedule.
  scheduleID: ID!
}

# The returned payload when resuming a schedule.
type ResumeSchedulePayload {
  # The possible error.
  error: ResumeScheduleError
  # The updated schedule input.
  schedule: Schedule
}

# Revenue configuration data related to a subscription product.
type RevenueConfig {
  # Unique identifier for the revenue configuration.
  id: ID!
  # 0-100 percent value of revenue the broadcaster will earn.
  splitPercent: Int!
  # Start time of when the revenue split configuration takes effect.
  startAt: Time
}

# RevokeVIPError contains details about a client error that occurred.
type RevokeVIPError {
  # The type of error that occurred when revoking a user's VIP status.
  code: RevokeVIPErrorCode!
}

# RevokeVIPErrorCode defines a client error that occurred while revoking a VIP status.
enum RevokeVIPErrorCode {
  # The channel does not exist.
  CHANNEL_NOT_FOUND
  # The revoker does not have permission to revoke the VIP status in this channel.
  FORBIDDEN
  # The user whose VIP status is to be revoked does not exist.
  REVOKEE_NOT_FOUND
  # The user whose VIP statu is to be revoked does not actually have the VIP status to be revoked.
  REVOKEE_NOT_VIP
}

# RevokeVIPInput contains the parameters to revoke the VIP status of a user from a channel.
input RevokeVIPInput {
  # The channel from which the VIP status of the user will be revoked.
  channelID: ID!
  # The ID of the user whose VIP status will be revoked.
  # Either revokeeID or revokeeLogin must be provided.
  revokeeID: ID
  # The login of the user whose VIP status will be revoked.
  # Either revokeeID or revokeeLogin must be provided.
  revokeeLogin: String
}

# RevokeVIPPayload is the response after attempting to revoke the VIP status of a user.
type RevokeVIPPayload {
  # The channel that the user is revoked as a VIP to.
  channel: User
  # The client error that has occurred.
  # Null if the operation is successful.
  error: RevokeVIPError
  # The user whose VIP status is revoked.
  revokee: User
}

# Rewarded Video information.
type RewardedVideo {
  # A flag indicating if the user is eligible for rewarded videos.
  isEligible: Boolean!
  # A flag indicating if the user needs to do a captcha in order to use rewarded videos.
  shouldCaptcha: Boolean!
}

type RichOEmbed implements OEmbed {
  authorName: String
  authorURL: String
  cacheAge: Int
  height: Int!
  html: String!
  inputURL: String!
  providerName: String
  providerURL: String
  thumbnail: ThumbnailOEmbed
  title: String
  type: String!
  version: String!
  width: Int!
}

# A ritual is an opportunity for a viewer to better connect with a streamer's
# community by announcing when they reach milestones in the channel.
# A ritual token is issued when a user is eligible for the ritual, and can be
# redeemed to send the announcement in a channel.
type RitualToken {
  # The channel that the user can redeem the ritual token in.
  channel: User
  # The time after which the ritual is considered expired and can no longer be
  # redeemed. Clients should dismiss the ritual UI if it's still shown after
  # this time. Null if the ritual never expires.
  expiresAt: Time
  # A unique ID for the ritual token.
  id: ID!
  # The status of the ritual token.
  status: RitualTokenStatus
  # The type of the ritual to be redeemed.
  type: RitualTokenType
  # The user that owns the ritual token.
  user: User
}

enum RitualTokenStatus {
  # ELIGIBLE means a user does not have this token, but can request one.
  ELIGIBLE
  # AVAILABLE means a user has been granted this token and it can be redeemed.
  AVAILABLE
  # DISMISSED means a user has opted out of redeeming this token.
  DISMISSED
  # REDEEMED means a user has successfully consumed this token.
  REDEEMED
}

enum RitualTokenType {
  # NEW_CHATTER is granted 5 minutes after a user joins a channel for the first time.
  NEW_CHATTER
}

# DEPRECATED.
# A chatroom associated with a channel where members of the room can exchange messages.
type Room {
  # UUID of the room.
  id: ID! @deprecated(reason: "The Rooms product has been sunset")
  # Whether the room can be read by non-members and logged out users.
  isPreviewable: Boolean!
    @deprecated(reason: "The Rooms product has been sunset")
  # Paginated list of members of the chatroom.
  members(first: Int = 100, after: Cursor): RoomMemberConnection
    @deprecated(reason: "The Rooms product has been sunset")
  # List of messages to the room, in reverse chronological order. If fromTime is used, that time is used
  # as the cursor instead of after/before.
  messages(
    first: Int
    after: Cursor
    last: Int
    before: Cursor
    fromTime: Time
  ): RoomMessageConnection
    @deprecated(reason: "The Rooms product has been sunset")
  # Minimum role required to join the room. For example, in a sub room, subs can join,
  # but also the broadcaster, mods, and staff.
  minimumAllowedRole: RoomRole!
    @deprecated(reason: "The Rooms product has been sunset")
  # Room modes (e.g. slow mode).
  modes: RoomModes @deprecated(reason: "The Rooms product has been sunset")
  # The name of the room (e.g. subs-only).
  name: String! @deprecated(reason: "The Rooms product has been sunset")
  # The user the room belongs to.
  owner: User! @deprecated(reason: "The Rooms product has been sunset")
  # rolePermissions describes the role necessary to perform actions in the room.
  rolePermissions: RoomRolePermissions
    @deprecated(reason: "The Rooms product has been sunset")
  # Returns the current user's settings for the room.
  self: RoomView @deprecated(reason: "The Rooms product has been sunset")
  # The room topic (e.g. "serious discussion only").
  topic: String @deprecated(reason: "The Rooms product has been sunset")
}

# DEPRECATED
# Paginated list of room members (users).
type RoomMemberConnection {
  # The elements of the list.
  edges: [RoomMemberEdge]!
    @deprecated(reason: "The Rooms product has been sunset")
  # Information about this page.
  pageInfo: PageInfo! @deprecated(reason: "The Rooms product has been sunset")
}

# Element in a list of room members.
type RoomMemberEdge {
  # Opaque cursor describing this edge's position in the paginated list.
  cursor: Cursor! @deprecated(reason: "The Rooms product has been sunset")
  # The user who is a member of the room.
  node: User @deprecated(reason: "The Rooms product has been sunset")
  # Type of user for grouping users in the rooms member list.
  type: RoomMemberType! @deprecated(reason: "The Rooms product has been sunset")
}

# DEPRECATED
# Type of user for grouping users in the rooms member list.
enum RoomMemberType {
  # User that is the broadcaster.
  BROADCASTER @deprecated(reason: "The Rooms product has been sunset")
  # User that is staff.
  STAFF @deprecated(reason: "The Rooms product has been sunset")
  # User that is admin.
  ADMIN @deprecated(reason: "The Rooms product has been sunset")
  # User that is global moderator.
  GLOBALMOD @deprecated(reason: "The Rooms product has been sunset")
  # User that is a channel moderator.
  MOD @deprecated(reason: "The Rooms product has been sunset")
  # User that has no special role.
  REGULAR @deprecated(reason: "The Rooms product has been sunset")
}

# DEPRECATED
# A message sent from a user to a room.
type RoomMessage {
  # The text and emoticon content of a message.
  content: RoomMessageContent!
    @deprecated(reason: "The Rooms product has been sunset")
  # Time the message was deleted or purged. Null if the message is not deleted.
  deletedAt: Time @deprecated(reason: "The Rooms product has been sunset")
  # UUID of the message.
  id: ID! @deprecated(reason: "The Rooms product has been sunset")
  # The room the message was sent in.
  room: Room! @deprecated(reason: "The Rooms product has been sunset")
  # The user that sent the message.
  sender: User! @deprecated(reason: "The Rooms product has been sunset")
  # Time the message was sent.
  sentAt: Time! @deprecated(reason: "The Rooms product has been sunset")
}

# DEPRECATED
# Paginated list of messages in a room.
type RoomMessageConnection {
  # The elements of the list.
  edges: [RoomMessageEdge]!
    @deprecated(reason: "The Rooms product has been sunset")
  # Information about this page.
  pageInfo: PageInfo! @deprecated(reason: "The Rooms product has been sunset")
}

# DEPRECATED
# The content of a user's message to a room.
type RoomMessageContent {
  # Parsed list of fragments in the message, include emotes, mentions, and plaintext.
  fragments: [RoomMessageFragment]!
    @deprecated(reason: "The Rooms product has been sunset")
  # String representation of the user message.
  text: String! @deprecated(reason: "The Rooms product has been sunset")
}

# Element in a list of messages.
type RoomMessageEdge {
  # Opaque cursor describing this edge's position in the paginated list.
  cursor: Cursor! @deprecated(reason: "The Rooms product has been sunset")
  # The message.
  node: RoomMessageItem @deprecated(reason: "The Rooms product has been sunset")
}

# DEPRECATED
# One parsed part of a message, which may be an emote, mention, or plaintext.
type RoomMessageFragment {
  # Contains an emote or a mentioned user depending on the text of the fragment.
  content: FragmentContent
    @deprecated(reason: "The Rooms product has been sunset")
  # Plaintext representation of the fragment.
  text: String! @deprecated(reason: "The Rooms product has been sunset")
}

# DEPRECATED
# RoomMessageGroupMention represents a group mention, such as @here.
type RoomMessageGroupMention {
  # The type of mention.
  type: RoomMessageMentionType!
    @deprecated(reason: "The Rooms product has been sunset")
}

union RoomMessageItem = RoomMessage
# Represents a group mention, such as @here.
enum RoomMessageMentionType {
  # An @here mention.
  HERE @deprecated(reason: "The Rooms product has been sunset")
}

# Modes that have been enabled for the room.
type RoomModes {
  # If enabled, messages to the room must contain only emotes.
  emotesOnlyModeEnabled: Boolean!
    @deprecated(reason: "The Rooms product has been sunset")
  # If enabled, messages to the room must be unique.
  r9kModeEnabled: Boolean!
    @deprecated(reason: "The Rooms product has been sunset")
  # The number of seconds users must wait between messages. If 0, slow mode is disabled.
  slowModeDurationSeconds: Int!
    @deprecated(reason: "The Rooms product has been sunset")
}

# DEPRECATED
# Represents the permissions a user has in a room.
type RoomPermissions {
  # Whether the user can moderate the room.
  moderate: Boolean! @deprecated(reason: "The Rooms product has been sunset")
  # Whether the user can read messages in the room.
  readMessages: Boolean!
    @deprecated(reason: "The Rooms product has been sunset")
  # Whether the user can send messages in the room.
  sendMessages: Boolean!
    @deprecated(reason: "The Rooms product has been sunset")
}

# DEPRECATED
# Describes the role a user must be in order to perform an action, such as sending messages. Roles are
# hierarchical, so users that meet a role also meet all lower roles as well. For example, a moderator
# meets the subscriber role, even if they are not subscribed to the channel. Roles are defined in order
# from highest to lowest in the enum.
enum RoomRole {
  # The channel owner.
  BROADCASTER @deprecated(reason: "The Rooms product has been sunset")
  # A moderator for the channel.
  MODERATOR @deprecated(reason: "The Rooms product has been sunset")
  # A subscriber of the channel.
  SUBSCRIBER @deprecated(reason: "The Rooms product has been sunset")
  # All users.
  EVERYONE @deprecated(reason: "The Rooms product has been sunset")
}

# DEPRECATED
# RoomRolePermissions describes the role necessary to perform actions in a room.
type RoomRolePermissions {
  # Read describes the role necessary to read messages in the room.
  read: RoomRole! @deprecated(reason: "The Rooms product has been sunset")
  # Send describes the role necessary to send messages in the room.
  send: RoomRole! @deprecated(reason: "The Rooms product has been sunset")
}

# DEPRECATED
# A RoomView represents the authenticated user's self connection to a room, and includes the user's
# settings and permissions.
type RoomView {
  # Whether the user has archived the room.
  isArchived: Boolean! @deprecated(reason: "The Rooms product has been sunset")
  # Whether the user has muted the room.
  isMuted: Boolean! @deprecated(reason: "The Rooms product has been sunset")
  # Whether the user has unread messages in the room.
  isUnread: Boolean! @deprecated(reason: "The Rooms product has been sunset")
  # Last time the user read a message in the room.
  lastReadAt: Time @deprecated(reason: "The Rooms product has been sunset")
  # The permissions the authenticated user has in the room.
  permissions: RoomPermissions
    @deprecated(reason: "The Rooms product has been sunset")
  # The room the room view belongs to.
  room: Room! @deprecated(reason: "The Rooms product has been sunset")
  # The number of mentions for the user in the room that the user has not read.
  unreadMentionCount: Int!
    @deprecated(reason: "The Rooms product has been sunset")
}

# An error describing why the issue happened, when relevant.
enum RotateExtensionSecretsError {
  # User has indicated an invalid extension id.
  INVALID_CLIENT
  # User is unable to delete the extension secrets.
  UNAUTHORIZED
  # User indicated an Invalid delay; must be greater than zero.
  INVALID_DELAY
}

# RotateExtensionSecretsInput includes the necessary parameters for creating a new extension secrets.
input RotateExtensionSecretsInput {
  # Delay is the time delay in seconds between creation & activation of the secret.
  delaySeconds: Int!
  # extensionID to generate a the secret for.
  extensionID: ID!
}

# RotateExtensionSecretsPayload returns the new extension secrets information.
type RotateExtensionSecretsPayload {
  # A user-friendly error, should one occur.
  error: RotateExtensionSecretsError
  # All the existing secrets for the extension.
  secrets: [ExtensionSecret!]
}

# ROW cookie vendor for a user.
type ROWCookieVendor {
  # User content status for each vendor.
  consentStatus: ConsentStatus!
  # A flag that shows if the consent is given by the user or by consent service as default value.
  hasUserSetConsent: Boolean!
  # A flag that shows if the vendor should be visible to management page.
  isVisible: Boolean!
  # Vendor name.
  name: VendorName!
}

# List of ROW cookie vendor.
type ROWVendorConsent {
  # status for vendors.
  status: [ROWCookieVendor!]!
}

# RTMPSession is metadata related to the RTMP data sent by the broadcaster.
type RTMPSession {
  # Audio codecs of RTMP session.
  audioCodecs: String!
  # H.264 advanced video codec.
  avcLevel: Int
  # Staff-only field. The IP address of the broadcaster of the RTMP session.
  clientIP: String
  # Name of the broadcaster's encoder.
  encoder: String!
  # H.264 encoder Instantaneous Decoder Refresh interval.
  idrInterval: Int
  # rtmpExitReason tells how the stream session was terminated.
  rtmpExitReason: String
  # RTMP request parameters sent by the broadcaster.
  rtmpFlags: String!
  # A full list of RTMP header sent by the broadcaster.
  rtmpMetadata: String!
  # Duration of each video frame segment in seconds.
  segmentDurationSeconds: Int!
  # Video codecs of RTMP session.
  videoCodecs: String!
  # Video resolution height in pixel.
  videoResolutionHeight: Int!
  # Video resolution width in pixel.
  videoResolutionWidth: Int!
}

# Errors that can result from running multiplayer ads.
enum RunMultiplayerAdErrorCode {
  # The channel is not live, so ads cannot be run on it.
  CHANNEL_NOT_LIVE
  # At least one of the multiplayer ad offers has expired.
  OFFER_EXPIRED
  # At least one of the multiplayer ad offers was not found.
  OFFER_NOT_FOUND
  # An unknown error has occurred.
  UNKNOWN
}

# Inputs for running multiplayer ads.
input RunMultiplayerAdsInput {
  # ID of the channel the ads will run on.
  channelID: ID!
  # How long the multiplayer ad should run for.
  desiredAdDurationSeconds: Int
  # The ID of the ad offers to run.
  offerIDs: [ID!]!
}

# The response after running multiplayer ads.
type RunMultiplayerAdsPayload {
  # The error that has occurred.
  # Null if the operation is successful.
  error: RunMultiplayerAdErrorCode
}

# The view configuration of an extension if the component anchor is supported.
input SaveComponentViewInput {
  # The developer configured height of the extension as a ratio relative to it's width.
  aspectHeight: Int
  # Specifies the width of a component extension in relation to it's targetHeight and aspectRatioY.
  #
  # NOTE:  targetHeight and aspectRatio will replace aspectHeight and aspectWidth.
  #        however, since both will be used for a short time during the rollout of the new UI,
  #        aspectWidth and aspectHeight will not be deprecated until later.
  aspectRatioX: Int!
  # Specifies the height of a component extension in relation to it's targetHeight and aspectRatioX.
  #
  # NOTE:  targetHeight and aspectRatio will replace aspectHeight and aspectWidth,
  #        however, since both will be used for a short time during the rollout of the new UI,
  #        aspectWidth and aspectHeight will not be deprecated until later.
  aspectRatioY: Int!
  # The developer configured width of the extension as a ratio relative to it's height.
  aspectWidth: Int
  # Specifies whether to automatically scale the extension iframe using css zoom as the video
  # player dimensions change.
  hasAutoscale: Boolean
  # Specifies whether CSS zooming should be applied to the CE container, creating a consistent
  # size of 1024 pixels along the long edge of the component. Default: true.
  hasZoom: Boolean
  # If Autoscale is true, this indicates the baseline width of the extension.
  # This fields is optional, but is required if hasAutoscale is true.
  scalePixels: Int
  # Size of the long edge of the Component Extension, relative to the length of the corresponding
  # interactable dimension of the video.
  size: Float
  # The percentage of the available space (0-100) (between the top and bottom player controls)
  # that the extension aims to consume.
  #
  # NOTE:  targetHeight and aspectRatio will replace aspectHeight and aspectWidth,
  #        however, since both will be used for a short time during the rollout of the new UI,
  #        aspectWidth and aspectHeight will not be deprecated until later.
  targetHeight: Int!
  # Relative path of the HTML file to load for this view.
  viewerPath: String!
  # If hasZoom is set to true, specify the effective CSS zoom to apply to the long edge of the CE.
  # Default: 1024.
  zoomPixels: Int
}

# ConfigViewInput holds the view configuration of an extension if the config page is supported.
input SaveConfigViewInput {
  # Relative path of the HTML file to load for this view.
  viewerPath: String!
}

# ExtensionAssetManifestInput is data related to the assets of an extension.
input SaveExtensionAssetManifestInput {
  # Hash of the asset zip file.
  assetHash: String!
}

# ExtensionCapabilitiesInput contains data about what an Extension can do, in general, and at the time of interaction.
input SaveExtensionCapabilitiesInput {
  # The bits support level required by the broadcaster for the extension to operate. Defaults to "NONE".
  bitsSupportLevel: ExtensionBitsSupportLevel = NONE
  # Location of configuration.
  configurationLocation: ExtensionConfigurationLocation!
  # Does this extension use bits.
  hasBitsSupport: Boolean!
  # Does this extension support chat.
  hasChatSupport: Boolean!
  # Required configuration string.
  requiredConfiguration: String!
  # The subscription support level required by the broadcaster for the extension to operate. Defaults to "NONE".
  subscriptionsSupportLevel: ExtensionSubscriptionsSupportLevel
  # Whitelists for restricting extension access and behavior.
  whitelists: ExtensionWhitelistsInput!
  # Will this extension request an identity link.
  willRequestIdentityLink: Boolean!
}

# ExtensionDeveloperManifestInput is the developer specific extension data.
input SaveExtensionDeveloperManifestInput {
  # Author email.
  authorEmail: String!
  # Testing uri for extension development.
  testingBaseURI: String!
}

# Extension metadata used for discovery.
input SaveExtensionDiscoveryManifestInput {
  # Name of the extension author.
  authorName: String!
  # Extension categories.
  categories: [ID!]!
  # Extension descriprion. 1024 character limit.
  description: String!
  # games an extension is associated with.
  games: [ID!]!
  # name of the extension.
  name: String!
  # Url to an extensions privacy policy.
  privacyPolicyURL: String!
  # Extension summary. 140 character limit.
  summary: String!
  # Extension developers support email.
  supportEmail: String!
  # Extension eula/tos url.
  termsURL: String!
  # A summary of the extension's functionality from a viewer's perspective.
  viewerSummary: String!
}

# SaveExtensionManifestError is an error associated with the saveExtensionManifest mutation.
enum SaveExtensionManifestError {
  # User is unable to make modifications to the extension.
  UNAUTHORIZED
  # Version specified is invalid.
  INVALID_VERSION
  # At least one anchor must be specified.
  ANCHOR_REQUIRED
  # HasZoom was specified but ZoomPixels is missing.
  INVALID_ZOOM
  # The number of whitelisted broadcasters exceeds the limit.
  MAX_BROADCASTERS
  # The number of whitelisted testing users exceeds the limit.
  MAX_TESTERS
  # The number of whitelisted config URLs exceeds the limit.
  MAX_WHITELISTED_CONFIG_URLS
  # The number of whitelisted panel URLs exceeds the limit.
  MAX_WHITELISTED_PANEL_URLS
  # Extension names must be shorter than 40 characters.
  INVALID_NAME_LENGTH
  # Extension description must be shorter than 1024 characters.
  INVALID_DESCRIPTION_LENGTH
  # Extension summary must be shorter than 140 characters.
  INVALID_SUMMARY_LENGTH
  # Extension author email must not be nil. Lenght must be < 254, Parses a single RFC 5322 address.
  INVALID_AUTHOR_EMAIL
  # Extension support email must not be nil. Lenght must be < 254, Parses a single RFC 5322 address.
  INVALID_SUPPORT_EMAIL
  # Extension author name length must be > 40.
  INVALID_AUTHOR_NAME_LENGTH
  # Extension testing base uri must not be nil and empty scheme. Scheme should be http or https. User should not be nil.
  INVALID_TESTING_BASE_URI
  # Extension terms uri must not be nil and empty scheme. Scheme should be http or https. User should not be nil.
  INVALID_TERMS_URI
  # Extension privacy uri must not be nil and empty scheme. Scheme should be http or https. User should not be nil.
  INVALID_PRIVACY_URI
  # Extension component viewer path must not be nil. Format should be BaseUri/Extension_Path.
  INVALID_COMPONENT_VIEWER_PATH
  # Extension panel viewer path must not be nil. Format should be BaseUri/Extension_Path.
  INVALID_PANEL_VIEWER_PATH
  # Extension video overlay viewer path must not be nil. Format should be BaseUri/Extension_Path.
  INVALID_VIDEO_OVERLAY_VIEWER_PATH
  # Extension config viewer path must not be nil. Format should be BaseUri/Extension_Path.
  INVALID_CONFIG_VIEWER_PATH
  # Extension live config viewer path must not be nil. Format should be BaseUri/Extension_Path.
  INVALID_LIVE_CONFIG_VIEWER_PATH
  # Extension mobile viewer path must not be nil. Format should be BaseUri/Extension_Path.
  INVALID_MOBILE_VIEWER_PATH
  # Extension component aspect width must be < 50 or > 1.
  INVALID_COMPONENT_ASPECT_WIDTH
  # Extension component aspect height must be < 50 or > 1.
  INVALID_COMPONENT_ASPECT_HEIGHT
  # Extension panel hiehgt must be < 500 or > 100.
  INVALID_PANEL_HEIGHT
  # Extension Bits Support Level must ba valid member of the BitsSupportLevelEnum.
  INVALID_BITS_SUPPORT_LEVEL
  # Scale pixels must be set to a positive integer when autoscale is true.
  INVALID_SCALING_PIXELS
  # Aspect Ratio X must be set to a positive integer.
  INVALID_COMPONENT_ASPECT_RATIO_X
  # Aspect Ratio Y must be set to a positive integer.
  INVALID_COMPONENT_ASPECT_RATIO_Y
  # Target Height must be set to a positve integer.
  INVALID_COMPONENT_TARGET_HEIGHT
  # Extension viewer summary must be shorter than 140 characters.
  INVALID_VIEWER_SUMMARY_LENGTH
}

# SaveExtensionManifestInput updates the manifest.
input SaveExtensionManifestInput {
  # ExtensionAssetManifest is data related to the assets of an extension.
  assetManifest: SaveExtensionAssetManifestInput!
  # Data about what an Extension can do, in general, and at the time of interaction.
  capabilities: SaveExtensionCapabilitiesInput!
  # ExtensionDeveloperManifest is the developer specific extension data.
  developerManifest: SaveExtensionDeveloperManifestInput!
  # Extension metadata used for discovery.
  discoveryManifest: SaveExtensionDiscoveryManifestInput!
  # The extension ID of the manifest to update.
  id: ID!
  # The extension version to update.
  version: String!
  # Extension views.
  views: SaveExtensionViewsInput!
}

# SaveExtensionManifestPayload returns the update Extension manifest.
type SaveExtensionManifestPayload {
  # The error when the mutation fails to update an extension.
  error: SaveExtensionManifestError
  # The updated extension manifest.
  manifest: ExtensionManifest
}

# The potential anchor-specific configurations and extension can have.
input SaveExtensionViewsInput {
  # The developer configuration of the extension as a component extension, if supported.
  component: SaveComponentViewInput
  # The developer configuration of the extension's configuration view, if supported.
  config: SaveConfigViewInput
  # The developer configuration of the extension's live configuration dashboard view, if supported.
  liveConfig: SaveLiveConfigViewInput
  # The developer configuration of the extension as a mobile extension, if supported.
  mobile: SaveMobileViewInput
  # The developer configuration of the extension as a panel extension, if supported.
  panel: SavePanelViewInput
  # The developer configuration of the extension as a video overlay extension, if supported.
  videoOverlay: SaveVideoOverlayViewInput
}

# ExtensionWhitelistsInput contains whitelists for restricting extension access and behavior.
input SaveExtensionWhitelistsInput {
  # List of broadcaster account IDs allowed to install an extension after release.
  # If this is empty or missing, all broadcasters can use this extension.
  broadcasters: [ID!]!
  # URLs which are permitted to be opened from the configuration dialog.
  configURLs: [String!]!
  # URLs which are permitted to be opened from an extension set as a panel.
  panelURLs: [String!]!
  # List of account IDs which should have access to a version of an extension.
  # Users in this list are ignored by the broadcaster whitelist check.
  testers: [ID!]!
}

# HiddenView holds the view configuration of an extension if it is a hidden load test extension.
input SaveHiddenViewInput {
  # Relative path of the HTML file to load for this view.
  viewerPath: String!
}

# LiveConfigViewInput holds the view configuration of an extension if the live config dashboard page is supported.
input SaveLiveConfigViewInput {
  # Relative path of the HTML file to load for this view.
  viewerPath: String!
}

# MobileViewInput holds the view configuration of an extension if mobile is supported.
input SaveMobileViewInput {
  # Relative path of the HTML file to load for this view.
  viewerPath: String!
}

# PanelViewInput holds the view configuration of an extension if the panel anchor is supported.
input SavePanelViewInput {
  # The extension developer configured height of the panel extension.
  height: Int!
  # Relative path of the HTML file to load for this view.
  viewerPath: String!
}

# VideoOverlayViewInput holds the view configuration of an extension if the videoOverlay anchor is supported.
input SaveVideoOverlayViewInput {
  # Relative path of the HTML file to load for this view.
  viewerPath: String!
}

# Sony Computer Entertainment (SCE) title properties.
# Used as part of stream metadata for PlayStation.
type SCETitle {
  ageRating: Int
  attribute: String
  genre: String
  id: ID
  isPreset: Boolean
  language: String
  metadata: String
  name: String
  presetText: [String]
  presetTextDescription: String
  productID: String
  sessionID: String
  shortName: String
  storeURL: String
}

# Sony Computer Entertainment (SCE) user properties.
# Used as part of stream metadata for PlayStation.
type SCEUser {
  country: String
  npID: ID
  onlineID: ID
}

# The channel schedule.
type Schedule {
  # The ID of the schedule.
  id: ID!
  # A period during which scheduled events temporarily cease.
  interruption: ScheduleInterruption
  # The next uncancelled segment of the schedule.
  nextSegment: ScheduleSegment
  # The segments after a specific date ordered by start time. This field can be
  # paginated and return segments across week boundaries.
  segmentList(
    first: Int = 10
    after: Cursor
    options: ScheduleSegmentListInput
  ): ScheduleSegmentListConnection
  # All segments for the specified week. If relativeDate isn't provided, the current week is used.
  segments(
    utcOffsetMinutes: Int
    startingWeekday: String
    relativeDate: Time
    includeFutureSegments: Boolean
  ): [ScheduleSegment!]
}

# The interruption of a schedule.
type ScheduleInterruption {
  # The end time when the schedule will no longer be disabled.
  endAt: Time!
  # The reason the schedule is disabled.
  reason: ScheduleInterruptionReason!
  # The start time when the schedule will be disabled.
  startAt: Time!
}

# The reason of an interruption of a schedule.
enum ScheduleInterruptionReason {
  # The user is on vacation.
  VACATION
  # Fallback value for reason unknown to the GQL schema.
  OTHER
}

# The segment of a schedule.
type ScheduleSegment {
  # The UTC date when the segment is no longer cancelled.
  cancelledUntil: Time
  # The game categories tied to this segment.
  categories: [Game!]
  # The end time of the segment.
  endAt: Time
  # The start date and time of the first occurrence of the segment.
  firstOccurrenceDate: Time
  # Whether or not the current user has a reminder set for the segment.
  hasReminder: Boolean!
  # The ID of the segment.
  id: ID!
  # If this segment is cancelled or not.
  isCancelled: Boolean!
  # A count of users who have a reminder set, available only to the schedule owner.
  reminderCount: Int
  # The number of times the segment should repeat. If 1, this is a single segment.
  repeatEndsAfterCount: Int
  # The start time of the segment.
  startAt: Time!
  # The title of the segment.
  title: String!
}

# The days.
enum ScheduleSegmentDay {
  # SUNDAY.
  SUNDAY
  # MONDAY.
  MONDAY
  # TUESDAY.
  TUESDAY
  # WEDNESDAY.
  WEDNESDAY
  # THURSDAY.
  THURSDAY
  # FRIDAY.
  FRIDAY
  # SATURDAY.
  SATURDAY
}

# Paginated list of segments using the Relay cursor specification.
type ScheduleSegmentListConnection {
  # The list of schedule segments.
  edges: [ScheduleSegmentListEdge!]
  # Pagination information for this connection.
  pageInfo: PageInfo!
}

# Element in a list of endorsed channels.
type ScheduleSegmentListEdge {
  # Cursor identifying the position of this edge for future queries.
  cursor: Cursor!
  # The information about the endorsed channel.
  node: ScheduleSegment!
}

# The inputs for the segmentList query.
input ScheduleSegmentListInput {
  # Flag to indicate whether in progress segments should be returned.
  ignoreInProgress: Boolean
  # The reference time to request segments after. If not provided, the current time will be used.
  startTime: Time
  # The desired timezone for the times sent with the returned segments. If not set, UTC is used.
  utcOffsetMinutes: Int
}

# The optional parameters for scheduleSegment.
input ScheduleSegmentOptions {
  # The reference time to request segments after. If not provided, the current time will be used.
  relativeDate: Time
  # The desired timezone for the times sent with the returned segments. If not set, UTC is used.
  utcOffsetMinutes: Int
  # The weekday that is used to mark the beginning of the week. If not supplied, this will default to "MONDAY".
  startingWeekday: ScheduleSegmentDay
}

# Whether the image should be set on a benefit or campaign.
enum Scope {
  # Image is for a benefit.
  BENEFIT
  # Image is for a campaign.
  CAMPAIGN
}

# Contains categories search results.
type SearchCategoriesConnection {
  # List of matching game results.
  edges: [SearchCategoriesEdge!]
  # Information about this page of categories.
  pageInfo: PageInfo!
  # Total number of results.
  totalCount: Int!
}

# An element in the categories result, and its metadata.
type SearchCategoriesEdge {
  # Cursor represents the position of the current edge/node.
  cursor: Cursor!
  # Node represents the extension for the current edge.
  node: Game!
}

# Contains results for a searchFor query.
type SearchFor {
  # Contains results for channels.
  channels: SearchForResultUsers
  # Contains results for games.
  games: SearchForResultGames
  # Contains results for live channels.
  liveChannels: SearchForResultUsers
  # Contains results for related live channels.
  relatedLiveChannels: SearchForResultRelatedLiveChannels
  # Contains results for users.
  users: SearchForResultUsers
  # Contains results for videos.
  videos: SearchForResultVideos
}

# Contains a single result item and a tracking ID.
type SearchForEdge {
  # List of matching items.
  item: SearchForItem!
  # An id used for search metrics.
  trackingID: ID!
}

# Contains a single result item and a tracking ID.
type SearchForEdgeRelatedLiveChannels {
  # List of matching items.
  item: User!
  # An id used for search metrics.
  trackingID: ID!
}

# A result item may be a User, Game, or Video.
union SearchForItem = Game | User | Video
# SearchForOptions allows the user to target specific result types.
input SearchForOptions {
  # List of indices to run a user's query against.
  targets: [SearchForTarget!]
}

# Contains game search results.
type SearchForResultGames {
  # Cursor for fetching the next page of results.
  cursor: String
  # List of edges containing game results and trackingIDs.
  edges: [SearchForEdge!]!
  # List of matching game results.
  items: [Game!]
  # Information about this page.
  pageInfo: PageInfo!
  # Order in which the result should be displayed.
  score: Int!
  # Total number of results.
  totalMatches: Int!
}

# Contains results for related live channels.
type SearchForResultRelatedLiveChannels {
  # List of edges containing user results and trackingIDs.
  edges: [SearchForEdgeRelatedLiveChannels!]!
  # List of matching user results.
  items: [User!]
  # Optional score associated with the related live section.
  score: Int
}

# Contains user search results.
type SearchForResultUsers {
  # Cursor for fetching the next page of results.
  cursor: String
  # List of edges containing user results and trackingIDs.
  edges: [SearchForEdge!]!
  # List of matching user results.
  items: [User!]
  # Information about this page.
  pageInfo: PageInfo!
  # Order in which the result should be displayed.
  score: Int!
  # Total number of results.
  totalMatches: Int!
}

# Contains video search results.
type SearchForResultVideos {
  # Cursor for fetching the next page of results.
  cursor: String
  # List of edges containing video results and trackingIDs.
  edges: [SearchForEdge!]!
  # List of matching video results.
  items: [Video!]
  # Information about this page.
  pageInfo: PageInfo!
  # Order in which the result should be displayed.
  score: Int!
  # Total number of results.
  totalMatches: Int!
}

# Specify which index to run a user's search.
input SearchForTarget {
  # Pagination cursor for user to optionally provide to request a specific page of results.
  cursor: String
  # Search index to run a user's query against.
  index: SearchIndex!
  # Limit the number of results returned.
  limit: Int
}

# Enumeration of indexes a search query can target.
enum SearchIndex {
  # Game index.
  GAME
  # User index.
  USER
  # Video on demand index.
  VOD
  # Live channel index.
  LIVE
  # Channel index.
  CHANNEL
}

# SearchOptions to customize results returned by the search query.
input SearchOptions {
  # List of indices to run a user's query against. If no targets are specified,
  # the query is run against all the indices listed in SearchIndex.
  targets: [SearchTarget!]
}

# Contains the result returned by the search engine for a particular query.
type SearchResult {
  # JSON encoded as a string.
  result: String!
}

# List of users.
type SearchStreamConnection {
  # List of matching channels results.
  edges: [SearchStreamEdge!]
  # Information about this page of videos.
  pageInfo: PageInfo!
  # The total number of items in the collection.
  totalCount: Int!
}

# An element in a paginated list of videos, and its metadata.
type SearchStreamEdge {
  # The cursor of the channel record list. This is same for one page.
  cursor: Cursor!
  # The channel result returned.
  node: Stream!
}

# A search suggestion.
type SearchSuggestion {
  # Extra data for category or channel type of search suggestion.
  content: SearchSuggestionContent
  # The part of the suggestion that matches the search query.
  highlight: SearchSuggestionHighlight!
    @deprecated(reason: "Use 'matchingCharacters' instead.")
  # The search suggestion's unique identifier.
  id: ID!
  # The part of the suggestion that matches the search query.
  matchingCharacters: SearchSuggestionHighlight
  # The search suggestion string.
  text: String!
}

# A category search suggestion.
type SearchSuggestionCategory {
  # The boxart URL for the category, provided by the endpoint.
  # Use this field for lower latency.
  #
  # The image dimensions are specifiable via the `height` and `width` parameters.
  # If `height` or `width` are not specified, the URL will contain
  # the template strings `{height}
` and/or `{width}
` in their respective places.
  boxArtURL(width: Int, height: Int): String!
  # The category.
  game: Game
  # The category's unique identifier.
  id: ID!
}

# A channel search suggestion.
type SearchSuggestionChannel {
  # The channel's unique identifier.
  id: ID!
  # Whether or not the channel is verified, provided by the endpoint.
  # Use this field for lower latency.
  isVerified: Boolean!
  # The login of the channel, provided by the endpoint.
  # Use this field for lower latency.
  login: String!
  # The profile image URL for the channel, provided by the endpoint.
  # Use this field for lower latency.
  #
  # Valid widths are 28, 50, 70, 150, 300, and 600.
  # The image height will be the same as the given width.
  profileImageURL(width: Int!): String
  # The user of the channel.
  user: User
}

# A list of search suggestions and related tracking data.
type SearchSuggestionConnection {
  # The list of search suggestions.
  edges: [SearchSuggestionEdge!]
  # As pagination is currently not supported by the backend, this will always be the zero value.
  pageInfo: PageInfo!
  # Tracking data for the search suggestions.
  tracking: SearchSuggestionTracking
}

# The types with additional content in a search suggestion.
union SearchSuggestionContent =
    SearchSuggestionCategory
  | SearchSuggestionChannel
# Edge containing the search suggestion.
type SearchSuggestionEdge {
  # As pagination is currently not supported by the backend, this will always be the zero value.
  cursor: Cursor!
  # The search suggestion.
  node: SearchSuggestion!
}

# A range that matches the search query.
type SearchSuggestionHighlight {
  # The end of the match.
  end: Int!
  # The start of the match.
  start: Int!
}

# An object containing tracking data for a search suggestion.
type SearchSuggestionTracking {
  # The unique identifier of the model instance.
  modelTrackingID: ID!
  # The unique identifier generated for every response.
  responseID: ID!
}

# Specify which index to run a user's search.
input SearchTarget {
  # When true, response will return  the total number of matching documents in
  # index for a given query. The value for limit is ignored and assumed to be zero.
  countTotalMatches: Boolean
  # Search index to run a user's query against.
  index: SearchIndex!
  # Max number of matching documents that will be returned.
  limit: Int!
}

# A list of user returned from forage by user query.
type SearchUserConnection {
  # List of matching user results.
  edges: [SearchUserEdge!]
  # Information about this page.
  pageInfo: PageInfo!
  # Total number of results.
  totalCount: Int!
}

# Element in a list of users returned from forage.
type SearchUserEdge {
  # Cursor for fetching the next page of results(only on last edge of current connection).
  cursor: Cursor!
  # The information about user.
  node: User!
}

# Season metadata.
type SeasonDetails {
  # Number of episodes.
  episodeCount: Int
  # The season number.
  season: Int
}

# Inputs for seeding a competition participant.
input SeedCompetitionParticipantInput {
  # ID of the competition.
  competitionID: ID!
  # ID of the competition player or competition team.
  participantID: ID!
  # The assigned seed value.
  seedValue: Int!
}

# SeedCompetitionParticipantPayload is the success response for seeding a competition player or competition team.
type SeedCompetitionParticipantPayload {
  # The new state of competition after seeding a competition player or competition team.
  competition: Competition
  # Used for competition mutation errors.
  error: CompetitionError
}

# An enumeration of the statuses of suggested segments.
enum SegmentsStatusType {
  # The suggested segments have successfully been created.
  COMPLETED
  # There wasn't enough data to generate suggested segments.
  NOT_ENOUGH_DATA
  # The vod is currently being processed for suggested segments.
  IN_PROGRESS
  # The backend failed to generate suggested segments.
  FAILED
}

# The segment start time input.
input SegmentStartTimeInput {
  # The day of the segment.
  day: ScheduleSegmentDay!
  # The hour of the segment 0-23.
  hour: Int!
  # The minute of the segment 0-59.
  minute: Int!
}

# Inputs for selecting a channel badge.
input SelectChannelBadgeInput {
  # Set ID of the badge to select.
  badgeSetID: ID!
  # Optional Version of the Badge to select.
  badgeSetVersion: String
  # ID of the channel this badge is selected on.
  channelID: ID!
}

# The output for the select channel badge mutation.
type SelectChannelBadgePayload {
  # Indicates if selecting the badge was successful.
  isSuccessful: Boolean
  # The channel (user object of channel) this badge is selected on.
  user: User
}

# Inputs for selecting a global badge.
input SelectGlobalBadgeInput {
  # Set ID of the badge to select.
  badgeSetID: ID!
  # Optional Version of the Badge to select.
  badgeSetVersion: String
}

# The output for the select global badge mutation.
type SelectGlobalBadgePayload {
  # Indicates if selecting the badge was successful.
  isSuccessful: Boolean
  # The user of the selected badge.
  user: User
}

# An interface to represent the logged in user's relationship to the claimable.
interface SelfClaimEdge {
  # If the user is eligible to claim the object.
  canClaim: Boolean!
  # Nullable field for the country where the user redeemed the claimable.
  countryOfResidence: String
  # The user ID that is claiming.
  id: ID!
  # Nullable status code for if the user cannot claim the object.
  statusCode: String
}

# Input for sending a chat message through subscriber-only mode with Channel Points.
input SendChatMessageThroughSubscriberModeInput {
  # The channel the message is being sent to.
  channelID: ID!
  # The client's perception of the reward's cost.
  cost: Int!
  # The user's message.
  message: String!
  # Client-set identifier for the transaction. This ID should be universally unique.
  transactionID: ID!
}

# The response from redeeming the skip subs only chat message reward.
type SendChatMessageThroughSubscriberModePayload {
  # The user's new Channel Points balance.
  balance: Int
  # The error that occurred during redemption, if any.
  error: SendCopoMessageError
  # Whether the message was flagged by Automod and held for review.
  isHeldByAutomod: Boolean
}

input SendCheerInput {
  # bits is the number of bits the message will spend (as parsed by the client).
  bits: Int!
  # content is the text to process and forward to the chat system.
  content: String!
  # Client-generated unique ID used to prevent a cheer from being re-sent (thus spending double bits).
  # The server will reject any request with an ID that has already been used.
  id: ID!
  # Optional field that dictates the user wants their cheer to appear anonymously (i.e. unassociated with their username).
  isAnonymous: Boolean = false
  # Optional field that dictates whether automod should be enabled for the cheer or not.
  isAutoModEnabled: Boolean
  # Optional field that dictates the cheer message was sent from a room, as this provides the context for what room
  # it was sent from.
  roomID: ID
  # Optional field that dictates that the user want to cheer anyways, even though they know it will be automodded.
  shouldCheerAnyway: Boolean
  # targetID is the `User.id` of the channel to send the cheer to.
  targetID: ID!
  # Optional field for Cheer 2.0 experiments.
  imageID: ID
}

type SendCheerPayload {
  # currentUser is the authenticated user object which includes the updated
  # `Wallet` info after the message bits have been spent.
  currentUser: User
  # id is the client-generated value passed in as part of the request.
  id: ID!
  # If any validation errors occur, this will not be nil.
  validationError: SendCheerValidationError
}

# Resolver for validation errors that occur on send cheer.
type SendCheerValidationError {
  # Error code that describes the validation error.
  code: SendCheerValidationErrorCode!
  # Error message that is returned from the backend service.
  message: String!
  # Optional rejected message for when the error requires frontend message changes, like AutoMod'd messages.
  messageContent: RoomMessageContent
}

# Validation error status codes.
enum SendCheerValidationErrorCode {
  # Bits amount is below the minimum.
  AMOUNT_BELOW_MIN_BITS
  # The message was auto modded.
  AUTO_MOD_MESSAGE
  # The channel was ineligible for receiving bits.
  CHANNEL_INELIGIBLE
  # The emote amount was below the minimum bits emote amount.
  EMOTE_AMOUNT_BELOW_MIN_BITS
  # The user has insufficient balance.
  INSUFFICIENT_BALANCE
  # The bits amount is invalid.
  INVALID_BITS_AMOUNT
  # The bits message is invalid.
  INVALID_BITS_MESSAGE
  # The event ID is invalid, probably because it's been used.
  INVALID_EVENT_ID
  # The message length is greater than the max message length.
  MESSAGE_LENGTH_EXCEEDED
  # The request has been throttled.
  REQUEST_THROTTLED
  # The bits emotes that were sent were greater than the max allowed.
  TOO_LARGE_BITS_EMOTE
  # The cheer was over the maximum cheer limit.
  TOO_LARGE_CHEER
  # An unknown error has occurred, but it was a validation error.
  UNKNOWN
  # The user is banned from bits.
  USER_BANNED
  # The user is ineligible to send bits.
  USER_INELIGIBLE
  # The use is suspended from sending bits.
  USER_SUSPENDED
  # The message contained Zalgo text.
  ZALGO_MESSAGE
  # The message was not processed due to an automodded pending cheer.
  AUTO_MOD_PENDING
  # The message contained term(s) blocked by the channel.
  CHANNEL_BLOCKED_TERMS
  # The anonymous message contained text that is invalid.
  INVALID_ANONYMOUS_MESSAGE
  # The bits message contained an anonymous cheermote when it's not allowed (ex: in public cheers).
  ANONYMOUS_CHEERMOTE_NOT_ALLOWED
}

# An error from redeeming a chat message Channel Points reward.
type SendCopoMessageError {
  # The error code.
  code: SendCopoMessageErrorCode
}

# Possible errors from redeeming a chat message Channel Points reward.
enum SendCopoMessageErrorCode {
  # User has previously sent an identical message.
  MSG_DUPLICATE
  # The user is suspended from Twitch.
  USER_SUSPENDED
  # The user is banned in the channel.
  USER_BANNED
  # The user is timed out in the channel.
  USER_TIMED_OUT
  # The chat is emote-only mode and the message contained text.
  EMOTE_ONLY
  # The chat is in slow mode and the user has recently sent a message.
  SLOW_MODE
  # The chat is in followers-only mode and the user has not been following long enough.
  FOLLOWERS_ONLY
  # The chat is in followers-only mode and the user is not following.
  FOLLOWERS_ONLY_ZERO
  # The chat is in subs-only mode and the user is not subbed.
  SUBS_ONLY
  # The chat is in r9k-only mode (relatively unique messages) and the message was not unique.
  R9K_MODE
  # The chat is in Blizzard connect mode and the user does not have their Blizzard account connected.
  BLIZZARD_CONNECT_MODE
  # The chat is in verified account mode and the user's account is not verified.
  VERIFIED_ACCOUNT
  # The user's message contained a blocked phrase.
  CHANNEL_SETTINGS
  # The user's message was flagged by Automod and is being reviewed.
  AUTOMOD_HELD @deprecated(reason: "use isHeldByAutomod on the payload instead")
  # The user's message was rejected for another reason- possibly intentionally hidden, such as IP block.
  MESSAGE_REJECTED
  # The request failed due to an underlying server error.
  SERVER_ERROR
  # The user does not have sufficient points to redeem the reward.
  INSUFFICIENT_POINTS
  # The client is retrying a redemption with a transaction id that has already been redeemed.
  TRANSACTION_ALREADY_COMMITTED
  # The client is retrying a redemption with a transaction id that is currently being redeemed in another request.
  TRANSACTION_IN_PROGRESS
  # The reward cost has changed since the user has tried to redeem it.
  REWARD_COST_MISMATCH
  # The reward is currently disabled.
  REWARD_DISABLED
  # The user is not allowed to redeem this reward on this channel.
  REWARD_FORBIDDEN
  # The user's message starts with a '/' like a chat command.
  MESSAGE_IS_COMMAND
  # An unknown error occurred.
  UNKNOWN
}

# Error type.
type SendExtensionMessageError {
  # Error code.
  code: SendExtensionMessageErrorCode!
}

# Possible error reasons returned by sendExtensionMessage mutation.
enum SendExtensionMessageErrorCode {
  # Unauthorized.
  UNAUTHORIZED
  # Unknown error.
  UNKNOWN
}

# Input to the sendExtensionMessage mutation.
input SendExtensionMessageInput {
  # The channelID the extension is active on.
  channelID: ID!
  # The type of the content.
  contentType: String!
  # A JWT token signed with the shared secret for this extension.
  extAuthToken: String!
  # The ID of the extension which is sending the message.
  extensionID: ID!
  # The content of the message to be sent.
  message: String!
  # The set of target message receievers to send to, e.g. "broadcast".
  targets: [String!]!
}

# Payload returned from the sendExtensionMessage mutation.
type SendExtensionMessagePayload {
  # error, if any.
  error: SendExtensionMessageError
  # Information about what rate limits, if any, were applied to this send.
  rateLimitsApplied: [SendExtensionMessageThrottleData!]
}

# Information about a rate limit throttle.
type SendExtensionMessageThrottleData {
  # Was the rate limit exceeded.
  isLimitExceeded: Boolean!
  # The limit itself.
  limit: String!
  # Name of the rate limiter applied.
  rateLimiterName: String!
  # How much quota remains.
  remainingQuota: Int!
  # Time when this rate limit will reset.
  resetsAt: Time
}

# Input for sending a highlighted chat message with Channel Points.
input SendHighlightedChatMessageInput {
  # The channel the message is being sent to.
  channelID: ID!
  # The client's perception of the reward's cost.
  cost: Int!
  # The user's message.
  message: String!
  # Client-set identifier for the transaction. This ID should be universally unique.
  transactionID: ID!
}

# The response from redeeming the highlighted chat message reward.
type SendHighlightedChatMessagePayload {
  # The user's new Channel Points balance.
  balance: Int
  # The error that occurred during redemption, if any.
  error: SendCopoMessageError
  # Whether the message was flagged by Automod and held for review.
  isHeldByAutomod: Boolean
}

type SendRoomMessageError {
  code: SendRoomMessageErrorCode!
  # On SLOW_MODE_ENFORCEMENT_FAILED, USER_CHAT_TIMED_OUT: the number of remaining
  # seconds user must wait before sending another message.
  remainingDurationSeconds: Int
  # On SLOW_MODE_ENFORCEMENT_FAILED: the number of seconds users must wait in between sending messages.
  slowModeDurationSeconds: Int
}

enum SendRoomMessageErrorCode {
  # User not allowed to chat in room.
  FORBIDDEN
  # Message failed automod check.
  AUTO_MOD_ENFORCEMENT_FAILED
  # Room is in emotes only mode and message contained non-emote text.
  EMOTE_ONLY_MODE_ENFORCEMENT_FAILED
  # Room is in R9K mode and message was not unique.
  R9K_MODE_ENFORCEMENT_FAILED
  # User is rate limited.
  RATE_LIMIT_FAILED
  # Room is in slow mode and user tried to send a message to quickly.
  SLOW_MODE_ENFORCEMENT_FAILED
  # Message failed spam check.
  SPAM_ENFORCEMENT_FAILED
  # Message contained zalgo characters.
  ZALGO_ENFORCEMENT_FAILED
  # User is banned in the channel.
  USER_CHAT_BANNED
  # User is timed out in the channel.
  USER_CHAT_TIMED_OUT
  # User is suspended from Twitch.
  USER_SUSPENDED
}

input SendRoomMessageInput {
  message: String!
  # Optional nonce which will be included in the pubsub event for this message.
  nonce: String
  roomID: ID!
}

type SendRoomMessagePayload {
  error: SendRoomMessageError
  message: RoomMessage
}

# Error code for when a mutation fails.
type SendWhisperError {
  # Error code for the failed whisper send.
  code: SendWhisperErrorCode!
}

# Possible errors returned by the sendWhisper mutation.
enum SendWhisperErrorCode {
  # Target is banned.
  TARGET_BANNED
  # Message body is empty.
  BODY_EMPTY
  # Target's settings prevent them from receiving message.
  TARGET_RESTRICTED
  # Sender does not have a verified account.
  SENDER_NOT_VERIFIED
  # Whisper was not delivered for an unspecified reason.
  NOT_DELIVERED
}

input SendWhisperInput {
  # Message to send to user.
  message: String!
  # Random string generated by the client and should be unique across messages.
  nonce: String!
  # User to send a whisper to.
  recipientUserID: ID!
}

type SendWhisperPayload {
  # If an error occurred, the error code. Otherwise null.
  error: SendWhisperError
  # The message that was sent, or null if there was an error.
  message: WhisperMessage
}

# The SEO metatag of a twitch webpage.
type SEOMetatag {
  # The attributes of the tag.
  attributes: [SEOMetatagAttribute!]!
  # The name of the tag.
  name: String!
}

# An attribute of a metatag.
type SEOMetatagAttribute {
  # The key of the attribute.
  key: String!
  # The value of the attribute.
  value: String!
}

# Series metadata.
type SeriesDetails {
  # Number of seasons.
  seasonCount: Int
}

# Sets the auto ad density for the channel.
input SetAutoAdDensityInput {
  # Input for auto ad length seconds.
  autoAdLengthSeconds: Int!
  # Input for auto ad period minutes.
  autoAdPeriodMinutes: Int!
  # Input for target ID of channel.
  targetChannelID: ID!
}

# Shows the newly updated values for autoad settings.
type SetAutoAdDensityPayload {
  # The user whose channels ad density was set.
  autoAdLengthSeconds: Int
  # Auto ad period minutes.
  autoAdPeriodMinutes: Int
  # Input for target ID of channel.
  targetChannelID: ID
}

# SetAutohostChannelsInput sets the user's list to autohost.
input SetAutohostChannelsInput {
  # ChannelIDs that will be on the list to autohost.
  channelIDs: [ID!]!
  # UserID to update autohost list for.
  userID: ID!
}

# SetAutohostChannelsPayload returns the user whose autohostChannels field had been updated.
type SetAutohostChannelsPayload {
  # User whose autohostChannels field had been updated.
  user: User
}

# Input for setting auto refill settings.
input SetAutoRefillSettingsInput {
  # The charge instrument information for starting a purchase.
  chargeInstrument: ChargeInstrumentInput!
  # The currency this should be charged in.
  currency: Currency!
  # The gross amount (of currency) that can be charged on the charge instrument.
  grossAmount: Int!
  # Optional id of the auto refill settings that are being modified.
  id: ID
  # Indicates if the profile is active.
  isEnabled: Boolean!
  # Id of the refill offer used on auto refill.
  offerID: ID!
  # The threshold amount a balance must go below to trigger a reload.
  threshold: Int!
}

# The payload for the set auto refill settings mutation.
type SetAutoRefillSettingsPayload {
  # The changed auto refill profile.
  autoRefillProfile: AutoRefillProfile
}

# Input for the set bits user settings mutation.
input SetBitsUserSettingsInput {
  # Optional field that dictates whether a user has exited out of the first cheer tutorial by clicking out of the experience.
  abandonedFirstCheerTutorial: Boolean
  # Optional field that dictates whether a user has skipped the first cheer tutorial by clicking the skip button.
  skippedFirstCheerTutorial: Boolean
}

# Payload for set bits user settings mutation.
type SetBitsUserSettingsPayload {
  # currentUser is the authenticated user object which includes the updated
  # `Wallet` info after the message bits have been spent.
  currentUser: User
}

# Sets the ad schedule preferences for the channel.
input SetChannelAdScheduleInput {
  # Input for target ID of channel.
  targetChannelID: ID!
  # Input for if channel has ad schedule enabled.
  isAdScheduleEnabled: Boolean
  # Input for desired ad break length.
  scheduledAdDurationPreferenceSeconds: Int
  # Input for desired number of seconds between each ad break.
  scheduledAdIntervalPreferenceSeconds: Int
  # Input for how long into the stream before scheduled ad breaks begin.
  adStartDelaySeconds: Int
  # Input for if channel has reminder enabled for when an ad is about to be displayed.
  isAdReminderEnabled: Boolean
  # Input for desired seconds before an ad reminder is displayed.
  adReminderTimeSeconds: Int
}

# Shows the newly updated values for channel ad schedule settings.
type SetChannelAdSchedulePayload {
  # ID of the channel.
  targetChannelID: ID
  # If channel has ad schedule enabled.
  isAdScheduleEnabled: Boolean
  # The desired ad break length.
  intervalSeconds: Int
  # The desired number of seconds between each ad.
  durationSeconds: Int
  # How long into the stream before scheduled ad breaks begin.
  startDelaySeconds: Int
  # If channel has reminder enabled for when an ad is about to be displayed.
  isAdReminderEnabled: Boolean
  # Desired seconds before an ad reminder is displayed.
  adReminderTimeSeconds: Int
}

input SetChannelFeedEnabledInput {
  # The new desired value for channel_feed_enabled.
  enabled: Boolean!
}

type SetChannelFeedEnabledPayload {
  # The user whose channel feed setting was toggled.
  user: User!
}

input SetChannelNotificationSettingInput {
  category: String!
  channelID: ID!
  platform: String!
  settingState: String!
}

type SetChannelNotificationSettingPayload {
  settingState: String!
}

# SetChannelTrailerErrorCode are the types of errors that the setChannelTrailer mutation may return.
enum SetChannelTrailerErrorCode {
  # The caller is not authorized to update the user's trailer settings.
  UNAUTHORIZED
  # The vod is longer than 60 seconds (max time for channel trailers).
  VOD_TOO_LONG
}

# Inputs to the setChannelTrailer mutation.
input SetChannelTrailerInput {
  # The channel whose trailer should be updated.
  channelID: ID!
  # The ID of the video that should be used as the channel's trailer,
  # or null if the trailer should be cleared.
  trailerVideoID: ID
}

# Output of the setChannelTrailer mutation.
type SetChannelTrailerPayload {
  # The channel whose trailer vod was modified.
  channel: Channel
  # The error if the mutation failed in an expected way, or null if the mutation was successful.
  error: SetChannelTrailerErrorCode
}

# The required input to set a user's chat pause setting.
input SetChatPauseSettingInput {
  # The desired method for a user to pause chat.
  chatPauseSetting: ChatPauseSetting!
}

# Result of a setChatPauseSetting mutation.
type SetChatPauseSettingPayload {
  # The newly saved chat pause setting.
  chatPauseSetting: ChatPauseSetting
}

# Update tags associated with CLIP, STREAM, or VOD with contentID.
input SetContentTagsInput {
  # ID of the channel owning the content.
  authorID: ID!
  # ID of content: Channel ID for Streams, Slugs for Clips, and VOD ids for VODs.
  contentID: ID!
  # Type of content being returned. Can only be of values CLIP, STREAM, or VOD.
  contentType: ContentType!
  # List of tag IDs to be replaced from the content.
  tagIDs: [ID!]!
}

# Result of mutation is the contentID.
type SetContentTagsPayload {
  # Content which tags have been updated.
  content: TaggedContent
}

# The input to be provided to the SetCreatorBadgeFlair mutation.
input SetCreatorBadgeFlairInput {
  # ID for channel to apply setting for.
  channelID: ID!
  # Setting to apply to channel setting for badge flair.
  creatorBadgeFlair: CreatorBadgeFlairSetting!
}

type SetCreatorBadgeFlairPayload {
  # Channel whose badge flair setting was updated.
  channel: Channel
}

# SetDashboardAlertQueueActivityStatusError is the error associated with SetDashboardAlertQueueActivityStatus.
type SetDashboardAlertQueueActivityStatusError {
  # The associated error code.
  code: SetDashboardAlertQueueActivityStatusErrorCode!
}

# SetDashboardAlertQueueActivityStatusErrorCode are the possible errors that this mutation returns.
enum SetDashboardAlertQueueActivityStatusErrorCode {
  # The input activity ID is invalid.
  INVALID_ACTIVITY_ID
  # The input alert status is invalid.
  INVALID_ALERT_STATUS
  # The input channel ID is invalid.
  INVALID_CHANNEL_ID
  # The alert is not found.
  NOT_FOUND
}

# Inputs to the SetDashboardAlertQueueActivityStatus mutation.
input SetDashboardAlertQueueActivityStatusInput {
  # The ID corresponding to the activity whose alert queue activity status should be updated.
  activityID: ID!
  # The value to set the status to.
  alertStatus: DashboardActivityFeedActivityAlertStatus!
  # The ID corresponding to the user whose alert queue activity status should be updated.
  userID: ID!
}

# Outputs from the SetDashboardAlertQueueActivityStatus mutation.
type SetDashboardAlertQueueActivityStatusPayload {
  # The updated activity.
  activity: DashboardActivityFeedActivity
  # The possible error returned from the service.
  error: SetDashboardAlertQueueActivityStatusError
}

# SetDashboardAlertQueuePreferenceError is the error associated with SetDashboardAlertQueuePreference.
type SetDashboardAlertQueuePreferenceError {
  # The associated error code.
  code: SetDashboardAlertQueuePreferenceErrorCode!
}

# SetDashboardAlertQueuePreferenceErrorCode are the possible errors that this mutation returns.
enum SetDashboardAlertQueuePreferenceErrorCode {
  # The input channel ID is invalid.
  INVALID_CHANNEL_ID
}

# Inputs to the SetDashboardAlertQueuePreference mutation. Only one of the boolean settings should be set at once.
input SetDashboardAlertQueuePreferenceInput {
  # If true, cannot publish alerts to the user.
  shouldEnableDNDMode: Boolean
  # If true, cannot publish bits alerts to the user.
  shouldHideBits: Boolean
  # If true, cannot publish follows alerts to the user.
  shouldHideFollows: Boolean
  # If true, cannot publish subscription gift alerts to the user.
  shouldHideGiftSubscriptions: Boolean
  # If true, cannot publish hosts alerts to the user.
  shouldHideHosts: Boolean
  # If true, cannot publish raids alerts to the user.
  shouldHideRaids: Boolean
  # If true, cannot publish regular subscriptions alerts to the user (gift subs are still shown).
  shouldHideSubscriptions: Boolean
  # The ID corresponding to the user whose alert queue preference should be updated.
  userID: ID!
}

# Outputs from the SetDashboardAlertQueuePreference mutation.
type SetDashboardAlertQueuePreferencePayload {
  # The possible error returned from the service.
  error: SetDashboardAlertQueuePreferenceError
  # The updated preferences for dashboard alert queue.
  preferences: DashboardAlertQueuePreferences
}

# Enumerates possible errors when setting a default payment method.
enum SetDefaultPaymentMethodErrorCode {
  # Must have auth credentials to set default payment method.
  UNAUTHENTICATED
  # User does not have permission to set default payment method for the targeted user.
  FORBIDDEN
  # One or more fields are invalid or missing.
  INVALID_REQUEST
  # An internal error has occurred.
  INTERNAL_ERROR
}

# The input to be provided to the setDefaultPaymentMethod mutation.
input SetDefaultPaymentMethodInput {
  # Country (ISO-3166) associated to the billing info for the customer's payment method.
  billingCountry: String
  # The last four digits of the user provided account number.
  lastFour: String
  # Payment type used via the payment provider.
  paymentType: PaymentInstrumentType!
  # The payment provider we're updating the payment method on.
  provider: PaymentProvider!
  # The token used to verify the selected payment method.
  token: String!
  # The user to set default payment method for.
  userID: ID!
}

# The result of the setDefaultPaymentMethod mutation.
type SetDefaultPaymentMethodPayload {
  # Code to describe error that occurred while setting the default payment method.
  errorCode: SetDefaultPaymentMethodErrorCode
  # User who had their payment method updated.
  user: User
}

# The required input to set a user's deleted message display setting.
input SetDeletedMessageDisplaySettingInput {
  # The desired deleted message display setting to be saved.
  deletedMessageDisplaySetting: DeletedMessageDisplaySetting!
}

# Result of a setDeletedMessageDisplaySetting mutation.
type SetDeletedMessageDisplaySettingPayload {
  # The newly saved deleted message display setting.
  deletedMessageDisplaySetting: DeletedMessageDisplaySetting
}

# SetDropBenefitsOnDropInput has fields required to update a drop's list of benefits.
input SetDropBenefitsOnDropInput {
  # The benefits that should be awarded when this drop is claimed.
  benefitIDs: [ID!]!
  # The drop to update.
  dropID: ID!
}

# SetDropBenefitsOnDropPayload returns the result of the creation/update.
type SetDropBenefitsOnDropPayload {
  # Returns the updated Campaign.
  dropCampaign: DropCampaign
  # A mapped error returned by the drops management service.
  error: DropsError
}

# SetDropCampaignAccessInput has fields required to update a campaign's access.
input SetDropCampaignAccessInput {
  # A list of channels that are allowed for this campaign.
  allowedChannels: [ID!]
  # A list of channels that are blocked from this campaign.
  blockedChannels: [ID!]
  # The campaign ID.
  campaignID: ID!
  # Is the allowedChannels list in effect. Just having allowedChannels present
  # does not mean the access list should be enabled.
  isAllowedChannelsEnabled: Boolean!
  # Is the blockedChannels list in effect. Just having blockedChannels present does not mean the block list should be enabled.
  isBlockedChannelsEnabled: Boolean!
  # A list of users that are able to view this campaign and functionalities while the campaign is in the testing state.
  testViewers: [ID!]
}

# SetDropCampaignAccessPayload returns the result of the update.
type SetDropCampaignAccessPayload {
  # Returns the updated Campaign.
  dropCampaign: DropCampaign
  # A mapped error returned by the drops management service.
  error: DropsError
}

# SetDropCampaignStatusInput has fields required to update a campaign's status.
input SetDropCampaignStatusInput {
  # The campaign ID.
  campaignID: ID!
  # The status the campaign should receive.
  status: DropCampaignStatus!
}

# SetDropCampaignStatusPayload returns the result of the creation/update.
type SetDropCampaignStatusPayload {
  # Returns the updated Campaign.
  dropCampaign: DropCampaign
  # A mapped error returned by the drops management service.
  error: DropsError
}

# SetDropCampaignSummaryInput has fields required to update a campaign summary.
input SetDropCampaignSummaryInput {
  # The redirect URL where a user can link their account.
  accountLinkURL: String!
  # The campaign ID.
  campaignID: ID!
  # The type of a campaign defines what type of drops are allowed to be added to the campaign.
  campaignType: CampaignType
  # The description of this campaign.
  description: String!
  # The URL that links to the details / marketing page for this drop.
  detailsURL: String!
  # The date at which this campaign ends and all contained drops end at the latest.
  endAt: Time!
  # The game associated with this campaign.
  gameID: ID!
  # The name of the campaign.
  name: String!
  # This is the Organization ID (RBAC) to determine access / ownership of the campaign and attached drops.
  ownerID: ID!
  # The date at which this campaign starts and all contained drops start the earliest.
  startAt: Time!
}

# SetDropCampaignSummaryPayload returns the result of the creation/update.
type SetDropCampaignSummaryPayload {
  # Returns the created/updated Campaign.
  dropCampaign: DropCampaign
  # A mapped error returned by the drops management service.
  error: DropsError
}

# SetDropEventRuleInput has the fields required to set an event based rule on a drop.
input SetDropEventRuleInput {
  # How long the viewer has to claim their reward.
  claimDurationSeconds: Int!
  # The associated drop for the rule to update.
  dropID: ID!
  # The in-game conditions that must be met for the drop to trigger.
  eventRules: [DropEventConditionInput!]!
  # A textual description of what has to occur for the drop to trigger.
  questDescription: String!
  # Name of the drop.
  questName: String!
}

# SetDropRulePayload returns the result of the rule creation.
type SetDropEventRulePayload {
  # Returns the updated Campaign.
  dropCampaign: DropCampaign
  # A mapped error returned by the drops management service.
  error: DropsError
}

# SetDropManualTriggerRuleInput has the fields required to set a manual trigger based rule on a drop.
input SetDropManualTriggerRuleInput {
  # How long the viewer has to claim their reward.
  claimDurationSeconds: Int!
  # The associated drop for the rule to update.
  dropID: ID!
}

# SetDropManualTriggerRulePayload returns the result of the rule creation.
type SetDropManualTriggerRulePayload {
  # Returns the updated Campaign.
  dropCampaign: DropCampaign
  # A mapped error returned by the drops management service.
  error: DropsError
}

# SetDropSummaryInput has fields required to update a drop's summary.
input SetDropSummaryInput {
  # The associated drop for the summary to update.
  dropID: ID!
  # The date at which this drop can no longer occur.
  endAt: Time
  # The friendly name of this drop.
  name: String!
  # The date at which this drop can start to occur.
  startAt: Time
}

# SetDrop2BenefitPayload returns the result of the creation/update.
type SetDropSummaryPayload {
  # Returns the created/updated Campaign.
  dropCampaign: DropCampaign
  # A mapped error returned by the drops management service.
  error: DropsError
}

# SetDropTimeBasedRuleInput has fields required to update a drop's rule to a minutes watched based rule.
input SetDropTimeBasedRuleInput {
  # The associated drop for the rule to update.
  dropID: ID!
  # The ID of the drop that must be claimed before you can make progress on this drop.
  preconditionDropID: ID!
  # The amount of minutes a viewer must have watched before they can claim this drop.
  requiredMinutesWatched: Int!
}

# SetDropTimeBasedRulePayload returns the result of the rule update.
type SetDropTimeBasedRulePayload {
  # Returns the updated Campaign.
  dropCampaign: DropCampaign
  # A mapped error returned by the drops management service.
  error: DropsError
}

# The required input to set a user's emote animations setting.
input SetEmoteAnimationsEnabledInput {
  # Whether emote animations should be enabled for the current user.
  isEmoteAnimationsEnabled: Boolean!
}

# Result of a setEmoteAnimationsEnabled mutation.
type SetEmoteAnimationsEnabledPayload {
  # Whether emote animations are enabled for the current user.
  isEmoteAnimationsEnabled: Boolean
}

# The required input to set a user's emote animations setting callout dismissed.
input SetEmoteAnimationsSettingCalloutDismissedInput {
  # Whether the emote animations setting callout is dismissed by the user.
  isEmoteAnimationsSettingCalloutDismissed: Boolean!
}

# Result of a setEmoteAnimationsSettingCalloutDismissed mutation.
type SetEmoteAnimationsSettingCalloutDismissedPayload {
  # Whether the emote animations setting callout is dismissed by the user.
  isEmoteAnimationsSettingCalloutDismissed: Boolean
}

# Possible errors from this mutation.
type SetEmoteModifierGroupsError {
  # Error code from the mutation.
  code: SetEmoteModifierGroupsErrorCode!
}

# Possible error codes from this mutation.
enum SetEmoteModifierGroupsErrorCode {
  # An unexpected internal server error occurred.
  INTERNAL_SERVER_ERROR
  # The provided input is invalid.
  INVALID_ARGUMENT
  # The user is not authorized to set emote modifiers.
  USER_UNAUTHORIZED
  # Unknown error returned from service.
  UNKNOWN
}

# SetEmoteModifierGroupsInput is the input required when a creator sets their emote modifiers.
input SetEmoteModifierGroupsInput {
  # Emote modifier groups to set.
  groups: [EmoteModifierGroupInput!]!
}

# The result of setting emote modifier groups for a user.
type SetEmoteModifierGroupsPayload {
  # Error from the mutation if it exists.
  error: SetEmoteModifierGroupsError
  # The modified emote groups that were set.
  groups: [EmoteModifierGroupPayload!]
}

# SetExtensionConfigurationError returns an error code for the frontend to handle.
type SetExtensionConfigurationError {
  # The standardized code used by the frontend.
  code: SetExtensionConfigurationErrorCode!
}

# The standardized codes used by the frontend.
enum SetExtensionConfigurationErrorCode {
  # User is unable to set the configuration.
  UNAUTHORIZED
  # An unknown error occurred.
  UNKNOWN
}

# The required input for a setExtensionConfiguration mutation.
input SetExtensionConfigurationInput {
  # The channel to which this configuration applies to.
  channelID: ID!
  # The version of the configuration.
  configVersion: String!
  # The configuration string to post.
  content: String!
  # The extension ID.
  extensionID: ID!
}

# SetExtensionConfiguration returns the Input as the extensions configuration endpoint returns a 204.
type SetExtensionConfigurationPayload {
  # The channel to which this configuration applies to.
  channelID: ID
  # The version of the configuration.
  configVersion: String
  # The configuration string to post.
  content: String
  # Error code for the frontend to handle.
  error: SetExtensionConfigurationError
  # The extension ID.
  extensionID: ID
}

# SetExtensionFeatureFlagsError is wrapper for error associated with the setExtensionFeatureFlags mutation.
type SetExtensionFeatureFlagsError {
  # Error code.
  code: SetExtensionFeatureFlagsErrorCode!
  # The missing installation id if got EXTENSION_NOT_INSTALLED error.
  missingInstallationID: ID
}

# SetExtensionFeatureFlagsErrorCode is an error code associated with SetExtensionFeatureFlagsError.
enum SetExtensionFeatureFlagsErrorCode {
  # User is unable to make modifications to the extension.
  UNAUTHORIZED
  # Channel id is invalid, for example, is empty.
  INVALID_CHANNEL_ID
  # The extension is not installed on the channel.
  EXTENSION_NOT_INSTALLED
}

# The required input to set feature flags for an installation.
input SetExtensionFeatureFlagsInput {
  # Optional value to enable/disable chat for the specified installation.
  canSendChat: Boolean
  # Optional value to enable/disable bits for the specified installation.
  canUseBits: Boolean
  # Optional value for dynamicManagement flag on games.
  dynamicManagement: [ExtensionDynamicManagementInput]
  # The ID of the extension installation to set feature flags for.
  id: ID!
}

# The result of setting feature flags on an installation.
type SetExtensionFeatureFlagsPayload {
  # The error when the mutation fails to set feature flags.
  error: SetExtensionFeatureFlagsError
  # The new state of the installation after the setExtensionFeatureFlags mutation.
  installedExtension: ExtensionInstallation
}

# The required input to set oauth on an installation.
input SetExtensionInstallationOAuthInput {
  # The installation ID we're setting the oauth token for.
  id: ID!
  # The OAuth token created for the extension.
  oauthToken: String!
}

# The resulting installedExtension state after setting OAuth.
type SetExtensionInstallationOAuthPayload {
  # The new state of the installation after the setExtensionInstallationOAuth mutation.
  installedExtension: ExtensionInstallation
}

# SetGameDropAccountLinkClientInput has fields necessary to update a game's account link
# client ID used to verify a user has connected their in-game account.
input SetGameDropAccountLinkClientInput {
  # The client ID used to verify that users have linked their accounts properly.
  clientID: ID!
  # The ID of the game to link the client ID to.
  gameID: ID!
}

# SetGameDropAccountLinkClientPayload returns the result of the update.
type SetGameDropAccountLinkClientPayload {
  # A mapped error returned by the drops management service.
  error: DropsError
  # The updated game record.
  game: Game
}

# SetHeroAsAvatarError contains details about an error that occured when copying the hero to an avatar.
type SetHeroAsAvatarError {
  # The type of error that occured when copying the hero to the avatar.
  code: SetHeroAsAvatarErrorCode!
}

# SetHeroAsAvatarErrorCode defines a client error that occured while copying the hero to an avatar.
enum SetHeroAsAvatarErrorCode {
  # The requesting user did not have permission to update the avatar.
  FORBIDDEN
  # Some other unexpected error occured.
  UNKNOWN_ERROR
}

# SetHeroAsAvatarInput contains the parameters to copy the user's hero to their avatar.
# no parameters are required, because this mutation copies the requesting user's hero to
# the requesting user's avatar, but we're passing the heroID here
# because of a bug in the way `make check` works.
input SetHeroAsAvatarInput {
  # The ID of the hero to copy to its owning user's profile picture.
  heroID: ID!
}

# SetHeroAsAvatarPayload is the response after setting the avatar.
type SetHeroAsAvatarPayload {
  # The error that occured.
  # Null if the operation was successful.
  error: SetHeroAsAvatarError
  # The user object post mutation - null if error.
  user: User
}

# The required input to set a role's moderator logs' access.
input SetModLogsAccessInput {
  # The access level to moderator logs to be given to the role.
  accessLevel: ModLogsAccessLevel!
  # The Channel for which to set moderator log access.
  channelID: ID!
  # The user role for which to set the moderator log access permission.
  channelRole: ChannelUserRole!
}

# Result of a setModLogsAccess mutation.
type SetModLogsAccessPayload {
  # The access level of the role set.
  modLogsAccess: ModLogsAccess
}

# The required input to set a user's mod view settings relating to turorial.
input SetModViewSettingsInput {
  # The time the tutorial on the mod view page was seen.
  tutorialSeenAt: Time!
  # The viewed state of the tutorial on the mod view page.
  tutorialState: TutorialState!
}

# Result of a setModViewSettings mutation.
type SetModViewSettingsPayload {
  # The newly resolved modviewsettings resolver.
  modViewSettings: ModViewSettings
}

input SetNotificationSettingInput {
  category: String!
  platform: String!
  settingState: String!
}

type SetNotificationSettingPayload {
  settingState: String!
}

# SetOverwatchLeagueTeamPreferenceInput contains the OverwatchLeagueTeamPreference ID to set.
input SetOverwatchLeagueTeamPreferenceInput {
  # The channelID from the channel this event is taking place on.
  OverwatchTeamPreferenceOptionID: ID!
}

# SetOverwatchLeagueTeamPreferencePayload is the success response for setting an Overwatch League Team preference, and
# the corresponding updated OverwatchLeagueTeamPreference struct.
type SetOverwatchLeagueTeamPreferencePayload {
  # A possible error returned from the service.
  error: SetOverwatchTeamPreferenceError
  # The updated OverwatchLeagueTeamPreference struct.
  overwatchLeagueTeamPreference: OverwatchLeagueTeamPreference
}

# Error code for an error that occurs while claiming the bounty.
type SetOverwatchTeamPreferenceError {
  # Error code for error that occurred while claiming the bounty.
  code: SetOverwatchTeamPreferenceErrorCode!
}

# Error types recognized by the SetOverwatchLeagueTeamPreference mutation.
enum SetOverwatchTeamPreferenceErrorCode {
  # Unknown error being returned from service.
  UNKNOWN
}

# The required input for a setPreferredLanguageTag mutation.
input SetPreferredLanguageTagInput {
  # The preferred language tag to set onto the user.
  preferredLanguageTag: LanguageTag!
  # The user to modify.
  userID: ID!
}

# The result of a setPreferredLanguageTag mutation.
type SetPreferredLanguageTagPayload {
  # The user whose preferred language tag was changed.
  user: User
}

# Error from a failed currently playing track mutation.
type SetRadioCurrentlyPlayingError {
  # Mutation error code.
  code: SetRadioCurrentlyPlayingErrorCode
}

# Currently playing error codes.
enum SetRadioCurrentlyPlayingErrorCode {
  # The ID provided was malformed.
  INVALID_ID
  # Permission denied to add/update a currently playing item.
  PERMISSION_DENIED
  # No record found for the request params.
  NO_RECORD
}

# The required input to set radio track information currently being played.
input SetRadioCurrentlyPlayingInput {
  # The type of content the ID maps to.
  contentType: RadioCurrentlyPlayingType
  # Whether the track is currently playing or not.
  isCurrentlyPlaying: Boolean!
  # The ID of the source.
  sourceID: ID
  # The ID of the currently playing track.
  trackID: ID
}

# Result of a setRadioCurrentlyPlaying mutation.
type SetRadioCurrentlyPlayingPayload {
  # The currently playing radio track addition result.
  currentTrack: RadioCurrentTrackResponse
  # Error code.
  error: SetRadioCurrentlyPlayingError
}

# The required input to set a user's readable chat colors setting.
input SetReadableChatColorsEnabledInput {
  # Whether readable chat colors should be enabled for the current user.
  isReadableChatColorsEnabled: Boolean!
}

# Result of a setReadableChatColorsEnabled mutation.
type SetReadableChatColorsEnabledPayload {
  # Whether readable chat colors are enabled for the current user.
  isReadableChatColorsEnabled: Boolean!
}

# SetResourceRestrictionInput sets a restriction for the given resourceID.
input SetResourceRestrictionInput {
  # The ID of the resource to set the restriction on.
  resourceID: ID!
  # The type of resource that will be restricted.
  resourceType: RestrictionResource!
  # The restriction options, if any, to apply to the restriction being created.
  restrictionOptions: [ResourceRestrictionOption!]
  # The type of restriction that should be placed onto the channel. If empty, the restriction will be deleted.
  restrictionType: ResourceRestrictionType
}

# SetResourceRestrictionPayload returns the updated restriction for a channel.
type SetResourceRestrictionPayload {
  # The channel if a live resource restriction was updated.
  channel: Channel
  # The stream if a live resource restriction was updated.
  stream: Stream
  # The video if a video resource restriction was updated.
  video: Video
}

# An error that has been mapped from a Reminder service twirp error. Can sometimes include messages.
type SetScheduleReminderError {
  # The error code.
  code: SetScheduleReminderErrorCode!
  # The error message string.
  message: String
}

# Enum for set schedule reminders errors.
enum SetScheduleReminderErrorCode {
  # The error code is unknown.
  UNKNOWN
  # The request for setting a reminder was invalid.
  INVALID_ARGUMENT
  # The schedule segment you're attempting to set a reminder for was not found.
  NOT_FOUND
  # The schedule segment you're attempting to set a reminder for was cancelled.
  FAILED_PRECONDITION
}

# SetScheduleReminderInput has fields required to set a schedule event reminder.
input SetScheduleReminderInput {
  # The ID of the segment to set a reminder for.
  segmentID: ID!
  # Whether the reminder should be enabled or disabled.
  shouldEnable: Boolean!
}

# SetScheduleReminderPayload returns the result of the creation/update.
type SetScheduleReminderPayload {
  # A mapped error returned by the Reminder service.
  error: SetScheduleReminderError
  # The new reminder state, if operation completed with no error.
  isEnabled: Boolean
}

# SetSessionStatusInput represents a user's status within a single session (browser tab, game, desktop application,
# mobile application, etc.).
input SetSessionStatusInput {
  # activity is the action the user is performing in your application. The purpose of an activity is to allow the user's
  # friends and related users to join in on whatever the user is doing. If the user is not performing any action that
  # other users can join in on (e.g. watching a VOD, browsing their settings page) or is not performing any action at
  # all, this should be set to null.
  activity: ActivityInput
  # availability is the state of the user's session in your application. You should set it to ONLINE if the user is
  # known to be at their device, IDLE if they are not, and OFFLINE if your application is currently terminating.
  #
  # Note that if your application fails to send an OFFLINE heartbeat before terminating, the session will automatically
  # expire after some time without a heartbeat.
  availability: AvailabilityInput!
  # sessionID must be supplied and can be any string unique to this session. Generating a random UUID when your
  # application starts and sending it for each setSessionStatus is a good idea.
  #
  # Each instance of your application should send the same ID for each of its setSessionStatus calls, but two instances
  # of your application running at the same time should never have the same session ID.
  sessionID: String!
}

type SetSessionStatusPayload {
  # The number of seconds your application should wait before sending another setSessionStatus. If your application does
  # not call setSessionStatus again within roughly this duration, it will be assumed to have terminated unexpectedly and
  # its session status for this user will expire.
  setAgainInSeconds: Int!
  # The modified user.
  user: User
}

# Inputs to the setSquadStreamPrimaryPlayer mutation.
input SetSquadStreamPrimaryPlayerInput {
  # ID of the device viewing squad stream.
  deviceID: ID!
  # ID of the channel as the current primary player.
  primaryPlayerID: ID!
  # ID of the squad stream.
  squadID: ID!
}

# Outputs to the setSquadStreamPrimaryPlayer mutation.
type SetSquadStreamPrimaryPlayerPayload {
  # The current primary player of the squad stream.
  primaryPlayer: User
}

# Error from set unban requests settings mutation.
type SetUnbanRequestsSettingsError {
  # Error code from the set unban requests settings mutation.
  code: SetUnbanRequestsSettingsErrorCode!
}

# Error codes for from set unban requests settings mutation.
enum SetUnbanRequestsSettingsErrorCode {
  # Unknown error.
  UNKNOWN
  # User is not authorized to set unban request settings on the channel.
  UNAUTHORIZED
  # User attempted to set with an invalid value.
  INVALID_VALUE
}

# Required input to set unban requests settings on a channel.
input SetUnbanRequestsSettingsInput {
  # The channel on which to update settings for.
  channelID: ID!
  # The amount of time after a ban before an unban request can be made.
  cooldownMinutes: Int!
  # Whether unban requests are allowed to be created on the channel.
  isEnabled: Boolean!
}

# Result of setting a channel's unban requests settings.
type SetUnbanRequestsSettingsPayload {
  # Error from attempting to set unban requests settings.
  error: SetUnbanRequestsSettingsError
  # The updated settings on the channel.
  settings: UnbanRequestsSettings
}

# SetUserResidenceInput is input required to set a user's residence.
input SetUserResidenceInput {
  # User's country in ISO alpha-2.
  countryCode: String!
  # Target user for setting residence.
  userID: ID!
  # User's zip code.
  zipCode: String
}

# SetUserResidencePayload is the response from the SetUserResidence mutation.
type SetUserResidencePayload {
  # User whose residence was set for.
  user: User
}

type Share {
  # The user that created this share.
  author: User
  # Time the share was created by the user.
  createdAt: Time
  # Share ID.
  id: ID!
  # The item that was shared.
  target: ShareTarget
}

union ShareTarget = Clip | Post | Stream | Video
# An ordered list of content to render with metadata on the content.
type Shelf {
  # The ordered content for the shelf.
  content: ShelfContentConnection!
  # How to present the content in the shelf.
  displayType: String!
  # A unique identifier for the shelf for use in tracking and pagination.
  id: ID!
  # The title for the shelf.
  title: ShelfTitle!
  # Information used for recommendation tracking.
  trackingInfo: TrackingInfo!
}

# Paginated list of Shelves. (pagination not yet implemented)
# Implements the Relay cursor connections specification.
# See: https://facebook.github.io/relay/graphql/connections.htm.
type ShelfConnection {
  # The list of shelves to display.
  edges: [ShelfEdge!]
  # As pagination is currently not supported by the backend, this will always be the zero value.
  pageInfo: PageInfo!
}

# The content to render in a shelf.
union ShelfContent = Clip | Game | Stream | Tag | Video
# The list of content to render in a shelf.
type ShelfContentConnection {
  # The list of content to display.
  edges: [ShelfContentEdge!]
  # As pagination is currently not supported by the backend, this will always be the zero value.
  pageInfo: PageInfo!
}

# The content to render in a shelf.
type ShelfContentEdge {
  # As pagination is currently not supported by the backend, this will always be the zero value.
  cursor: Cursor!
  # The metadata to show for each content edge.
  metadata: ShelfContentMetadata
  # The underlying content to render.
  node: ShelfContent
  # Used to associate promotions for tracking.
  promotionsCampaignID: ID!
  # Used to determine what the source of the shelf content is from.
  sourceType: SourceType!
  # Used in client tracking.
  trackingID: ID!
}

# The metadata for content to render in a shelf.
type ShelfContentMetadata {
  # Whether the content has a live event.
  hasLive: Boolean!
  # The localized subtitle for a content item in a shelf.
  subtitle: ShelfTitle
  # The localized title for a content item in a shelf.
  title: ShelfTitle!
}

# Contains information about a Shelf's relationship to a given page (connection),
# and the Shelf itself.
type ShelfEdge {
  # As pagination is currently not supported by the backend, this will always be the zero value.
  cursor: Cursor!
  # The shelf.
  node: Shelf!
}

# The title for the shelf.
type ShelfTitle {
  # A resource to interpolate into the title string.
  context: ShelfTitleContext
  # The fallback localized title, only to be used if client fails to parse the localizedTitleTokens.
  fallbackLocalizedTitle: String!
  # The name of the shelf being presented, used for backwards compatibility. Allows for localization and interpolation.
  key: String!
  # The localized shelf title in the form of a list of tokens.
  localizedTitleTokens: [TitleTokenEdge]!
}

# Metadata used to render the shelf title.
union ShelfTitleContext = Game
# A set of options for configuring which shelf data to return to the user.
input ShelvesAvailableOptions {
  # The ID of the collection. Only valid when shelfType is set to
  # VideoShelfType.COLLECTION.
  collectionID: ID
  # The ID of the game shelf to query. Only valid when shelfType is set to
  # VideoShelfType.GAME_VIDEOS.
  gameID: ID
  # Which shelf type to query. Currently required.
  # In future, omitting this option returns all valid shelves.
  shelfType: VideoShelfType
}

# A set of options to configuring how the shelves data is returned to the consumer.
input ShelvesOptions {
  # Should indicate whether the response includes empty shelves.
  includeEmpty: Boolean = false
}

# A short video from a ShortVideoFeed and its relevant metadata.
type ShortVideo {
  # The actual short form video content to display.
  content: ShortVideoContent
  # The ID of the short form video.
  id: ID!
  # All of the reactions on this short form video.
  reactions: [ShortVideoReaction!]!
}

# All of the different content types that make up "short form video".
union ShortVideoContent = Clip
# A paginated list of short videos.
type ShortVideoFeedConnection {
  # The list edges contain ShortVideoFeedEdges with pagination information.
  edges: [ShortVideoFeedEdge!]!
  # Information about pagination in this connection.
  pageInfo: PageInfo!
}

# An element in a paginated list of short videos.
type ShortVideoFeedEdge {
  # Uniquely identifies this item's position in a connection.
  cursor: Cursor!
  # The short video.
  node: ShortVideo
}

# Options used to determine the content returned in the short video feed.
input ShortVideoFeedOptions {
  # The platform of the viewer -- used to curate content in the feed.
  platform: ShortVideoFeedPlatform
  # The type of short video feed to return.
  type: ShortVideoFeedType
}

# The platform from which the short video feed is requested.
enum ShortVideoFeedPlatform {
  # The mobile web site.
  MOBILE_WEB
  # The iOS app.
  IOS
  # The Android app.
  ANDROID
}

# The type of short form video feed.
enum ShortVideoFeedType {
  # Return a video feed based off the channels the user is following.
  FOLLOWING
  # Return a video feed based off an recommendations model.
  RECOMMENDED
}

# An aggregated counter for the contained emote to display how many reactions to a ShortVideo there have been.
type ShortVideoReaction {
  # The number of times this emote has been used to react to this video.
  count: Int!
  # The emote that was used to react.
  emote: Emote
  # The ID is the same as emote.ID.
  id: ID!
}

# The type representing Community Points Smart Costs Acknowledgements.
type SmartCostsAcknowledgement {
  # The last acknowledged cost.
  lastAcknowledgedCost: Int!
  # The type of automatic reward the smart costs acknowledgement is for.
  rewardType: CommunityPointsAutomaticRewardType!
}

# The input representing Community Points Smart Costs Acknowledgements.
input SmartCostsAcknowledgementInput {
  # The last acknowledged cost.
  lastAcknowledgedCost: Int!
  # The type of automatic reward the smart costs acknowledgement is for.
  rewardType: CommunityPointsAutomaticRewardType!
}

# Wrapper around the standard emoticon groups for Prime Emoticons.
type SmiliesSet {
  # The list of emotes which belong to this set.
  emotes: [Emote!]
  # ID for the current smilies set.
  id: ID
}

# Inputs to the SnoozeAd mutation.
input SnoozeAdInput {
  # targetChannelID is the target ID of the channel.
  targetChannelID: ID!
  # snoozeDuration is the requested time in seconds to snooze.
  snoozeDuration: Int
}

# Outputs from the SnoozeAd mutation.
type SnoozeAdPayload {
  # status gives the status code of the Vader request (SUCCESS or ERROR).
  status: SnoozeAdStatusCode
}

# Snooze status code depending on Vader response.
enum SnoozeAdStatusCode {
  # Success status if snooze endpoint successfully called.
  SUCCESS
  # Error status if snooze endpoint called but failed.
  ERROR
}

# A social media item that is an attribute of Channel.
type SocialMedia {
  # The social media's unique identifier.
  id: ID!
  # The name of the domain which will be used to determine which favicon to render.
  name: String
  # The label displayed to the client.
  title: String!
  # The web address to a social media website.
  url: String!
}

type SocialStream implements RecommendedStream {
  # The friend who generated the recommendation.
  friend: User
  # The recommended stream.
  stream: Stream
  # The type of recommendation. Different types contain different metadata about why the recommendation was made.
  type: StreamRecommendationType
}

# Sort direction.
enum SortOrder {
  # Ascending (A-Z, 1-9).
  ASC
  # Descending (Z-A, 9-1).
  DESC
}

# The type of source the shelf content is coming from.
enum SourceType {
  # The target source is from promotional campaign that is free.
  PROMOTION
  # The target source is from recommendations.
  RECOMMENDED
  # The target source is from a promotional campaign that is paid.
  SPONSORED
  # The target source is from a fallback candidate.
  POPULAR
  # The target source is from a boost promotional campaign.
  COMMUNITY_BOOST
  # The target source is unknown so we default to UNKNOWN.
  UNKNOWN_SOURCE_TYPE
}

# Error returned when attempting to spend subscription credit.
type SpendSubscriptionCreditError {
  # Error code for error that occured while attempting to spend subscription credit.
  code: SpendSubscriptionCreditErrorCode!
}

# Possible error codes returned when attempting to spend subscription credit.
enum SpendSubscriptionCreditErrorCode {
  # Occurs if a Twitch Prime user attempts to spend subscription credit that is (still) unavailable.
  UNABLE_TO_SPEND
  # Occurs if a Twitch Prime user attempts to spend multiple times, acting as a flag for fraud.
  TOO_MANY_RECENT_SPENDS
}

# Input requires the broadcaster to be payed and user to deduct credit.
input SpendSubscriptionCreditInput {
  # The user id of streamer being subscribed to.
  broadcasterID: String!
  # Twitch user ID.
  userID: ID!
}

# Mutated data after spending the subscription credit.
type SpendSubscriptionCreditPayload {
  # Possible error returned from the service.
  error: SpendSubscriptionCreditError
  # The modified subscription benefit data.
  subscriptionBenefit: SubscriptionBenefit
  # Twitch user ID.
  userID: ID!
}

# The connection of sponsored cheermote channel settings to user.
type SponsoredCheermoteChannelSettingsConnection {
  # The list of key pool edges associated with the user.
  edges: [SponsoredCheermoteChannelSettingsEdge!]!
  # The metadata about having more key pools to fetch, or if there is a previous page of key pools.
  pageInfo: PageInfo!
  # The total number of key pools for the given user.
  totalCount: Int!
}

# The sponsored cheermote channel settings edge which contains our cursor and node.
type SponsoredCheermoteChannelSettingsEdge {
  # The cursor of the edge, which is also the key pool ID.
  cursor: Cursor!
  # The node of the edge, which contains all information about the key pool.
  node: SponsoredCheermoteChannelSettingsNode
}

# The information associated with a given sponsored cheermote channel setting.
type SponsoredCheermoteChannelSettingsNode {
  # Brand's image to display, in the form of a URL.
  brandImageURL: String!
  # Brand name to display.
  brandName: String!
  # Time the campaign ends.
  endTime: Time!
  # The campaign ID, which is unique.
  id: ID!
  # The opt in status of the campaign.
  isOptedIn: Boolean!
  # Time the campaign starts.
  startTime: Time!
  # Thresholds for matching on sponsored cheering.
  thresholds: [CheermoteCampaignThreshold!]!
}

# A squad stream represents a group of broadcasters that are streaming together.  When a squad
# stream is live, viewers can opt to watch the streams of all its members together from a
# single view.
#
# Squad streams are created by a broadcaster who invites other broadcasters to participate.
# Each broadcaster who accepts an invitation becomes a member of the squad stream and can also
# invite other broadcasters to participate.  At the moment, a squad stream can have up to
# four members and a broadcaster can only belong to a single squad stream.
#
# A squad stream ends when all its members leave or stop streaming.
type SquadStream {
  # The ID of the squad stream.
  id: ID!
  # The invitations with the given status that have been sent by members to other users to join to squad stream.
  invitations(status: SquadStreamInvitationStatus!): [SquadStreamInvitation!]
  # Broadcasters who are currently participating in the squad stream.
  members: [User!]
  # The owner can remove members from the squad stream.
  owner: User
  # The current status of the squad stream.
  status: SquadStreamStatus!
}

# Determines who can send the user invitations to join a squad stream.
enum SquadStreamIncomingInvitePolicy {
  # This user should never receive invitations.
  NONE
  # This user can receive invitations from friends, teammates and followed channels.
  NETWORK
  # This user can receive invitations from anyone.
  ALL
}

# SquadStreamInvitation represents an invitation sent by a member of a squad stream to another user to
# join the squad stream.
type SquadStreamInvitation {
  # When the invitation was created.
  createdAt: Time!
  # ID of the invitation.
  id: ID!
  # Network type of the invitation. This field is only non nil when the invitation
  # is fetched for User.IncomingSquadStreamInvitations.
  networkType: SquadStreamInvitationNetworkType
  # If the invitation's status is rejected, the reason for the rejection.
  reasonRejected: SquadStreamInvitationRejectedReason
  # The user that the invitation is sent to.
  recipient: User
  # The user that sent the invitation.
  sender: User
  # The squad stream that the recipient is invited to join.
  squadStream: SquadStream
  # The status of the invitation.
  status: SquadStreamInvitationStatus!
}

# List of Squad Stream invitations.
type SquadStreamInvitationConnection {
  # The elements of the list.
  nodes: [SquadStreamInvitation!]
  # The total count of invitations.
  totalCount: Int
}

# Describes the network type of a squad stream invitation.
enum SquadStreamInvitationNetworkType {
  # The invitation is from within the recipient's network (friends, teammates and followed channels).
  IN_NETWORK
  # The invitation is from outside of the recipient's network.
  OUT_OF_NETWORK
}

# Describes the reason a squad stream invitation was rejected.
enum SquadStreamInvitationRejectedReason {
  # The recipient rejected the invitation.
  RECIPIENT_REJECTED
  # The recipient cannot access the squad stream product (e.g. due to missing transcode, partner-only launch).
  RECIPIENT_CANNOT_ACCESS_SQUAD_STREAM
  # The recipient does not allow the sender of the invitation to invite them (e.g. due to their squad stream settings).
  RECIPIENT_CANNOT_BE_INVITED
}

# Describes the current state of a squad stream invitation.
enum SquadStreamInvitationStatus {
  # The recipient has accepted the invitation.
  ACCEPTED
  # A squad stream owner has deleted the invitation.
  DELETED
  # The invitation has been sent to the recipient and the sender is waiting for a response.
  PENDING
  # The recipient has rejected the invitation.
  REJECTED
  # The invitation has an unknown status.
  UNKNOWN
}

# A user's squad stream settings.
type SquadStreamSettings {
  # Denotes whether or not a user can access squad management features like
  # accepting/receiving invites and viewing the Squad Stream dashboard widget.
  canAccessSquads: Boolean!
  # Determines who can send the user invitations to join a squad stream.
  # Resolves for anyone who can access the user's dashboard (editors, staff, etc.).
  incomingInvitePolicy: SquadStreamIncomingInvitePolicy
}

# Describes the status of a squad stream.
enum SquadStreamStatus {
  # The squad stream is live and is being broadcast to viewers.
  LIVE
  # The squad stream is being set up, and should not be shown to viewers.
  PENDING
  # The squad stream has ended.
  ENDED
  # The squad stream has an unknown status.
  UNKNOWN
}

# A link between a single sign-on (SSO) app and a Twitch account.
# SSO apps are the Twitch apps on console and smart TV.
type SSOLink {
  # The name of the SSO app that is linked to the authenticated user's Twitch account.
  app: String @deprecated(reason: "To be removed.")
  # The identifier of the device or user account on XboxLive, PSN, etc.
  # that is linked to the authenticated user's Twitch account.
  ssoID: String
}

# StartAdError ...
type StartAdError {
  # code is the code for the error that occurs while trying to run an ad break.
  code: StartAdErrorCode!
  # retryAfterSeconds is the amount of time in seconds remaining before user can run another ad.
  retryAfterSeconds: Int
}

# StartAdErrorCode ...
enum StartAdErrorCode {
  # The user has requested an ad break before the rate limit timer has expired.
  RATE_LIMITED
  # The user is not authorized to run an ad break on the requested channel.
  USER_NOT_AUTHORIZED
  # An unknown error occured while trying to run an ad break.
  UNKNOWN_ERROR
}

# StartAdInput ...
input StartAdInput {
  # channelID is the ID of the channel the ad will run on.
  channelID: ID!
  # lengthSeconds is the requested ad break length in seconds (30s ad, 60s ad, etc).
  lengthSeconds: Int
  # The source of where this call came from.
  trigger: StartAdTrigger
}

# StartAdPayload ...
type StartAdPayload {
  # adSession is the response object from an ad request.
  adSession: AdSession
  # error is the StartAdError object from a failed request.
  error: StartAdError
}

# StartAdTrigger is what triggered the ad.
enum StartAdTrigger {
  # The ad was triggered from the quick actions button on the dashboard.
  QUICK_ACTION
  # The ad was triggered automatically by the ads manager.
  ADS_MANAGER
}

# Error code for an error that occurs while starting the bounty.
type StartBountyError {
  # Error code for error that occurred while starting the bounty.
  code: StartBountyErrorCode!
}

# Error types recognized.
enum StartBountyErrorCode {
  # Invalid parameter in the request.
  INVALID_PARAMETER
  # The bounty cannot be started because it is not live.
  BOUNTY_NOT_LIVE
  # The stream title contains banned words.
  STREAM_TITLE_BANNED_WORDS
  # The stream title is too long.
  STREAM_TITLE_TOO_LONG
  # The user is not authorized to start the bounty.
  UNAUTHORIZED
  # Unknown error being returned from service.
  UNKNOWN_ERROR
}

# StartBountyInput includes the bounty a user is trying to start.
input StartBountyInput {
  # Unique Identifier for the bounty.
  bountyID: ID!
  # Title of the stream for the bounty. Must start with #sponsored.
  title: String!
  # UserID of the user that will start the bounty.
  userID: ID!
}

# Data that was mutated after starting the bounty.
type StartBountyPayload {
  # The possible error returned from the service.
  error: StartBountyError
  # The started bounty with the updated status.
  startedBounty: Bounty
  # The user that now has the started bounty.
  user: User
}

# Error associated with a failed attempt to start a cloud broadcast.
type StartCloudBroadcastError {
  # The cause of the error.
  cause: StartCloudBroadcastErrorCause!
  # An optional error message associated with the error.
  message: String
}

# Errors returned by attempting to start a cloud broadcast.
enum StartCloudBroadcastErrorCause {
  # No subscription was found for the given channel and provider.
  NO_SUBSCRIPTION
  # An unknown error occurred, use message for more information.
  UNKNOWN
}

# Input for remotely and asynchronously starting a cloud broadcast for the given channelID.
input StartCloudBroadcastInput {
  # The desired framerate of the broadcast.
  framerate: Int
  # The desired height of the broadcast.
  height: Int
  # The cloud provider to send a start cloud broadcast request to..
  providerID: ID!
  # The desired width of the broadcast.
  width: Int
}

# Response to start a cloud broadcast.
type StartCloudBroadcastPayload {
  # If the broadcast was successfully started, properties of that broadcast.
  broadcast: CloudBroadcast
  # An optional error if the mutation failed, contaning actionable errors.
  error: StartCloudBroadcastError
}

# StartPayoutOnboardingWorkflowInput returns the required input when starting a new workflow for payout onboarding.
input StartPayoutOnboardingWorkflowInput {
  # TargetUserID is the ID of the user whose workflow will be started.
  targetUserID: ID!
}

# StartPayoutOnboardingWorkflowPayload returns a new workflow when starting payout onboarding.
type StartPayoutOnboardingWorkflowPayload {
  # A new workflow status.
  workflow: PayoutOnboardingWorkflow
}

# Input for starting a PV Watch Party.
input StartWatchPartyInput {
  # Amazon LWA access token.
  accessToken: String!
  # Channel ID of the creator.
  channelID: ID!
  # Catalog GTI to use.
  watchPartyItemID: ID!
}

# Returns the new Watch Party and all decoration/details.
type StartWatchPartyPayload {
  # Error if the user's token expired.
  error: WatchPartyError
  # The watch party that was started.
  watchParty: WatchParty
}

# Stat cards contains the required target for a milestone and the current progress.
type StatCreatorHomeCard implements CreatorHomeCard {
  # The type of the card, i.e. "STAT_FOLLOWERS_CARD".
  type: String!
  # currentValue indicates where the creator is in regards to a required goal.
  # i.e Get 50 Followers, broadcaster has "19".
  currentValue: Float!
  # targetValue indicates the target for a given stat.
  # i.e Get "50" Followers, broadcaster has 19.
  targetValue: Float!
}

# Error code for an error that occurs while stopping the bounty.
type StopBountyError {
  # Error code for error that occurred while stopping the bounty.
  code: StopBountyErrorCode!
}

# Error types recognized.
enum StopBountyErrorCode {
  # Invalid parameter in the request.
  INVALID_PARAMETER
  # The user is not authorized to stop the bounty.
  UNAUTHORIZED
  # Unknown error being returned from service.
  UNKNOWN_ERROR
}

# StopBountyInput includes the bounty a user is trying to stop.
input StopBountyInput {
  # Unique Identifier for the bounty.
  bountyID: ID!
  # UserID of the user that will stop the bounty.
  userID: ID!
}

# Data that was mutated after stopping the bounty.
type StopBountyPayload {
  # The possible error returned from the service.
  error: StopBountyError
  # The stopped bounty with the updated status.
  stoppedBounty: Bounty
  # The user that now has the stopped bounty.
  user: User
}

# An error associated with a failed call to stopCloudBroadcast.
type StopCloudBroadcastError {
  # The cause of the error.
  cause: StopCloudBroadcastErrorCause!
  # Optional message associated with an error.
  message: String
}

# Errors returned by attempting to stop a cloud broadcast.
enum StopCloudBroadcastErrorCause {
  # No broadcast was found for the given channel and provider.
  # Either because the broadcast is stopped or because the provider did not know about the user.
  BROADCAST_NOT_FOUND
  # An unknown error message occurred, see message for more information.
  UNKNOWN
}

# Input for remotely stoping a Cloud broadcast for the given channelID.
input StopCloudBroadcastInput {
  # The the broadcast id to use when stopping a broadcast.
  id: ID!
}

# Response to stop a Cloud broadcast.
type StopCloudBroadcastPayload {
  # If the broadcast was successfully stopped, properties of that broadcast.
  broadcast: CloudBroadcast
  # Optional error associated with a failed attempt to stop a cloud broadcast.
  error: StopCloudBroadcastError
}

# Input for stopping a PV Watch Party.
input StopWatchPartyInput {
  # Amazon LWA access token.
  accessToken: String!
  # Channel ID of the creator.
  channelID: ID!
}

# Returns LWA authentication errors.
type StopWatchPartyPayload {
  # Error if the user's token expired.
  error: WatchPartyError
  # The watch party that was stopped.
  watchParty: WatchParty
}

# A live stream.
type Stream {
  # The associated archive of the stream.
  archiveVideo: Video
  averageFPS: Float
  bitrate: Float
  # The language the stream is being broadcasted in.
  broadcastLanguage: Language
  # The user who is broadcasting the live stream.
  broadcaster: User
  # Software being used for the broadcast.
  broadcasterSoftware: String
  # channel is deprecated.
  channel: Channel
    @deprecated(
      reason: "Channel fields have been merged into User. Use stream.broadcaster instead."
    )
  # Number of clips created since stream start.
  clipCount: Int
  codec: String
  # The time streaming started.
  createdAt: Time
  # The stream delay in seconds.
  delayLengthSeconds: Int
    @deprecated(reason: "Not a supported feature anymore.")
  # Information about what directories the stream is categorized in.
  directories: [Directory]!
    @deprecated(
      reason: "This was made for Communities, but the feature is officially dead. Use 'game' instead"
    )
  # Information about the game being streamed.
  game: Game
  # The height of the stream's video, in pixels.
  height: Int
  # The stream's unique identifier.
  id: ID!
  # Whether the stream is hidden from its directory.
  isDirectoryHidden: Boolean
  # Information about whether the channel is encrypted.
  isEncrypted: Boolean
  # Whether the broadcaster has indicated the stream is intended for mature audiences only.
  isMature: Boolean
    @deprecated(reason: "Use broadcaster.broadcastSettings.isMature instead")
  # Whether the broadcaster is partnered with Twitch.
  isPartner: Boolean
  # Whether or not viewers of this stream can receive drops.
  # Note: Actually earning drops additionally requires that the game have an
  # active drops campaign and is done at the discretion of the developer.
  isStreamDropsEnabled: Boolean
  # The lanugage setting of the streaming user.
  language: Language
  # When the stream was last updated.
  lastUpdatedAt: Time
  # The maximum height of the stream's video, in pixels.
  maxHeight: Int @deprecated(reason: "Not a supported feature anymore")
  # Platform-specific (e.g. Xbox, PlayStation) metadata.
  platform: Platform
  # The playback access token that determines whether the user can watch the stream.
  # Fetched for both authed and unauthed users.
  playbackAccessToken(params: PlaybackAccessTokenParams!): PlaybackAccessToken
  # A URL to a dynamically sized image.
  # If either `height` or `width` are not given, a templated value will be present instead.
  previewImageURL(height: Int, width: Int): String
  # The restriction that is currently active on the channel for restricting a user's access to it.
  restriction: ResourceRestriction
    @deprecated(
      reason: "Use Channel.restriction for full restriction data or Stream.restrictionType for stream's restriction type"
    )
  # The list of restriction options that were applied in addition to the restriction type for this stream.
  restrictionOptions: [ResourceRestrictionOption!]!
  # The type of restriction this stream currently has.
  restrictionType: String
  # self contains information on the relationship between the current user (anonymous or authenticated) and this stream.
  self: StreamSelfConnection
  # Tags are used as a discovery and search mechanism for tags and tagged content.
  # The tag data may not be updated immediately after streamers update their tags.
  # Please use User.tags instead if you want real time data from Graffiti.
  # For example, you should use Stream.tags for the channel page and the browse page, but use User.tags for the dashboard.
  tags: [Tag!]
  # A user-defined title describing the stream.
  title: String
    @deprecated(
      reason: "Title field in Users has been deprecated. Use broadcaster.broadcastSettings.title instead"
    )
  # What type of stream this is (e.g. live, playlist, watch_party).
  type: String
  # The number of viewers currently watching the stream.
  viewersCount: Int
  # The width of the stream's video, in pixels.
  width: Int
}

# StreamBitrate represents the bitrate of stream session by time.
type StreamBitrate {
  # Time of recorded bitrate.
  recordedAt: Time!
  # Bitrate of video stream in Kbps.
  valueKbps: Float!
}

# Paginated list of Streams.
type StreamConnection {
  edges: [StreamEdge]
  # Used for tracking.
  generationID: ID
  pageInfo: PageInfo
  # Used for tracking.
  responseID: ID
}

# Contains information about a Streams's relationship to a given page (connection),
# and the Stream itself.
type StreamEdge {
  cursor: Cursor
  node: Stream
  # Unique id per stream response item, used by clients to attribute displays/clicks to items.
  trackingID: ID
}

# The type of streamer shelf to display.
enum StreamerShelfType {
  # Shows the streamer's autohost list.
  AUTOHOST
  # Shows the streamer's team members.
  TEAM
  # Disables the shelf.
  DISABLED
}

# StreamFramerate represents the framerate of strem session by time.
type StreamFramerate {
  # Time of recorded bitrate.
  recordedAt: Time!
  # Framerate of video stream in Frame Per Second.
  valueFPS: Float!
}

type Streaming implements Activity {
  # The stream being broadcasted.
  stream: Stream
  # This activity's type, i.e. "STREAMING".
  type: ActivityType
}

# StreamKey represents a RTMP stream key with its expiration date.
type StreamKey {
  # Stream key expiration date.
  expiresAt: Time
  # RTMP stream key value.
  value: String!
}

# StreamKeyError represents the error code and its translated error message
# response that explains why the broadcaster can't start a stream.
type StreamKeyError {
  # code is the error code for why the broadcaster is not allow to broadcast.
  code: String!
  # Link is the url link that is associated from the translated message.
  links: [String!]!
  # message is the translated message for why the broadcaster is not allow to broadcast.
  message: String!
}

# StreamKeyResult represents StreamKey or StreamKeyError.
union StreamKeyResult = StreamKey | StreamKeyError
# Mosaic layouts for Dashboard Stream Manager.
type StreamManagerMosaicLayout implements ChannelDashboardLayout {
  # The actual Mosaic layout data to be stored or fetched.
  data: MosaicData!
  # A unique identifier to uniquely reference this layout.
  id: ID!
  # The display name for the layout shown to the user.
  name: String!
  # A version to identify how the MosaicData was generated,
  # such as for deprecation purposes.
  version: String!
  # When the layout was last updated
  lastUpdated: Time
}

# Query to let consumers filter streams that have specific metadata.
# e.g. return only those hearthstone streams that have broadcasterheroclass as mage.
# FE uses these parameters to implemtent filters.
input StreamMetadataFilterInput {
  # Filter streams by CSGO Map.
  counterStrikeMap: String
  # Filter streams by CSGO skill.
  counterStrikeSkill: String
  # Filter streams by Hearthstone hero class e.g "Mage".
  hearthstoneBroadcasterHeroClass: String
  # Filter streams by Hearthstone hero name e.g "Jaina".
  hearthstoneBroadcasterHeroName: String
  # Filter streams by Hearthstone game mode e.g "arena" or "rank" etc.
  hearthstoneGameMode: String
  # Filter streams by League Of Legends champion id.
  leagueOfLegendsChampionID: String
  # The maximum AVC level of the stream. e.g "4.1".
  maxAVCLevel: String
  # The maximum AVC profile of the stream.
  maxAVCProfile: AVCProfile
  # The maximum height of the stream.
  maxHeight: Int
  # Filter streams by Overwatch broadcaster's character e.g "Widowmaker".
  overwatchBroadcasterCharacter: String
  # Filter streams by PUBG game mode.
  pubgGameMode: String
  # Filter streams by PUBG max number of players alive in game.
  pubgPlayerAliveMax: String
  # Filter streams by PUBG min number of players alive in game.
  pubgPlayerAliveMin: String
}

# Optional inputs to filter streams
# add additional optional fields for filtering streams to the StreamOptions input type.
input StreamOptions {
  # Filter streams based on restriction types.
  includeRestricted: [StreamRestrictionType!]
  # Broadcaster languages to filter the streams by.
  # Deprecated: use language tags instead.
  languages: [Language!]
  # The locale of the user.
  locale: String
  # The platform to filter streams by.
  platformType: PlatformType = all
  # If sorted by relevance, this provides additional context used to influence recommendations.
  recommendationsContext: RecommendationsContext
  # A GUID that is created by the caller for tracking. This should be globally
  # unique per request and is required if sort=RELEVANCE.
  requestID: ID
  # The sort param can be used to change the default sorting.
  sort: StreamSort = VIEWER_COUNT
  # List of tags to filter by.
  tags: [String!]
}

# The content to render in a live recommendation item.
type StreamRecommendationEdge {
  # As pagination is currently not supported by the backend, this will always be the zero value.
  cursor: Cursor!
  # The underlying stream content to render.
  node: Stream
  # Unique id per stream used in client tracking.
  trackingID: ID!
}

# StreamRecommendationsFilters defines parameters which filter down stream recommendation results.
input StreamRecommendationsFilters {
  # Stream recommendation results will only include streams with these category ids.
  # Clients can use this filtering option for flows where a user can select categories to filter on.
  # The category IDs should be available from queries in the previous step of the user flow.
  # Example: categoryIDs: ["513143", "33214"] where "513143" and "33214" are
  # coming from categories selected by the user in the previous page.
  categoryIDs: [ID!]
}

enum StreamRecommendationType {
  # A SocialStream.
  SOCIAL
}

# Type of restricted stream. Currently used as inputs for user.followedLiveUsers, StreamOptions, and GameStreamOptions.
enum StreamRestrictionType {
  # Represents streams that are restricted by OWL all-access pass.
  OWL_ALL_ACCESS_PASS
  # Represents streams that are restricted to sub-only.
  SUB_ONLY_LIVE
}

# The relationship between the authenticated user and a stream.
type StreamSelfConnection {
  # Whether or not the requesting user is authorized to view the channel's stream.
  canWatch: Boolean!
  # Whether the stream is restricted.
  isRestricted: Boolean!
  # If the stream is restricted, the type indicates how the stream is restricted.
  restrictionType: String
}

# The start and end time of a stream session for a user.
type StreamSession {
  # The associated archive of the stream.
  archiveVideo: Video
  # The end time for the stream session.
  endedAt: Time!
  # The start time for the stream session.
  startedAt: Time!
}

# Possible ways of sorting collections of live streams.
enum StreamSort {
  # Sort streams by number of concurrent viewers, descending (most viewers first).
  # This is the default if StreamSort is not set or is a deprecated field.
  VIEWER_COUNT
  # Sort streams by number of concurrent viewers, ascending (least viewers first).
  VIEWER_COUNT_ASC
  # Sort by stream creation time, most recently started streams first.
  RECENT
  # Sort by relevance to the current user.
  RELEVANCE
  # Sort streams for the game "Counter-Strike: Global Offensive" by skill, descending (highest skill first).
  # Other streams are included last, sorted at random.
  # Deprecated: this sort option no longer exists.
  CSGO_SKILL
  # Sort streams for the game "League of Legends" by summoner rank, descending (highest rank first).
  # Other streams are included last, sorted at random.
  # Deprecated: this sort option no longer exists.
  LOL_SUMMONER_RANK
}

# Analytics information for a streaming session.
type StreamSummary {
  # The associated archives of the stream.
  archiveVideos: [Video!]
  # Average viewers for the time period.
  averageViewers: Float!
  # The ID for the streaming channel.
  channelID: ID!
  # Unique chatters for the time period.
  chatters: Int!
  # The number of clips created during the stream summary.
  clipsCreated: Int!
  # The time that the stream session ended.
  endedAt: Time!
  # Number of follows for the time period.
  follows: Int!
  # Notification information for a given stream session.
  goLiveNotification: GoLiveNotification
  # Live views for the time period.
  liveViews: Int!
  # Max viewers for the time period.
  maxViewers: Int!
  # New subscriptions for the time period.
  newSubscriptions: Int!
  # The time that the stream session started.
  startedAt: Time!
  # Unique chatters for the time period.
  uniqueChatters: Int! @deprecated(reason: "Use chatters instead")
  # Unique viewers for the time period.
  uniqueViewers: Int!
}

# A stucco (wide emote) represents an image that can be used for user interaction in specific cases.
type Stucco {
  # The description is used to describe the stucco (e.g. for screenreaders).
  description: String!
  # The unique ID of this stucco.
  id: ID!
  # The set of URLS to images related to this stucco, contains URLS for 1x, 2x and 4x images.
  imageSet: StuccoImageSet!
  # Indicates if this stucco does not belong to a single channel (available to all channels).
  isGlobal: Boolean!
  # The owner of this stucco, usually the channel this has been uploaded to.
  ownerID: ID!
  # The state of the stucco.
  state: StuccoState!
  # The textCode used to represent and identify this stucco, consists of channel prefix + stucco prefix + code.
  textCode: String!
}

# Image set of different sizes of the stucco.
type StuccoImageSet {
  # Image url of the 92x28px stucco ("1x") image asset.
  image1xURL: String!
  # Image url of the 182x56px stucco ("2x") image asset.
  image2xURL: String!
  # Image url of the 368x112px stucco ("4x") image asset.
  image4xURL: String!
}

# A Stucco pack is a collection of stuccos, the pack can be activated to be used by viewers of that channel.
type StuccoPack {
  # The ID of the stucco pack.
  id: ID!
  # User id of the owner of this pack (usually a channel).
  ownerID: ID!
  # The stuccos contained in this pack, represented as slots, containing the slot index and the stucco.
  slots: [StuccoPackSlot!]
}

# A stucco pack slot represents a single ordered slot in a pack of stuccos.
type StuccoPackSlot {
  # The index of this slot (used for ordering).
  index: Int!
  # The stucco in this slot.
  stucco: Stucco!
}

# The state a stucco can be in.
enum StuccoState {
  # - Active: part of a stucco pack.
  ACTIVE
  # - Inactive: available in the library.
  INACTIVE
  # - Moderated: stucco was moderated and is no longer available to the broadcaster or viewers.
  MODERATED
  # - Pending: stucco is currently going through moderation.
  PENDING
  # - Archived: Archived stucco, no longer visible.
  ARCHIVED
}

# Sub Count Series shows a user's sub counts broken down by type, tier, and date.
type SubCountSeries {
  # The duration each datapoint spans (ex: Day).
  period: TimeSeriesPeriod!
  # The datapoints in the timeseries, ordered ascending order by timestamp.
  subCountSeriesDataPoints: [SubCountSeriesDataPoint!]!
  # The total number of subscriptions for the given time period (ex: 957).
  totalCount: Int!
}

# A single data point in the time series.
type SubCountSeriesDataPoint {
  # The breakdown of which tiers contributed how much to the total gift sub count.
  giftSubTierBreakdown: [SubCountTierDataPoint!]!
  # The breakdown of which tiers contributed how much to the total multi month sub count.
  multiMonthSubTierBreakdown: [SubCountTierDataPoint!]!
  # The breakdown of which tiers contributed how much to the total paid sub count.
  paidSubTierBreakdown: [SubCountTierDataPoint!]!
  # The timestamp associated with this data point.
  timeStamp: Time!
  # The total number of gifted subscriptions captured during this period.
  totalGiftSubCount: Int!
  # The total number of multi month subscriptions captured during this period.
  totalMultiMonthSubCount: Int!
  # The number of paid subscriptions captured during this period.
  totalPaidSubCount: Int!
  # The number of Prime subscriptions captured during this period.
  totalPrimeSubCount: Int!
}

# SubCountTierDataPoint shows the breakdown of subcount by tier.
type SubCountTierDataPoint {
  # How many of this type of subscription were captured in this time period.
  count: Int!
  # The type of subscription, i.e. Tier 1, Tier 2, Tier 3.
  tier: String!
}

# Submit copyright claim error detailing the error message.
type SubmitCopyrightClaimError {
  # Error message detailing what fields were incorrect.
  message: String!
}

# CopyrightClaimRequest Input of the copyright claim request being submitted.
input SubmitCopyrightClaimInput {
  # This is the original work that is alledgedly being used without permission.
  copyrightedWork: CopyrightedWork!
  # All pieces of content that are alledgedly infringing upon the copyrighted work. Max 50 pieces of content.
  reportedContents: [ReportedContent!]!
  # Contact information for the claimant initiating the copyright claim request.
  contactInformation: CopyrightClaimContact!
  # Signature of the claimant, verifying that they read and agreed to the terms.
  signature: String!
  # This is the token used for captcha to protect Twitch against bots.
  captchaToken: String
}

# Output from the submit copyright claim mutation.
type SubmitCopyrightClaimPayload {
  # ID of the claim that was created, if request was successful.
  claimID: ID
  # An error describing why the claim was not created.
  error: SubmitCopyrightClaimError
}

# Wrapper for errors associated with submitCSATFeedback mutation.
type SubmitCSATFeedbackError {
  # The code associated with the error from submitCSATFeedback mutation.
  code: SubmitCSATFeedbackErrorCode!
}

# Possible error codes returned by the submitCSATFeedback mutation.
enum SubmitCSATFeedbackErrorCode {
  # Unkown backend error.
  UNKNOWN
  # Invalid argument error, such as exceeding max characters in feedback or providing an invalid GUID.
  INVALID_ARGUMENT
}

# SubmitCSATFeedbackInput creates or updates a currently authenticated user's rating/feedback of Twitch Developer Products.
input SubmitCSATFeedbackInput {
  # The action that prompted the CSAT callout to appear.
  actionPrompted: CSATActionPrompted
  # The company ID, if the user is submitting the feedback through an organization's console.
  companyID: ID
  # The additional feedback that the user submits after the rating.
  feedback: String
  # The GUID used when updating a CSAT Feedback entry with additional feedback or changes.
  guid: ID
  # The rating that the user submits.
  rating: CSATRating
  # The page in Twilight that the user responds to the CSAT callout from.
  source: String!
}

# The result of a submitCSATFeedback mutation.
type SubmitCSATFeedbackPayload {
  # The error from a failed submitCSATFeedback mutation.
  error: SubmitCSATFeedbackError
  # The response of the mutation.
  response: SubmitCSATFeedbackResponse
}

# The response of a successful submitCSATFeedback mutation.
type SubmitCSATFeedbackResponse {
  # Unique identifier returned in the response.
  guid: ID!
}

# SubmitEmotePrefix creates a new emoticon prefix for a channel.
input SubmitEmotePrefixInput {
  # The channel ID whose emote prefix will be updated.
  channelID: ID!
  # The new emote prefix.
  name: String!
}

# SubmitEmotePrefixPayload returns a status code indicating whether the update was successful or not.
type SubmitEmotePrefixPayload {
  # A code indicating why the prefix submit failed, if it did.
  errorCode: SubmitEmotePrefixResponseCode
  # The newly submitted prefix.
  prefix: EmoticonPrefix
}

# A code indicating why the prefix submit failed, if it did.
enum SubmitEmotePrefixResponseCode {
  # Only eligible users can update their emoticon prefix.
  ERR_INVALID_USER
  # The prefix submitted was not the correct length.
  ERR_INVALID_PREFIX_LENGTH
  # The prefix submitted does not meet the regular expression requirements.
  ERR_INVALID_PREFIX_REGEX
  # The prefix is not in a state that it can be updated.
  ERR_INVALID_PREFIX_STATE
  # Emote prefixes must be unique across the website.
  ERR_PREFIX_NOT_UNIQUE
  # The prefix was updated recently and can't be updated again for a while.
  ERR_PREFIX_UPDATE_TOO_SOON
  # The user is not in good standing and therefore cannot update their emoticon prefix.
  ERR_NOT_IN_GOOD_STANDING
  # Something unexpected happened when submitting the emote prefix.
  ERR_UNKNOWN
  # The prefix for the affiliate can not be updated. Affiliates can update prefix once every name change.
  ERR_AFFILIATE_PREFIX_UPDATE_TOO_SOON
  # The prefix submitted for the affiliate does not match the auto generated prefix.
  ERR_SUBMITTED_PREFIX_DOES_NOT_MATCH_AUTO_GENERATED_PREFIX
}

# SubmitEmoticonPrefix creates a new emoticon prefix for a channel.
input SubmitEmoticonPrefixInput {
  # The channel ID.
  channelID: ID!
  # Emoticon prefix.
  name: String!
}

# SubmitEmoticonPrefixPayload returns the updated emoticon prefix.
type SubmitEmoticonPrefixPayload {
  # The response doesn't return the real state of the prefix. Querying the emoticon
  # prefix is required to get the most accurate state.
  response: EmoticonPrefix!
}

# Possible errors returned by the SubmitExtensionFeedback mutation.
enum SubmitExtensionFeedbackError {
  # Internal service error eg. database timeout.
  INTERNAL_ERROR
}

# SubmitExtensionFeedbackInput submits a user's feedback for a related rating on a Twitch extension.
input SubmitExtensionFeedbackInput {
  # Feedback that the broadcaster can write.
  comment: String!
  # The ID of the extension the feedback applies to.
  extensionClientID: ID!
  # The version of the extension the feedback applies to.
  extensionVersion: String!
  # ID of the user submitting the feedback for the extension.
  userID: ID!
}

# The result of a submitExtensionFeedback mutation.
type SubmitExtensionFeedbackPayload {
  # The ExtensionRating record that the feedback was attached to.
  comment: ExtensionComment
  # The error when the mutation fails to submit the extension feedback.
  error: SubmitExtensionFeedbackError
}

# A list of channels subscribed to by a user.
type SubscribedChannelConnection {
  # The subscribed channels.
  edges: [SubscribedChannelEdge!]
  # Pagination.
  pageInfo: PageInfo!
  # The total number of subscribed channels.
  totalCount: Int
}

# A broadcaster user with cursor.
type SubscribedChannelEdge {
  # Cursor represents the position of the current edge/node.
  cursor: Cursor!
  # Node represents the user for the current edge.
  node: User
}

# SubscriberBadgeProgress contains progress information for subscription badges based on a user's tenure.
type SubscriberBadgeProgress {
  # The ID is a composite of channel_id (owner of badge) / user_id (viewer requesting badge) / version
  id: ID!
  # URL of 18x18 asset.
  image1xURL: String!
  # URL of 36x36 asset.
  image2xURL: String!
  # URL of 72x72 asset.
  image4xURL: String!
  # The percentage of tenure already earned towards this badge.
  percentCompleted: Float!
  # The total tenure in months required to earn this badge.
  requiredTenureMonths: Int!
  # Metadata about how a subscriber badge is stored & fetched.
  version: String!
}

# Breakdown of number of subscriptions by tier.
type SubscriberCountBreakdown {
  # The number of subscriptions to the product.
  count: Int!
  # The tier of the product.
  tier: String!
}

# Information pertaining to user's subscriber score.
# Contains subscription count, sub points, emote limits, and information about the next subscriber level.
type SubscriberScore {
  # Breakdown of subscriber score by product tier.
  breakdown: [SubscriberScoreBreakdown!]
  # Current subscriber count.
  count: Int!
  # Breakdown of total subs by product tier.
  countBreakdown: [SubscriberCountBreakdown!]
  # Current subscriber score.
  current: Int!
  # Current number of emotes unlocked.
  currentEmoteLimit: Int!
  # Next goal to unlock more emotes.
  # Will be null if max score already reached.
  next: Int
  # Emote limit after reaching nextScoreGoal.
  # Will be null if max emote limit reached.
  nextEmoteLimit: Int
}

# Breakdown of score by tier.
type SubscriberScoreBreakdown {
  # The score of the product.
  score: Int!
  # The tier of the product.
  tier: String!
}

# Data about a user's subscription to a broadcaster.
type SubscriptionBenefit {
  # The date that the subscription benefit ends.
  endsAt: Time
  # gift resolves gift info about a SubscriptionBenefit.
  gift: SubscriptionGift
  # The unique identifier.
  id: ID!
  # For a recurring subscription, the price is charged at every interval i months.
  intervalNumber: Int!
  # Whether the sub is set to "do not renew".
  isDNRd: Boolean!
  # Whether this subscription has been extended. This means that a non-recurring
  # subscription has been extended with additional months.
  isExtended: Boolean!
  # Whether the subscription is in the grace period to be cancelled and refunded.
  isRefundable: Boolean!
  # The id of where the subscription originated from. Used when DNRing a recurring subscription.
  originID: String
  # If the subscriptionBenefit has a future dated paid upgrade. (ie. a user has
  # upgraded a 1-month gift to a recurring subscription).
  paidUpgrade: PaidUpgrade
    @deprecated(
      reason: "gift to paid upgrades will now be in the pendingSubscription schema"
    )
  # If the subscriptionBenefit has a pending future dated paid subscription.
  pendingSubscription: PendingSubscription
  # The platform the subscription was purchased on.
  platform: SubscriptionPlatform!
  # Resolves the product that the subscription benefit is to.
  product: SubscriptionProduct
  # Whether this benefit was achieved using a Twitch Prime subscription.
  purchasedWithPrime: Boolean!
  # The date that the subscription benefit will renew. Will be nil if the subscription benefit
  # is not going to renew.
  renewsAt: Time
  # The states this benefit has transitioned through. Captures both user-initiated states
  # such as initiating a DNR request, as well as system-initiated states such as completing a DNR request.
  states: [SubscriptionBenefitStateHistory!]
  # Exposes the third party SKU for managing third party subscriptions from the client.
  # Will be nil if there is not a thirdPartySKU associated with this subscription benefit.
  thirdPartySKU: String
  # The subscription tier.
  tier: String!
  # The user who is subscribed to.
  user: User
}

# A paginated list of subscription benefits.
type SubscriptionBenefitConnection {
  # The list of subscription benefits on this page.
  edges: [SubscriptionBenefitEdge!]
  # Information about this page of payment transactions.
  pageInfo: PageInfo!
}

# Criteria for building paginated list of user's all active subscriptions.
input SubscriptionBenefitCriteriaInput {
  # Only return subscription benefits for a given filter value.
  filter: SubscriptionBenefitFilter = ALL
  # Platform where subscriptions were purchased.
  platform: SubscriptionPlatform = WEB
}

# An element in a paginated list of subscription benefits.
type SubscriptionBenefitEdge {
  # Opaque cursor describing this edge's position in the paginated list.
  cursor: Cursor!
  # The element node.
  node: SubscriptionBenefit
}

# Set of ways to filter subscription benefit paginated results.
enum SubscriptionBenefitFilter {
  # Only subscriptions purchased on a platform, specified in the input as platform.
  PLATFORM
  # Only Subscriptions received through gifts from another Twitch user.
  GIFT
  # All active subscriptions.
  ALL
}

# The logic state of the Subscription Benefit.
enum SubscriptionBenefitState {
  # Unknown (0-value) state.
  UNKNOWN
  # Active (recurring) state.
  ACTIVE
  # State when a user has initiated a DNR request.
  DNR_INITIATED
  # State for when Twitch has completed a DNR request.
  WILL_NOT_RENEW
  # State for when Twitch has initiated a refund request.
  CANCEL_INITIATED
  # State for when Twitch has completed a refund request.
  CANCELLED
  # State for when a Subscription has been paused (used to support Android account hold feature).
  ON_HOLD
}

# Data about the states a Subscription Benefit has transitioned through. Captures both user-initiated states
# such as initiating a DNR request, as well as system-initiated states such as completing a DNR request.
type SubscriptionBenefitStateHistory {
  # When the benefit transitioned to this state.
  createdAt: Time
  # The logical state the benefit occupied.
  state: SubscriptionBenefitState!
}

# Configs that help initiate the subscription checkout flow.
type SubscriptionCheckoutConfigs {
  # Lists any additional actions for a subscription checkout session.
  actions: [CheckoutAction!]!
  # Whether the initiated checkout flow can complete/succeed and gift the recipient the product.
  canGift: Boolean!
  # Whether the initiated checkout flow can proceed with a purchase.
  canPurchase: Boolean!
  # Whether the purchaser is eligible for a one-time promotion in the subscription purchase checkout flow.
  isOneMonthFreeEligible: Boolean!
  # Holds configuration necessary for initializing payment provider client libraries and facilitate checkout flow.
  paymentProviderConfigs: PaymentProviderConfigs!
  # Purchase Ineligibility reason details.
  purchaseIneligibilityReason: PurchaseIneligibilityReason!
}

# An Offer for purchasing community gift subscriptions with associated metadata about the Offer.
# Composes the "model" (Offer) with the "view" metadata about the offer.
type SubscriptionCommunityGifting {
  # The image assets for this offer.
  assets: SubscriptionCommunityGiftingAssets!
  # The Offer document for this Community Gift offer.
  offer: Offer
  # The default number of subscriptions that this offer is offering.
  quantity: Int!
  # The type of this community gifting offer.
  type: SubscriptionCommunityGiftingType!
}

# Groups image assets related to the community gifting Offer.
type SubscriptionCommunityGiftingAssets {
  # The link to the 1x pixel density image asset for this community gifting offer.
  imageURL1x: String!
  # The link to the 2x pixel density image asset for this community gifting offer.
  imageURL2x: String!
  # The link to the 3x pixel density image asset for this community gifting offer.
  imageURL3x: String!
  # The link to the 4x pixel density image asset for this community gifting offer.
  imageURL4x: String!
}

# Describes the type of community gifting Offer that is being resolved.
enum SubscriptionCommunityGiftingType {
  # An unknown gifting type.
  UNKNOWN
  # A preset bundle of fixed-quantity community gift subscriptions.
  BUNDLE
  # An offer that allows the user to choose how many gift subscriptions they would like to purchase.
  CUSTOM
}

# Gift information for a subscription benefit.
type SubscriptionGift {
  # giftDate is the date that the gift was given.
  giftDate: Time
  # Gifter is the user who sent the gift. Will be nil if isGift is false or is the gift is anonymous.
  gifter: User
  # isGift says whether the subscription benefit is a gift or not.
  isGift: Boolean!
}

# A parent field for grouping the different types of subscription gift offers.
type SubscriptionGifting {
  # Offers and associated metadata for purchasing community gift subscriptions.
  community: [SubscriptionCommunityGifting!]
  # Offers for purchasing a gift subscription to the given user.
  # This will prefer the ID if both login and ID are provided.
  # If neither are provided, this will return null.
  standard(
    recipientID: ID
    recipientLogin: String
  ): [SubscriptionStandardGifting!]
}

# A gift offer that is available on a particular subscription based
# on gift type and platform.
type SubscriptionGiftOffer {
  # Unique identifier of a subscription gift offer.
  id: ID!
  # The subscription gift offer price info which contains information about currency, cost and tax information.
  priceInfo(taxCountry: String): PriceInfo!
  # The available promotions on this gift offer.
  promotion: SubscriptionGiftPromotion
  # The amount of gifts in this offer.
  quantity: Int!
  # thirdPartySKU represents the purchasable third party SKU of the gift the user will purchase.
  # Will return an nil if the user has no purchasable skus.
  # Will return nil if not on a platform with an external subscription gift offer or if the country is not supported.
  thirdPartySKU: String
  # The type of gift this offer is for.
  type: SubscriptionGiftType!
}

# The different types of platforms available for gift offers.
enum SubscriptionGiftOfferPlatform {
  # Gift offers available for the web clients.
  WEB
  # Gift offers available for the Android clients.
  ANDROID
}

# The promotion offer on a subscription gift offer.
type SubscriptionGiftPromotion {
  # The subscription gift's discount type for this promotion(e.g. "PERCENT_OFF").
  discountType: SubscriptionPromotionDiscountType!
  # The discount value of the subscription gift product (e.g. "50").
  discountValue: String!
  # Unique identifier of a subscription gift promotion.
  id: ID!
  # The subscription gift offer price info which contains information about currency, cost and tax information.
  priceInfo(taxCountry: String): PriceInfo!
  # The quantity of gifts this promotion is for(ex: 11 gifts for a promotion on 10 gifts).
  quantity: Int!
  # Promotion consumable SKU used by third party that the user will purchase.
  thirdPartySKU: String
}

# The different types of subscription gifting.
enum SubscriptionGiftType {
  # Unknown or no gift type.
  NONE
  # Standard gifts are gifts to a specific user given by a user.
  STANDARD
  # Community gifts are one or more gifts given to one or more users by a user.
  COMMUNITY
}

# Represents the interval of a subscription product.
type SubscriptionInterval {
  # The unit-less amount of time a subscription lasts for.
  duration: Int!
  # Denotes the unit of the interval.
  unit: SubscriptionIntervalUnit!
}

# Denotes the unit of the period of a subscription product.
enum SubscriptionIntervalUnit {
  # This subscription product length is unknown.
  UNKNOWN
  # This subscription product lasts X weeks.
  WEEK
  # This subscription product lasts X months.
  MONTH
  # This subscription product lasts X years.
  YEAR
  # This subscription product lasts forever.
  ONE_TIME
}

# Subscription pricing information.
type SubscriptionOffer {
  # Currency the offer is for.
  currency: String!
  # Exponent to use when shifting the currency.
  exponent: Int!
  # Id for offer on subscription product.
  id: ID!
  # Price for the offer.
  price: Int!
  # Promotion description.
  promoDescription: String
}

# SubscriptionPlatform enumerates platform options such as WEB, IOS, ANDROID.
enum SubscriptionPlatform {
  # Unknown or no platform.
  NONE
  # Access from the browser.                                           ).
  WEB
  # Access from the Twitch iOS application.
  IOS
  # Access from the Twitch Android application.
  ANDROID
  # Access from all Twitch Mobile applications (ANDROID + IOS).
  MOBILE_ALL
}

# A subscription that is purchasable by users.
# Once purchased, the subscription entitles the user to use special emote sets on Twitch.
type SubscriptionProduct {
  # The subscription product's display name.
  displayName: String
  # The maximum number of Emotes that can be associated with this product.
  emoteLimit: Int
  # The maximum number of animated Emotes that can be associated with this product.
  animatedEmoteLimit: Int
  # The emote modifiers associated with the product.
  emoteModifiers: [EmoteModifier!]
  # The identifier of the static EmoteSet that a user gains access to use on Twitch,
  # when they purchase this product.
  emoteSetID: ID
    @deprecated(
      reason: "Products can have more than one emote set now so use emoteGroups instead."
    )
  # The emote groups that the user gains access to use on Twitch when they purchase this product.
  # When using the ALL filter the data is uncached and should only be used on the creator dashboard.
  emoteGroups(state: EmoteStateFilter = ACTIVE): [EmoteSet!]
  # A list of Emotes the user gains access to use on Twitch when they purchase
  # this product.
  emotes(state: EmoteStateFilter = ACTIVE): [Emote]
  # A list of GiftOffers that are available on this subscription product
  # depending on which platform and gift type is given
  # Used by clients to display different gift prices, quantities and gift promotion information.
  giftOffers(
    platform: SubscriptionGiftOfferPlatform
    type: SubscriptionGiftType!
  ): [SubscriptionGiftOffer!]
  # The subscription product's promotion if it is active.
  giftPromotion: SubscriptionPromotion
  # The different types of gift subscriptions ("Community" vs "Standard").
  # Optional countryCode will need to be in ISO 3166 Alpha-2 format(e.g. "US", "BR", "HK").
  gifting(countryCode: String): SubscriptionGifting!
  # Whether the subscription hides ads for the channel.
  hasAdFree: Boolean!
  # Whether the subscribers of this product are affected by slow chat mode.
  hasFastChat: Boolean
  # Whether the channel has sub only chatroom restriction.
  hasSubOnlyChat: Boolean
  # Whether the subscribers of this product are able to see the subs-only video archive.
  hasSubonlyVideoArchive: Boolean
  # The subscription product's identifier.
  id: ID!
  # The interval that the product lasts for. Includes unit + duration.
  interval: SubscriptionInterval!
  # The subscription product's name.
  name: String!
  # Available offers for a subscription product.
  # Optional countryCode will need to be in ISO 3166 Alpha-2 format(e.g. "US", "BR", "HK").
  offers(countryCode: String): [Offer!]
  # The Twitch user that is the owner of the channel associated with this subscription product.
  # This is null for SubscriptionProducts like 'turbo' that are not associated with any user.
  owner: User
  # The subscription's USD-formatted price, e.g. "$9.99".
  price: String!
    @deprecated(
      reason: "Transitioning to priceInfo instead to support multi region pricing"
    )
  # PriceInfo holds the products pricing information such as currency, cost, and tax information.
  priceInfo(taxCountry: String): PriceInfo!
  # The subscription product's promotion if it is active.
  promotion: SubscriptionPromotion
  # The currently active revenue configuration record for the subscription product.
  revenueConfig: RevenueConfig
  # The connection for user to the subscription product.
  self: SubscriptionProductSelfConnection
  # The avaliability state of the product. e.g. "active" or "inactive".
  state: SubscriptionState!
  # ThirdPartytemplateSKU is used by the frontend to retrieve third party product information such
  # as price. templateSKU is exposed separately from purchaseSKU since retrieving purchaseSKU is a
  # more expensive operation. A user may not be able to purchase the templateSKU. Use purchaseSKU
  # when the user has indiciated they want to purchase.
  # Uses Client-ID to determine platform information and IP address to determine location.
  thirdPartyTemplateSKU(platform: String): String
  # The tier of the product.
  tier: String!
  # The type of subscription, e.g. "chansub" or "teamsub".
  type: SubscriptionProductType!
  # The URL for this subscription's purchase page.
  url: String!
}

# A set of subscription products.
type SubscriptionProductsConnection {
  # The resolved subscription products.
  nodes: [SubscriptionProduct!]!
}

# The connection between the user and subscription product.
type SubscriptionProductSelfConnection {
  # This user's subscription benefit information for the subscription product.
  benefit: SubscriptionBenefit
  # True if the user in this connection is allowed to gift the product in this connection.
  canGiftInChannel: Boolean!
  # True if the user in this connection can gift the product in this connection to the user with the supplied user ID.
  canGiftTo(recipientID: ID!): Boolean!
  # True if the user in this connection can gift the product in this connection to the user with the supplied login.
  # Since this requires an additonal lookup to get the user ID from the login, this is less preferable than canGift.
  canGiftToLogin(recipientLogin: String!): Boolean!
  # Holds configuration necessary to start subscription purchase checkout flow for this product for current user.
  checkoutConfiguration(
    config: CheckoutConfigurationInput!
  ): SubscriptionCheckoutConfigs
  # The subscription's discount type (e.g. "percent_off").
  discountType: DiscountType!
    @deprecated(reason: "Transitioning to promotion field instead")
  # The discount value of the subscription product (e.g. "50").
  discountValue: String!
    @deprecated(reason: "Transitioning to promotion field instead")
  # A list of GiftOffers that are available on this subscription product
  # depending on which platform, giftType and user that is authenticated.
  # Exposed on the self connection as well since user based promotions can be given in the future
  # Used by clients to display different gift prices, quantities and user based gift promotion information.
  giftOffers(
    platform: SubscriptionGiftOfferPlatform
    type: SubscriptionGiftType!
  ): [SubscriptionGiftOffer!]
  # If the product is eligible for a discount.
  isEligibleForDiscount: Boolean!
    @deprecated(reason: "Transitioning to promotion field instead")
  # The subscription's USD-formatted price after discount (e.g. "$2.49").
  newPrice: String!
    @deprecated(reason: "Transitioning to promotion field instead")
  # The subscription's USD-formatted price before discount (e.g. "$4.99").
  oldPrice: String!
    @deprecated(reason: "Transitioning to promotion field instead")
  # If the subscription product is eligible for a paid upgrade promotion.
  paidUpgradePromotion: SubscriptionPromotion
  # Contains information on the final checkout price of this subscription product.
  productPurchase(
    quantity: Int!
    paymentProvider: PaymentProvider!
  ): ProductPurchase
  # The subscription product's promotion for user if eligible.
  promotion: SubscriptionPromotion
  # This user's subscription purchase details for the subscription product. If this user is not
  # subscribed to the product, then the result's state is 'inactive'. If a compatible purchase exists,
  # then the result's "compatiblePurchase" field is present.
  purchase: SubscriptionPurchase
  # Subscription tenure data for the user to this subscription product.
  subscriptionTenure(
    tenureMethod: SubscriptionTenureMethod!
  ): SubscriptionTenure
  # ThirdPartyPurchaseSKU is different from templateSKU since it represents the SKU of the exact item the
  # user will purchase. It is more expensive to retrieve purchaseSKU than templateSKU, so only
  # use purchaseSKU when the user has indicated they want to checkout. Use templateSKU on channel
  # page load to retrieve product information.
  #
  # Will return an error if the user has no purchasable skus. Will return nil if not on a platform
  # with an external subscription product or if the country is not supported.
  # Uses Client-ID to determine platform information and IP address to determine location.
  thirdPartyPurchaseSKU(platform: String): String
}

# A subscription products error.
type SubscriptionProductsError {
  # A code representing the error state.
  code: SubscriptionProductsErrorCode!
}

# Codes representing subscription products error states clients can respond to.
enum SubscriptionProductsErrorCode {
  # Default code.
  UNKNOWN
  # Code indicating server error occurred while retrieving subscription products.
  ERROR
  # Code indicating subscription products could not be found.
  MISSING
}

# The set of results that can occur when resolving a subscription product.
union SubscriptionProductsResult =
    SubscriptionProductsConnection
  | SubscriptionProductsError
# The types of subscription products that can be purchased.
enum SubscriptionProductType {
  # Channel sub.
  CHANSUB
  # Team sub.
  TEAMSUB
  # Turbo sub.
  TURBO
}

# The promotion offer on subscription product.
type SubscriptionPromotion {
  # Contains information on the final checkout price for this promotion.
  checkoutPrice(
    quantity: Int!
    paymentProvider: PaymentProvider!
  ): ProductPurchase
  # The subscription's discount type (e.g. "PERCENT_OFF").
  discountType: SubscriptionPromotionDiscountType!
    @deprecated(reason: "No longer supported.")
  # The discount value of the subscription product (e.g. "50").
  discountValue: String! @deprecated(reason: "No longer supported.")
  # The subscription's USD-formatted price after discount (e.g. "$2.49").
  newPrice: String!
    @deprecated(reason: "Use SubscriptionPromotion.previewPrice instead.")
  # The subscription's USD-formatted price before discount (e.g. "$4.99").
  oldPrice: String!
    @deprecated(reason: "Use SubscriptionProduct.priceInfo instead.")
  # The price for the promotion.
  previewPrice: PriceInfo!
}

# Valid discount types for Subscription promotion.
enum SubscriptionPromotionDiscountType {
  # No discount on subscription product.
  NONE
  # Percent off discount on subscription product.
  PERCENT_OFF
  # Fixed price discount on subscription product.
  FIXED_VALUE_OFF
}

# A user's subscription purchase details, part of the Subscription Checkout workflow.
type SubscriptionPurchase {
  # A compatible purchase exists if this user bought a subscription product of a different tier for the
  # channel in question.
  #
  # i.e. this user doesn't have this subscription purchase for the $4.99 sub but they do have a
  #      compatible purchase for the $9.99 subscription.
  compatiblePurchases: [SubscriptionPurchaseDetails!]
  # The purchase details for a Twitch purchaser - Subscription product combination.
  details: SubscriptionPurchaseDetails
}

# The receipt details for a subscription purchase.
type SubscriptionPurchaseDetails {
  # Date the purchase was cancelled at, if applicable, else null.
  cancelledAt: Time
  # Currency for the price, e.g. "USD".
  currency: String!
  # Divisor for the price based on the currency. e.g. Divisor for USD is 100.
  divisor: Int!
  # Purchase's payment provider.
  paymentProvider: PaymentProvider!
  # Price in smallest subunit of currency, e.g. "499" cents.
  price: Int!
  # The tier of the subscription purchase product.
  productTier: String
  # The type of subscription purchase.
  productType: SubscriptionProductType!
  # Purchase state.
  state: SubscriptionPurchaseState!
}

# The various states of the subscription purchase receipt.
enum SubscriptionPurchaseState {
  # Active subscription purchase. It could be non-renewing or renewing.
  ACTIVE
  # Cancelled subscription purchase.
  CANCELLED
  # Inactive subscription purchase. User's subscription benefit from the original purchase has ended
  # and has not renewed.
  INACTIVE
}

# An Offer for purchasing a Standard (AKA "single" or "targetted") gift subscription for a specific user.
# This type exists as a futureproofing measure as gifting will evolve over time.
type SubscriptionStandardGifting {
  # The Offer document for this Standard Gift offer.
  offer: Offer
}

# The availability state of a subscription product.
enum SubscriptionState {
  # Active state.
  ACTIVE
  # Inactive state.
  INACTIVE
  # Unknown state.
  UNKNOWN
}

# Simple summary of subscription product.
type SubscriptionSummary {
  # Emotes included with subscription.
  emotes: [Emote]
  # Subscription product id, for now is the same as the ticket product id.
  id: ID!
  # Emote modifiers available at this tier.
  modifiers: [EmoteModifier!]
  # Channel's custom name for their subscription.
  name: String!
  # Pricing information about subscription, filtered to what is available for user.
  offers: [SubscriptionOffer!]
  # Info specific to the user.
  self: SubscriptionSummarySelf!
  # Tier of subscription, either 1, 2, or 3.
  tier: SubscriptionSummaryTier!
  # URL for checkout page.
  url: String!
}

# Most of the user specific fields for SubscriptionSummary.
type SubscriptionSummarySelf {
  # What is the cumulative tenure for this user.
  cumulativeTenure: Int!
  # The tier the user is subbed to (if they have a sub).
  subscribedTier: SubscriptionSummaryTier
}

# Tier of subscription.
enum SubscriptionSummaryTier {
  # First tier, $4.99 for US market.
  TIER_1
  # Second tier, $9.99 for US market.
  TIER_2
  # Third tier, $24.99 for US market.
  TIER_3
}

# Tenure to a subscription product.
type SubscriptionTenure {
  # The days remaining in a user's current tenure period.
  daysRemaining: Int!
  # The days elapsed in a user's current tenure period.
  elapsedDays: Int!
  # The ending date of a user's tenure.
  end: Time
  # The method used to calculate the user's tenure.
  method: SubscriptionTenureMethod!
  # The total duration of a user's tenure.
  months: Int!
  # The starting date of a user's tenure.
  start: Time
}

# A type of tenure to a subscription product.
enum SubscriptionTenureMethod {
  # Tenure data calculated cumulatively.
  CUMULATIVE
  # Tenure data calculated streak-based.
  STREAK
}

# A channel could have multiple subscription products at varying tiers.
# Each value will always map to the respective tier for every channel that has the given tier available as a product.
#
# Example:
# A channel with a "tier 2" subscription product will always have the tier represented as T_2000.
enum SubscriptionTier {
  # Custom tier.
  CUSTOM
  # Subscribed with Twitch Prime.
  PRIME
  # Tier "1000".
  T_1000
  # Tier "2000".
  T_2000
  # Tier "3000".
  T_3000
}

# Token that a User uses for redeeming Subscriptions.
type SubscriptionToken {
  # Current token balance of user.
  balance: Int
}

# A SubscriptionTokenBundleProduct can contain multiple Offers.
# ex) A Bundle of size 3 tokens, can have 3 other offers such as:
#   - Normal offer: "Pay $16.99 for the bundle
#   - Discounted, one-time buy offer: "Pay $14.99 for the bundle, but a one-time purchase only"
#   - Bits: Use X amount of Bits to purchase this Bundle.
type SubscriptionTokenBundleProduct {
  # Assets assocaited with a certain Token Bundle Product.
  assets: [TokenBundleAsset!]
  # Subscription token bundle product's identifier.
  id: ID!
  # List of available offers for this bundle product.
  # Displays the cheapest offer to the user, if there are promotions to be applied.
  offers: [Offer!]
  # Quantity of tokens the bundle.
  quantity: Int!
}

# Describes configurable values for the token product line.
type SubscriptionTokenProductConfig {
  # Max token balance a user can have.
  maxBalance: Int
}

# The individual swap participant input.
input SwapCompetitionLobbyParticipantInput {
  # The id of the lobby where the lobby participant currently is.
  lobbyID: ID!
  # The id of the lobby participant, which can be competition player id or competition team id, we are swapping with.
  participantID: ID!
}

# SwapCompetitionLobbyParticipantsInput exchanges the lobby placements of the two participants within the same phase.
input SwapCompetitionLobbyParticipantsInput {
  # The id of the competition.
  competitionID: ID!
  # The participantID and lobbyID of the first lobby participant to be swapped.
  first: SwapCompetitionLobbyParticipantInput!
  # The id of the phase.
  phaseID: ID!
  # The participantID and lobbyID of the second lobby participant to be swapped.
  second: SwapCompetitionLobbyParticipantInput!
}

# SwapCompetitionLobbyParticipantsPayload is the success response for swapping lobby participants.
type SwapCompetitionLobbyParticipantsPayload {
  # The new state of competition after swapping participants.
  competition: Competition
  # Used for competition mutation errors.
  error: CompetitionError
}

# SyncGameOnDropCampaignPayload contains the campaign ID that needs to be synced.
input SyncGameOnDropCampaignInput {
  # The ID of the campaign to sync.
  campaignID: ID!
}

# SyncGameOnDropCampaignPayload returns the result of the sync.
type SyncGameOnDropCampaignPayload {
  # The campaign after the sync.
  dropCampaign: DropCampaign
  # A mapped error returned by the drops management service.
  error: DropsError
}

# Tag(s) are used as a discovery and search mechanism for tagged content, including Streams, Clips, and VODs.
type Tag {
  # Timestamp of the creation of this tag.
  createdAt: Time
  # This tag's unique identifier.
  id: ID!
  # Whether this tag is auto generated.
  isAutomated: Boolean!
  # Whether this tag is a language tag.
  isLanguageTag: Boolean!
  # Localized description of this tag.
  localizedDescription: String!
  # Localized Name of this tag.
  localizedName: String!
  # Scope of the Tag.
  scope: TagScope!
  # Official Name of this tag in English.
  tagName: String!
}

# The frequency of a tag used as filter for a channel.
type TagAnalytic {
  # A decimal that shows how often a Tag is used.
  percentage: Float!
  # The tag for the analytic.
  tag: Tag!
}

# A paginated list of tags, and its metadata.
type TagConnection {
  # The list of tags in this page.
  edges: [TagEdge!]
  # Information about this page of tags.
  pageInfo: PageInfo!
}

# An element in a paginated tags, and its metadata.
type TagEdge {
  # Cursor represents the position of the current edge/node.
  cursor: Cursor!
  # Node represents the extension for the current edge.
  node: Tag
}

# The content that are possibly return for tagging mutation payload.
union TaggedContent = Clip | Game | Stream | User | Video
# An enumeration on the different scope of a tag.
enum TagScope {
  # Tags that can be applied to all content types.
  ALL
  # Tags that can only be applied to the CATEGORY content type.
  CATEGORY
}

# An enumeration on the different tag types of a category.
enum TagType {
  # Tags applied to the category.
  CONTENT
  # The most popular tags used by other channels streaming this game/category.
  TOP
}

# TargetedModerationAction is a ModLogs entry of a chat ban,timeout, or unban.
type TargetedModActionDetails {
  # Timestamp when user was banned/timed-out.
  bannedAt: Time
  # Duration of the chat timeout (in seconds).
  durationSeconds: Int
  # Timestamp when the chat timeout expires.
  expiresAt: Time
  # Reason of the action.
  reason: String
}

# TaxInterview describes the information for a user's Amazon tax interview during payout onboarding.
type TaxInterview {
  # Amazon tax interview account ID.
  accountID: ID! @deprecated(reason: "Use interview options instead")
  # Amazon tax interview client ID.
  clientID: ID! @deprecated(reason: "Use interview options")
  # Legal name of the user completing the Amazon tax interview.
  governmentAlias: String! @deprecated(reason: "Use interview options")
  # The preferred locale for user in the accepted format to initate the Amazon tax interview (e.g. "en_US").
  locale: String! @deprecated(reason: "Use interview options instead")
  # List of key value pairs that were used to generate the signature.
  options: [TaxInterviewOption!]
  # Unique signature to initiate the Amazon tax interview.
  signature: String!
  # The type of Amazon tax interview.
  type: TaxInterviewType! @deprecated(reason: "Use interview options instead")
  # The URL for user to begin their Amazon tax interview.
  url: String!
}

# TaxInterviewOption is a key value pair type used by the tax interview.
# Each option represents a form value that musted be passed to the argon website.
type TaxInterviewOption {
  # The name of the option.
  key: String!
  # The option value.
  value: String!
}

# TaxInterviewType enumerates valid Amazon tax interview types.
enum TaxInterviewType {
  # Describes an Amazon tax interview that would allow users to receive royalty income through licensed content.
  ROYALTY
  # Describes an Amazon tax interview that would allow users to receive income for their goods and services.
  SERVICE
}

# TaxMismatchError enumerates valid registration and tax interview field names for payout onboarding.
enum TaxMismatchError {
  # Applied when the user submits a name that does not match the name on their registration.
  # If provided, the company name will be compared intead of the user's full legal name.
  NAME
  # Applied when the user submits a country that does not match the country on their registration.
  COUNTRY
  # Applied when the user submits an email that does not match the email on their registration.
  EMAIL
  # Applied when the user submits a street address that does not match the street address on their registration.
  STREET_ADDRESS
  # Applied when the user submits a street address 2 that does not match the street address 2 on their registration.
  STREET_ADDRESS_2
  # Applied when the user submits a city that does not match the city on their registration.
  CITY
  # Applied when the user submits a state that does not match the state on their registration.
  STATE
  # Applied when the user submits a postal that does not match the postal on their registration.
  POSTAL
}

# Represents a tax jurisdiction from which a final price was calculated.
type TaxRegion {
  # Tax country, required for the TaxRegion object type.
  countryCode: String!
  # Tax state if applicable.
  state: String
  # Tax zip code if applicable.
  zipCode: String
}

# GDPR cookie vendors for vendors that support TCF strings, for a user.
type TCFCookieVendor {
  # User content status for each vendor.
  consentStatus: ConsentStatus!
  # If itâ€™s an advertising, analytics, or essential cookie.
  cookieVendorType: CookieVendorType!
  # List of features this vendor uses.
  features: [ConsentFeature!]
  # A flag that shows if the consent is given by the user or by consent service as default value.
  hasUserSetConsent: Boolean!
  # A flag that shows if the vendor should be visible to management page.
  isVisible: Boolean!
  # Vendor name.
  name: VendorName!
  # Url to the Vendor's privacy policy.
  policyURL: String!
  # List of purposes this vendor uses.
  purposes: [ConsentPurpose!]
  # List of special features this vendor uses.
  specialFeatures: [ConsentSpecialFeature!]
  # List of special purposes this vendor uses.
  specialPurposes: [ConsentSpecialPurpose!]
}

# Team represents a Twitch Team.
# Teams are collections of streaming channels, and are owned by a Twitch user.
# Teams have landing pages, e.g. https://www.twitch.tv/team/clg.
type Team {
  # ID to an image meant to be the background of the Team's landing page.
  backgroundImageID: ID
  # URL to an image meant to be the background of the Team's landing page.
  backgroundImageURL: String
  # ID to the Team's banner image.
  bannerID: ID
  # URL to the Team's banner image.
  bannerURL: String
  # Retrieves team stats within the start and end time broken down by granularity.
  # Default end time will be the current time (now).
  # Granularity defaults to 5 minutes.
  # ChannelIDs defaults to all team members.
  creatorTimeseriesMetrics(
    startAt: Time!
    endAt: Time
    timeZone: String!
    granularity: Granularity = FIVE_MINUTE
    channelIDs: [ID!] = []
  ): CreatorTimeseriesMetrics
  # Information about the team, formatted in Markdown.
  description: String
  # Display version of the team name.
  displayName: String!
  # The Team's ID.
  id: ID!
  # Channels that the Team owner have opted to highlight that are currently live.
  # These channels may or may not also be members of the Team.
  # They will be returned in the order configured by the Team admin.
  liveFeaturedChannels(first: Int = 10, after: Cursor): UserConnection
  # Users that belong to the team that are currently live.
  # They will be returned in the order configured by the Team admin.
  liveMembers(first: Int = 10, after: Cursor): UserConnection
  # ID to the Team's logo image.
  logoID: ID
  # URL to the Team's logo image.
  logoURL: String
  # The list of users that belong to this team.
  # They will be returned in the order configured by the Team admin.
  # metricsRevealed allows the client to return all `none`, `statsRevealed`, or `revenueRevealed` members.
  # Defaults to all members to avoid breaking changes.
  members(
    first: Int = 10
    after: Cursor
    metricsRevealedFilter: MemberMetricsRevealedParams
  ): UserConnection
  # The alphanumeric Twitch name of the team.
  name: String!
  # Owner is the User that owns and manages the Team.
  owner: User
  # Aggregated analytics for several video referral sources, for use in teams dashboard.
  # ChannelIDs defaults to all team members.
  videoPlayReferrals(
    start: Time!
    end: Time!
    filter: ReferralsFilter = ALL
    dimension: ReferralsDimension!
    first: Int = 10
    channelIDs: [ID!] = []
  ): VideoPlayReferrals
}

# Inputs for terminating a poll.
input TerminatePollInChannelInput {
  # The id of the channel with the poll to terminate.
  channelID: ID!
}

# Outputs from the terminate poll mutation.
type TerminatePollInChannelPayload {
  # The terminated poll.
  poll: Poll
}

# Inputs for terminating a poll.
input TerminatePollInput {
  # The id of the poll to terminate.
  pollID: ID!
}

# Outputs from the create poll mutation.
type TerminatePollPayload {
  # The created poll.
  poll: Poll
}

# A shelf title token type that contains text with various formatters.
type TextToken {
  # If this title token should be emphasized or not.
  hasEmphasis: Boolean!
  # The location that this shelf title token should link to.
  location: LinkType!
  # The text to display for this token.
  text: String!
}

type ThumbnailOEmbed {
  height: Int!
  url: String!
  width: Int!
}

# Possible labels for extra points awarded to resolve ties.
enum TiebreakerLabel {
  # Tiebreaker Points are awarded for a kill, useful in BR games.
  KILLS
  # Tiebreaker Points are a generic bonus field determined by the CO.
  BONUS
  # An unknown label was provided.
  UNKNOWN
}

# RFC3339 timestamp.
# For example "2015-07-22T21:41:14Z".
scalar Time

# A drop triggered by accummulating minutes watched.
type TimeBasedDrop implements DropType {
  # The rewards for this drop and how often those rewards can be awarded.
  benefitEdges: [DropBenefitEdge!]
  # The campaign this drop belongs to.
  campaign: DropCampaign!
  # The time at which this drop becomes unavailable.
  endAt: Time!
  # A unique identifier.
  id: ID!
  # The name of this drop.
  name: String!
  # The drops that must have been claimed before this drop can be claimed / made progress for.
  preconditionDrops: [TimeBasedDrop!]
  # The number of minutes a user has to watch in order to claim the reward.
  requiredMinutesWatched: Int!
  # User specific data associated with the TimeBasedDrop.
  self: TimeBasedDropSelfEdge!
  # The time at which this drop becomes available.
  startAt: Time!
}

# User specific data associated with this drop.
type TimeBasedDropSelfEdge {
  # The current progress for a given user towards this drop.
  currentMinutesWatched: Int!
  # The ID of the drop reward granted to the user if the drop is claimable, returns null otherwise.
  dropInstanceID: ID
  # Indicates whether or not all preconditions have been met, and the drop is available to get progress.
  hasPreconditionsMet: Boolean!
  # Whether the user has already claimed their reward for this drop.
  isClaimed: Boolean!
}

# Single item of stats for the time series.
type TimeseriesItem {
  # Deprecated: Number of follows during this timestamp.
  follows: Int @deprecated(reason: "Use user.timeseriesStats.follows instead.")
  # Streamed duration (in minutes).
  minutesStreamed: Int!
  # Timestamp of the broken down time series.
  timestamp: Time!
  # Value at the timestamp.
  value: Float!
}

# The subcount series is able to display each datapoint according to the following durations.
enum TimeSeriesPeriod {
  # Period of one day per datapoint.
  DAY
  # Period of one month per datapoint.
  MONTH
}

# Stats within a time frame broken down by granularity.
# This is used for per channel stats, per team stats use "CreatorTimeseriesMetrics".
type TimeseriesStats {
  # Seconds of ads played per time chunk.
  adBreaksInSeconds: [TimeseriesItem!]
  # Ad time (in seconds) per hour per time chunk.
  adTimePerHour: [TimeseriesItem!]
  # Average number of viewers per time chunk.
  averageViewers: [TimeseriesItem!]
  # Number of chat messages per time chunk.
  chatMessages: [TimeseriesItem!]
  # Number of clip views per time chunk.
  clipViews: [TimeseriesItem!]
  # Number of clips created per time chunk.
  clipsCreated: [TimeseriesItem!]
  # Number of follows during this timestamp.
  follows: [TimeseriesItem!]
  # Granularity of the time series, default unit is five minutes.
  granularity: Granularity!
  # Host/Raid viewers per time chunk.
  hostRaidViewers: [TimeseriesItem!]
  # Deprecated: List of the number of follows within a time period, broken up by granularity.
  items: [TimeseriesItem!]
    @deprecated(
      reason: "Use specific metric from user.timeseriesStats instead."
    )
  # Live number of views per time chunk.
  liveViews: [TimeseriesItem!]
  # Max viewers per time chunk.
  maxViewers: [TimeseriesItem!]
  # Minutes watched per time chunk.
  minutesWatched: [TimeseriesItem!]
  # Number of subscriptions per time chunk.
  newSubscriptions: [TimeseriesItem!]
  # Promotion clicks for the time period.
  promotionClick: [TimeseriesItem!]
  # Promotion displays for the time period.
  promotionDisplay: [TimeseriesItem!]
  # Time streamed per time chunk.
  timeStreamed: [TimeseriesItem!]
  # Number of people chatting per time chunk.
  uniqueChatters: [TimeseriesItem!]
  # Number of unique people watching per time chunk.
  uniqueViewers: [TimeseriesItem!]
}

# A piece of the shelf title in the form of a token.
type TitleTokenEdge {
  # The token.
  node: TitleTokenNode
}

# The content of a shelf title token.
union TitleTokenNode = DateToken | Game | IntegerToken | Tag | TextToken | User
input ToggleRitualsEnabledInput {
  channelID: ID!
  isEnabled: Boolean!
}

type ToggleRitualsEnabledPayload {
  # Whether the rituals feature is enabled for a channel.
  isEnabled: Boolean!
  user: User
}

# Assets for a TokenBundleProduct.
# Each asset will have a 1x, 2x, 3x sizing w/ their respective URLs.
# Different sizing is required for mobile clients.
type TokenBundleAsset {
  # URL of asset of size 1x.
  imageURL1x: String!
  # URL of asset size 2x.
  imageURL2x: String!
  # URL of asset size 3x.
  imageURL3x: String!
  # Key identifier for an asset.
  # ex) "bundleImg", "promoImg", etc.
  key: String!
}

# Tournament is an object that contains all information about a tournament
# managed within Bits for a specific event tied to cheering.
# NOTE: Should have been named CheeringTournament.
type Tournament {
  # Leaderboard of all users who have cheered in the tournament.
  globalLeaderboard: BitsLeaderboard! @deprecated
  # Event ID of the tournament.
  id: ID! @deprecated
  # The list of global milestones that can be claimed in the tournament.
  # For a given threshold, this milestone is reached when cheers from all users on the channel
  # is greater than or equal to the threshold. This unlocks a reward for all users who have cheered.
  progress: TournamentProgress! @deprecated
  # The list of rewards that are a part of the tournament. This is separated out into global, participant, and individual
  # rewards that can be claimed if the user is logged in.
  rewards: TournamentRewards @deprecated
  # The list of individual milestones that can be claimed in the tournament.
  # for a given threshold, this milestone is reached when an individual user's total cheers in
  # the channel is greater than or equal to the threshold. This unlocks a reward
  # for the individual user who cheered.
  self: TournamentSelfEdge @deprecated
  # Leaderboard of all teams who have been cheered for in the tournament. This leaderboard contains how much each team
  # in the tournament was cheered for.
  teamLeaderboard: BitsLeaderboard! @deprecated
  # The list of teams participating in the tournament.
  teams: [TournamentTeam]! @deprecated
}

# Contains all rewards information about the Insider rewards.
type TournamentInsiderRewards {
  # Twitch chat badge rewards.
  badges: [TournamentReward!]! @deprecated
  # Bits rewards.
  bits: [TournamentReward!]! @deprecated
  # Hero skin rewards.
  heroSkins: [TournamentReward!]! @deprecated
  # In Game Content rewards, like sprays and avatars (non-hero skin rewards).
  inGameContent: [TournamentReward!]! @deprecated
}

# Describes the amount of progress that has been made in a tournament, with corresponding milestones about said progress.
type TournamentProgress {
  # The amount of progress that has been made in the tournament. This is not exclusive to cheering in the channel.
  amount: Int! @deprecated
  # The milestones associated with the progress made. This is a list of rewards the progress value will unlock.
  milestones: [Milestone!]! @deprecated
}

# Type containing information about a Reward and claiming information.
type TournamentReward {
  # The campaign ID associated with the reward.
  campaignID: ID! @deprecated
  # Can this reward be entitled to the user.
  canBeFulfilled: Boolean! @deprecated
  # Number representing quantity of the reward that user can claim (but not entitled yet) at the time the request is made.
  canBeFulfilledQuantity: Int! @deprecated
  # The reward's description.
  description: String! @deprecated
  # Number representing quantity of the reward that user already claimed and can
  # find in his inventory. If the type is In Game Content, Twitch already handed
  # off to the game through the fulfiller.
  entitledQuantity: Int! @deprecated
  # The ID of the reward.
  id: ID! @deprecated
  # The reward's display image URL.
  imageURL: String! @deprecated
  # The state of the reward is entitled to the user.
  isEntitled: Boolean! @deprecated
  # Whether the reward is for prime users only.
  isPrimeOnly: Boolean! @deprecated
  # Whether the reward can be earned multiple times (e.g. in game consumables).
  isRepeatable: Boolean! @deprecated
  # Metadata attached to the reward.
  metadata: CampaignRewardMetadata @deprecated
  # The display name of the reward.
  name: String! @deprecated
  # Amount of reward (e.g. amount for bits).
  quantity: Int! @deprecated
  # A number presenting the rarity of this reward (the higher the rarer).
  rarity: Int! @deprecated
  # The type of reward (ex. Twitch Emote, In Game Content).
  type: String! @deprecated
}

# This type holds all information about rewards that are associated with a tournament. The struct parses out
# which rewards are Global, Team, and Individual, as well as if you're logged in that status if you can claim the reward.
type TournamentRewards {
  # The list of Cheerbomb rewards. If the user is logged in, this will also show the claim status of the reward.
  cheerbomb: [TournamentReward!]! @deprecated
  # The list of Global rewards. If the user is logged in, this will also show the claim status of the reward.
  global: [TournamentReward!]! @deprecated
  # The list of Individual rewards. If the user is logged in, this will also show the claim status of the reward.
  individual: [TournamentReward!]! @deprecated
  # The list of Insider rewards, which are granted when one subscribes to the insider pass.
  insider: TournamentInsiderRewards! @deprecated
  # The list of Team rewards. If the user is logged in, this will also show the claim status of the reward.
  team: [TournamentReward!]! @deprecated
}

# Tournament progress related to a user.
type TournamentSelfEdge {
  # The leaderboard entry of the user. Gives the current position and score.
  globalLeaderboardItem: BitsLeaderboardItem @deprecated
  # Amount of progress a user had made towards the tournament personally. This could be a combination of factors,
  # including bits cheered in the channel.
  progress: TournamentProgress! @deprecated
  # A list of the amount of bits a user has cheered for a certain team, as well as the
  # list of milestones that the user could claim with their claim status.
  teams: [TournamentTeam!]! @deprecated
}

# Team is a construct that contains metadata about a team participating in the tournament,
# as well as the milestones associated with cheering for them.
type TournamentTeam {
  # The division of the team. This string is set by the tournament organizer. (NA, CN, Atlantic League, etc.).
  division: String! @deprecated
  # The ID of the team.
  id: ID! @deprecated
  # The image URL of the team.
  logoURL: String! @deprecated
  # Name of the team.
  name: String! @deprecated
}

# TrackAppealRequestInput the details needs about which track to appeal.
input TrackAppealRequestInput {
  # audibleMagicResponseID is the ID of the audible magic response.
  audibleMagicResponseID: ID!
  # reason is the reason the track is being appealed.
  reason: String!
}

# Information used to track recommendation events.
type TrackingInfo {
  # The target object for the shelf, if it exists.
  reasonTarget: String
  # The type of the target object, if it exists.
  reasonTargetType: String
  # The reason why this shelf has been recommended.
  reasonType: String!
  # The name of the shelf.
  rowName: String!
}

# A tracking pixel is used to measure impressions or demographics.
type TrackingPixel {
  # Where this pixel came from.
  origin: String
  # What service will be using the pixel.
  service: String!
  # How long a client needs to view the content before firing the pixel.
  timeOffsetSeconds: Int
  # The type of tracker.
  type: TrackingPixelType
  # The URL that is requested when the pixel is fired.
  url: String!
}

# The tracking pixel that will be created as part of this campaign.
input TrackingPixelInput {
  # How long a client needs to view the content before firing the pixel.
  timeOffsetSeconds: Int
  # The type of tracker.
  type: TrackingPixelType
  # The URL that is requested when the pixel is fired.
  url: String!
}

# The type of the tracking pixel.
enum TrackingPixelType {
  # Digital Ad Ratings, a Nielsen product that provides demographic data.
  DAR
  # DoubleClick Campaign Manager, a Google product to track ad performance.
  DCM
  # An impression tracking product.
  SIZMEK
}

# A trailer is a video meant to introduce viewers to the creator and the type
# of content they produce.
type Trailer {
  # The trailer video. This may be null if the channel has no trailer.
  video: Video
}

# TranscodeSession is session metadata related to transcode.
type TranscodeSession {
  # Transcoded audio codecs.
  audioCodecs: String!
  # Staff-only field. Hostname of which transcode was processed.
  host: String
  # Staff-only field. The location of transcode origin.
  ingestOrigin: String
  # Staff-only field. Profile of transcode.
  profile: String
  # Transcoded video codecs.
  videoCodecs: String!
}

# TransitionExtensionStateError is an error associated with the transitionExtensionState mutation.
enum TransitionExtensionStateError {
  # User is unable to make modifications to the extension.
  UNAUTHORIZED
  # The version does not have an asset hash and it must for the transition.
  MISSING_ASSET_HASH
  # Review notes were not specified when transitioning an extension to IN_REVIEW.
  MISSING_REVIEW_NOTES
  # Test channel was not specified when transitioning an extension to IN_REVIEW.
  MISSING_TEST_CHANNEL
  # Only one version of an Extension can be in a review state (APPROVED, or in IN_REVIEW) at a time.
  MULTIPLE_VERSIONS_IN_REVIEW
  # Author email cannot be empty when transit to READY_FOR_REVIEW.
  TRANSITION_MISSING_AUTHOR_EMAIL
  # Author name cannot be empty when transit to READY_FOR_REVIEW.
  TRANSITION_MISSING_AUTHOR_NAME
  # Category cannot be empty when transit to READY_FOR_REVIEW.
  TRANSITION_MISSING_CATEGORY
  # Support email cannot be empty when transit to READY_FOR_REVIEW.
  TRANSITION_MISSING_SUPPORT_EMAIL
  # Name cannot be empty when transit to READY_FOR_REVIEW.
  TRANSITION_MISSING_NAME
  # Version cannot be empty when transit to READY_FOR_REVIEW.
  TRANSITION_MISSING_VERSION
  # Testing base URI cannot be empty when transit to READY_FOR_REVIEW.
  TRANSITION_MISSING_TESTING_BASE_URI
  # Summary cannot be empty when transit to READY_FOR_REVIEW.
  TRANSITION_MISSING_SUMMARY
  # Description cannot be empty when transit to READY_FOR_REVIEW.
  TRANSITION_MISSING_DESCRIPTION
  # Screenshot URLs cannot be empy when transit to READY_FOR_REVIEW.
  TRANSITION_MISSING_SCREENSHOT_URLS
  # Invalid state transition.
  INVALID_STATE_TRANSITION
  # Version specified is invalid.
  INVALID_VERSION
  # At least one anchor must be specified.
  ANCHOR_REQUIRED
  # HasZoom was specified but ZoomPixels is missing.
  INVALID_ZOOM
  # The number of whitelisted broadcasters exceeds the limit.
  MAX_BROADCASTERS
  # The number of whitelisted testing users exceeds the limit.
  MAX_TESTERS
  # The number of whitelisted config URLs exceeds the limit.
  MAX_WHITELISTED_CONFIG_URLS
  # The number of whitelisted panel URLs exceeds the limit.
  MAX_WHITELISTED_PANEL_URLS
  # Extension names must be shorter than 40 characters.
  INVALID_NAME_LENGTH
  # Extension description must be shorter than 1024 characters.
  INVALID_DESCRIPTION_LENGTH
  # Extension summary must be shorter than 140 characters.
  INVALID_SUMMARY_LENGTH
  # Extension author email must not be nil. Lenght must be < 254, Parses a single RFC 5322 address.
  INVALID_AUTHOR_EMAIL
  # Extension support email must not be nil. Lenght must be < 254, Parses a single RFC 5322 address.
  INVALID_SUPPORT_EMAIL
  # Extension author name length must be > 40.
  INVALID_AUTHOR_NAME_LENGTH
  # Extension testing base uri must not be nil and empty scheme. Scheme should be http or https. User should not be nil.
  INVALID_TESTING_BASE_URI
  # Extension terms uri must not be nil and empty scheme. Scheme should be http or https. User should not be nil.
  INVALID_TERMS_URI
  # Extension privacy uri must not be nil and empty scheme. Scheme should be http or https. User should not be nil.
  INVALID_PRIVACY_URI
  # Extension component viewer path must not be nil. Format should be BaseUri/Extension_Path.
  INVALID_COMPONENT_VIEWER_PATH
  # Extension panel viewer path must not be nil. Format should be BaseUri/Extension_Path.
  INVALID_PANEL_VIEWER_PATH
  # Extension video overlay viewer path must not be nil. Format should be BaseUri/Extension_Path.
  INVALID_VIDEO_OVERLAY_VIEWER_PATH
  # Extension config viewer path must not be nil. Format should be BaseUri/Extension_Path.
  INVALID_CONFIG_VIEWER_PATH
  # Extension live config viewer path must not be nil. Format should be BaseUri/Extension_Path.
  INVALID_LIVE_CONFIG_VIEWER_PATH
  # Extension mobile viewer path must not be nil. Format should be BaseUri/Extension_Path.
  INVALID_MOBILE_VIEWER_PATH
  # Extension component aspect width must be < 50 or > 1.
  INVALID_COMPONENT_ASPECT_WIDTH
  # Extension component aspect height must be < 50 or > 1.
  INVALID_COMPONENT_ASPECT_HEIGHT
  # Extension panel hiehgt must be < 500 or > 100.
  INVALID_PANEL_HEIGHT
  # Extension Bits Support Level must ba valid member of the BitsSupportLevelEnum.
  INVALID_BITS_SUPPORT_LEVEL
  # Scale pixels must be set to a positive integer when autoscale is true.
  INVALID_SCALING_PIXELS
  # Aspect Ratio X must be set to a positive integer.
  INVALID_COMPONENT_ASPECT_RATIO_X
  # Aspect Ratio Y must be set to a positive integer.
  INVALID_COMPONENT_ASPECT_RATIO_Y
  # Target Height must be set to a positve integer.
  INVALID_COMPONENT_TARGET_HEIGHT
}

# TransitionExtesnsionManifest updates the state of an existing extension.
input TransitionExtensionStateInput {
  # The extension ID of the extension to update.
  id: ID!
  # Notes provided to the moderation team while reviewing the extension.
  # Required when transitioning to READY_FOR_REVIEW.
  reviewNotes: String
  # The State to transition the extension to.
  state: ExtensionState!
  # URL to a test channel, provided to the moderation team while reviewing the extension.
  # Required when transitioning to READY_FOR_REVIEW.
  testChannel: String
  # The extension version to update.
  version: String!
}

# TransitionExtensionStatePayload returns any errors that occur during update.
type TransitionExtensionStatePayload {
  # The error when the mutation fails to update an extension.
  error: TransitionExtensionStateError
  # The updated extension manifest.
  manifest: ExtensionManifest
}

# A result of a try to trigger a drop on a channel.
type TriggerResult {
  # The channel the drop was tried to be triggered on.
  channel: Channel
  # The drop instance id in case the drop was successfully triggered.
  dropInstanceID: ID
  # The status result of the try to trigger the drop.
  status: ManuallyTriggerDropResultStatus!
}

# Trigger type determines what type of events activate the trigger.
enum TriggerType {
  # CHEER type trigger is activated by cheer events.
  CHEER
}

# TrueXAd is descriptive information about an engagement that was show for bits.
# Used as input on the redeem trueXAd mutation.
input TrueXAd {
  # campaignID is the ID of the campaign this ad belongs to.
  campaignID: ID!
  # creativeID is the ID of the particular ad experience displayed to the user.
  creativeID: ID!
  # currencyAmount is the suggested amount of "currency" to provide to the user based on this ad.
  currencyAmount: String!
  # name is the name of the ad campaign.
  name: String!
}

# TutorialState represents the possible states of the user's viewing of the mod view tutorial.
enum TutorialState {
  # DISMISSED occurs when a user dismisses the tutorial.
  DISMISSED
  # SEEN occurs when a user has seen every step in a tutorial.
  SEEN
  # UNSEEN is the initial state, before a user has either dismissed or viewed the tutorial entirely.
  UNSEEN
}

# Mosaic layouts for Twitch Studio.
type TwitchStudioMosaicLayout implements ChannelDashboardLayout {
  # The actual Mosaic layout data to be stored or fetched.
  data: MosaicData!
  # A unique identifier to uniquely reference this layout.
  id: ID!
  # The display name for the layout shown to the user.
  name: String!
  # A version to identify how the MosaicData was generated,
  # such as for deprecation purposes.
  version: String!
  # When the layout was last updated
  lastUpdated: Time
}

# Two Factor Methods the user can have enabled.
enum TwoFactorMethod {
  # The user has 2fa enabled but does not have the authy app installed. Only way
  # for the user to receive the 2fa verification code is SMS.
  AUTHY_SMS
  # The user has 2fa enabled and has the authy app installed. The 2fa verification
  # code can be retreived from the authy app OR SMS.
  AUTHY_APP
  # The user has 2fa enabled and has gone through the totp onboarding process
  # successfully. The 2fa verification code can be retreived from the
  # authenticator app the user chose during onboarding.
  AUTHY_TOTP
  # unknown 2fa method.
  UNKNOWN
}

# Used to provide info on the subscription events that might have happened in another device
# and not acknowledged in the current device.
type UnacknowledgedSubscriptionEvent {
  # The user of the channel the subscription was for.
  channel: User
  # The time that the subscription benefits will expire.
  endDate: Time
  # The external product id.
  externalProductID: ID!
  # The current status of the subscription. One of "active", "will_not_renew", or "canceled".
  status: UnacknowledgedSubscriptionEventState!
  # The UUID of the subscription.
  subscriptionID: ID!
}

# Subscrption state of the reported unacknowledged events.
enum UnacknowledgedSubscriptionEventState {
  # The subscription is active.
  ACTIVE
  # Subscription will not renew, but may still be active.
  WILL_NOT_RENEW
  # Subscription will not renew and is not active.
  CANCELLED
  # Subscription that is on hold.
  ON_HOLD
}

# A request from a channel-banned user to the channel moderators to be unbanned
# from the channel.
type UnbanRequest {
  # The channel on which the banned user is appealing a ban.
  channel: Channel
  # The time at which the unban request was created.
  createdAt: Time!
  # UUID of the Unban Request.
  id: ID!
  # The banned user appealing the ban.
  requester: User
  # Custom message provided by the requester.
  requesterMessage: String
  # The time at which the unban request was resolved (approved or denied).
  resolvedAt: Time
  # The moderator that has taken action on the user.
  resolvedBy: User
  # Custom message provided by the resolver.
  resolverMessage: String
  # The status of the unban request.
  status: UnbanRequestStatus!
}

# Paginated list of Unban Requests.
type UnbanRequestConnection {
  # The elements of the list.
  edges: [UnbanRequestEdge!]
  # Information about this page.
  pageInfo: PageInfo!
  # Count of all pending unban requests.
  totalCount(status: UnbanRequestStatus = NONE): Float
}

# Element in a list of Unban Requests.
type UnbanRequestEdge {
  # Opaque cursor describing this edge's position in the paginated list.
  cursor: Cursor!
  # The unban request.
  node: UnbanRequest
}

# Error returned from an update mutation.
type UnbanRequestError {
  # The error code returned from an update mutation.
  code: UnbanRequestErrorCode!
}

# Possible errors arising from an update unban request mutation.
enum UnbanRequestErrorCode {
  # User does not have the permissions required to update the Unban Request.
  UNAUTHORIZED
  # Unban Request was not found.
  REQUEST_NOT_FOUND
  # Attempted status update was not valid.
  INVALID_UPDATE
  # Unknown error.
  UNKNOWN
}

# Reasons why a user may be restricted from requesting an unban.
enum UnbanRequestRestrictionReason {
  # User has already created an unban request for the current ban.
  ALREADY_CREATED
  # User is not banned on the channel.
  NOT_BANNED
  # User is attempting to create a request too since their ban. Must wait for cooldown period to end.
  TOO_SOON_SINCE_BAN
  # Channel is not receiving unban requests.
  UNBAN_REQUESTS_DISABLED
  # User must be logged in to be able to request an unban.
  UNAUTHENTICATED
  # Unknown restricted reason.
  UNKNOWN
}

# Optional filters that can be applied to an unban requests query.
input UnbanRequestsOptions {
  # The order of the results, either oldest first or newest first.
  order: UnbanRequestsSortOrder = NEWEST
  # Filter results to only requests of this status.
  status: UnbanRequestStatus
  # Filter results to only requests from this user.
  userID: ID
}

# Set of preferences set by the channel owner regarding unban requests.
type UnbanRequestsSettings {
  # The number of minutes after being banned before users can request an unban.
  cooldownMinutes: Int!
  # Whether users can create requests on the channel or not.
  isEnabled: Boolean!
}

# Ways to sort Unban Requests.
enum UnbanRequestsSortOrder {
  # The oldest request first.
  OLDEST
  # The newest request first.
  NEWEST
}

# Possible statuses of an unban request.
enum UnbanRequestStatus {
  # Default status. Is an invalid status state. Used as zero value when no specific status is specified.
  NONE
  # Approved; user is unbanned from the channel.
  APPROVED
  # User's unban request is denied; user remains banned in the channel.
  DENIED
  # A moderator decision has not been made on the Unban Request.
  PENDING
  # The user has had their unban request approved, and has acknowledged
  # the rules on the channel.
  ACKNOWLEDGED
  # The user has canceled their unban request.
  CANCELED
}

type UnbanUserFromChatRoomError {
  code: UnbanUserFromChatRoomErrorCode!
}

enum UnbanUserFromChatRoomErrorCode {
  # User does not have permission to unban in channel.
  FORBIDDEN
  # Target does not exist.
  TARGET_NOT_FOUND
  # Target is not banned in channel.
  TARGET_NOT_BANNED
}

input UnbanUserFromChatRoomInput {
  bannedUserLogin: String!
  channelID: ID!
}

type UnbanUserFromChatRoomPayload {
  # The new ban status of this user regarding the specified channel.
  ban: ChatRoomBanStatus
  # Mutation error caused by the user input.
  error: UnbanUserFromChatRoomError
}

input UnblockUserInput {
  # ID of user to unblock.
  targetUserID: ID!
}

type UnblockUserPayload {
  # User that was unblocked.
  targetUser: User!
}

# Data required to undo recommendation feedback.
input UndoRecommendationFeedbackInput {
  # The id of the feedback.
  feedbackID: ID!
  # The page this event was fired from.
  sourceItemPage: String!
  # The unique id given to this request.
  sourceItemRequestID: ID!
  # The unique tracking id of the shelf / shelf card.
  sourceItemTrackingID: ID!
}

# Returns the created feedback item back to the client.
type UndoRecommendationFeedbackPayload {
  # The id of the feedback you just undid.
  feedbackID: ID!
}

# UnfollowGameInput contains just the game ID of the game to unfollow.
input UnfollowGameInput {
  gameID: ID!
}

# UnfollowGamePayload is the response from unfollowing a game.
type UnfollowGamePayload {
  # The deleted follow relationship, if one existed beforehand.
  follow: GameFollow
  # The game that was unfollowed
  # game.self.follow should now be null.
  game: Game
}

input UnfollowUserInput {
  targetID: ID!
}

type UnfollowUserPayload {
  # The deleted follow relationship.
  follow: Follow
}

input UnfriendUserInput {
  # The authenticated user will no longer be friends with the user whose ID is equal to targetID.
  targetID: ID!
}

type UnfriendUserPayload {
  # The user whose friend relationship was just destroyed by the authenticated user.
  user: User
}

# UnhostInput contains the necessary inputs to unhost a channel.
input UnhostInput {
  # Channel ID to unhost from.
  channelID: ID!
}

# UnhostPayload is the response after attempting to unhost.
type UnhostPayload {
  # The channel that just unhosted.
  channel: User
}

# UninstallExtensionError is wrapper for error associated with the uninstallExtension mutation.
type UninstallExtensionError {
  # Error code.
  code: UninstallExtensionErrorCode!
}

# UninstallExtensionErrorCode is an error code associated with UninstallExtensionError.
enum UninstallExtensionErrorCode {
  # User is unable to make modifications to the extension.
  UNAUTHORIZED
  # Channel id is invalid, for example, is empty.
  INVALID_CHANNEL_ID
  # The extension is not installed on the channel.
  EXTENSION_NOT_INSTALLED
}

# The required input for an uninstallExtension mutation.
input UninstallExtensionInput {
  # The composite ID of an extension installation <extensionID:version:channelID>.
  extensionInstallationID: ID!
}

# The resulting payload of an uninstallExtension mutation.
type UninstallExtensionPayload {
  # The error when the mutation fails to set feature flags.
  error: UninstallExtensionError
  # The id of the extension which was uninstalled.
  id: ID!
}

# UnlinkAmazonConnectionInput represent the parameters necessary to unlink an amazon connection.
input UnlinkAmazonConnectionInput {
  # Id of the user that wishes to unlink his amazon connection.
  userID: ID
}

# UnlinkAmazonConnectionPayload indicates whether the unlinking was successful or not.
type UnlinkAmazonConnectionPayload {
  # Whether or not the unlink operation was successful. Only reports if the
  # underlying call was successful, as such will return true even if no unlinking
  # occured (such as when as user doesn't have a linked amazon account, for instance).
  isSuccess: Boolean
}

# User ID input of the connection being deleted.
input UnlinkRiotConnectionInput {
  # Twitch User ID to delete.
  userID: ID!
}

# Contains a struct of all current accounts connections.
type UnlinkRiotConnectionPayload {
  # The complete account connections list where Riot will be null.
  connections: AccountConnectionSet
}

input UnlinkSSOInput {
  # The single sign-on (SSO) app that should be unlinked from the authenticated user's account.
  app: String!
  # The token that identifies the user on the linked SSO app.
  token: String
}

type UnlinkSSOPayload {
  # The deleted SSO links.
  links: [SSOLink!] @deprecated(reason: "To be removed.")
}

# Input for unlocking a chosen modified subscriber emote with Community Points.
input UnlockChosenModifiedSubscriberEmoteInput {
  # The channel the emote is being redeemed on.
  channelID: ID!
  # The client's perception of the reward's cost.
  cost: Int!
  # The modified emote to unlock.
  emoteID: ID!
  # Client-set identifier for the transaction. This ID should be universally unique.
  transactionID: ID!
}

# The response from redeeming the unlock a chosen modified subscriber emote reward.
type UnlockChosenModifiedSubscriberEmotePayload {
  # The user's new Community Points balance.
  balance: Int
  # The error that occurred during redemption, if any.
  error: CommunityPointsUnlockEmoteError
}

# Input for unlocking a chosen subscriber emote with Community Points.
input UnlockChosenSubscriberEmoteInput {
  # The channel the emote is being redeemed on.
  channelID: ID!
  # The client's perception of the reward's cost.
  cost: Int!
  # The emote to unlock.
  emoteID: ID!
  # Client-set identifier for the transaction. This ID should be universally unique.
  transactionID: ID!
}

# The response from redeeming the unlock a chosen subscriber emote reward.
type UnlockChosenSubscriberEmotePayload {
  # The user's new Community Points balance.
  balance: Int
  # The error that occurred during redemption, if any.
  error: CommunityPointsUnlockEmoteError
}

# Input for unlocking a random subscriber emote with Community Points.
input UnlockRandomSubscriberEmoteInput {
  # The channel the emote is being redeemed on.
  channelID: ID!
  # The client's perception of the reward's cost.
  cost: Int!
  # Client-set identifier for the transaction. This ID should be universally unique.
  transactionID: ID!
}

# The response from redeeming the unlock a random subscriber emote reward.
type UnlockRandomSubscriberEmotePayload {
  # The user's new Community Points balance.
  balance: Int
  # The random emote that was unlocked.
  emote: CommunityPointsEmote
  # The error that occurred during redemption, if any.
  error: CommunityPointsUnlockEmoteError
}

# ModUserError contains details about a client error that occurred.
type UnmodUserError {
  # The enum indicating what error has occurred.
  code: UnmodUserErrorCode!
}

# UnmodUserErrorCode defines a client error that occurred while remove a moderator.
enum UnmodUserErrorCode {
  # The requesting user does not have permission to add a moderator in this channel.
  FORBIDDEN
  # The target user does not exist or has a suspended account.
  TARGET_NOT_FOUND
  # The channel does not exist.
  CHANNEL_NOT_FOUND
  # The target user is not a moderator.
  TARGET_NOT_MOD
}

# UnmodUserInput contains the parameters to remove a user as a moderator to a channel.
input UnmodUserInput {
  # The channel that the user will be removed as a moderator to.
  channelID: ID!
  # The ID of the user that will be removed as a moderator.
  # Either targetID or targetLogin must be provided.
  targetID: ID
  # The login of the user that will be removed as a moderator.
  # Either targetID or targetLogin must be provided.
  targetLogin: String
}

# UnmodUserPayload is the response when remove a user as a moderator.
type UnmodUserPayload {
  # The channel that the user is removed as a moderator to.
  channel: User
  # The client error that has occurred.
  # Null if the operation is successful.
  error: UnmodUserError
  # The user that is removed as a moderator.
  target: User
}

# UnsetHypeTrainConfigInput takes series of optional config settings and unsets the custom value for the default..
input UnsetHypeTrainConfigInput {
  # Custom emote to be rendered in Hype Train messaging.
  calloutEmote: Boolean
  # Length of the cooldown period after a hype train ends.
  cooldownPeriodMinutes: Boolean
  # The difficulty of hype train levels.
  difficulty: Boolean
  # Hype Train kickoff settings.
  eventsThreshold: Boolean
  # Whether hype train should be enabled.
  isEnabled: Boolean
  # A boolean flag that indicates if the hype train settings should be personalized by Twitch.
  shouldUsePersonalizedSettings: Boolean
  # Use creator color as base color of the Hype Train progress bar.
  willUseCreatorColor: Boolean
}

# UnsetHypeTrainConfigPayload is the response that contains the Unsetd config.
type UnsetHypeTrainConfigPayload {
  # The hype train config for the channel.
  config: HypeTrainConfig
}

# Input to the unsubscribe mutation. One of "channel" or "type" fields must be provided.
input UnsubscribeEmailInput {
  # The unique ID of the origin email.
  sourceEmailID: String!
  # The email type of the origin email.
  sourceEmailType: String!
  # ID of the channel whose notifications should be blocked.
  targetChannelID: ID
  # The email type from which the user is unsubscribing.
  targetEmailType: String
  # ID of the user requesting the unsubscribe action.
  userID: ID!
  # Server signature to verify authenticity of the link author.
  validatingHash: String!
}

# Output from the unsubscribe mutation.
type UnsubscribeEmailPayload {
  # Specifies whether the action was successful.
  isSuccess: Boolean!
}

# Inputs to the updateAdProperties mutation.
input UpdateAdPropertiesInput {
  # Toggle for disable prerolls for midrolls feature.
  hasDisablePrerollsAbilityEnabled: Boolean
  # Toggle for disable prerolls for midrolls notifcations.
  # The "Disable Prerolls" product is a way for streamers to disable preroll ads by running midroll ads.
  # The streamer can choose to enable notifications (ie. "Preroll Ads are now disabled for X minutes") for this product.
  hasDisablePrerollsNotificationsEnabled: Boolean
  # Toggle for enable multiplayer ads for subs.
  isMultiplayerAdsForSubsEnabled: Boolean
  # User the update belongs to.
  targetUserID: ID!
}

# Output from the updateAdProperties mutation.
type UpdateAdPropertiesPayload {
  # User/channel to update the ad settings.
  targetUser: User
}

# Inputs for updating all videos viewability by channel id mutation.
input UpdateAllChannelVideosViewabilityInput {
  # The ID of the channel to update all videos from.
  channelID: ID!
  # Determines viewability of all the channels videos.
  scope: VideoPrivacyScope!
}

# The returned payload from the UpdateAllChannelVideosViewability mutation.
type UpdateAllChannelVideosViewabilityPayload {
  # The status for this mutation.
  status: UpdateAllChannelVideosViewabilityStatus
}

# Status associated with mutation UpdateAllChannelVideosViewability.
type UpdateAllChannelVideosViewabilityStatus {
  # Error code.
  code: UpdateAllChannelVideosViewabilityStatusCode!
}

# The status codes for this mutation.
enum UpdateAllChannelVideosViewabilityStatusCode {
  # Update job was successful started.
  SUCCESS
  # User does not have permission to update videos.
  FORBIDDEN
  # Internal error.
  INTERNAL_ERROR
  # Invalid Argument.
  INVALID_ARGUMENT
  # Unknown Error.
  UNKNOWN
}

input UpdateAllWhisperThreadsInput {
  markAllAsRead: Boolean
}

type UpdateAllWhisperThreadsPayload {
  count: Int!
}

# UpdateAutohostSettingsInput update a user's autohost settings.
input UpdateAutohostSettingsInput {
  # True if this channel has the autohost feature turned on.
  isEnabled: Boolean
  # The strategy to use when choosing channels to autohost.
  strategy: AutohostSettingsStrategy
  # UserID to update settings for.
  userID: ID!
  # True if this user autohosts their team members.
  willAutohostTeam: Boolean
  # True if this channels prefers autohost over vodcast.
  willPrioritizeAutohost: Boolean
}

# UpdateAutohostSettingsPayload returns the user whose settings had been updated.
type UpdateAutohostSettingsPayload {
  # User whose autohost settings has been updated.
  user: User
}

# Defines AutoMod category level settings for a Channel, either overallLevel or detailedAutoModLevels should be non null.
input UpdateAutoModLevelsInput {
  # String ID of the channel AutoModProperties are being updated for.
  channelID: ID!
  # This field represents the detailed AutoMod category settings, which may map to an overallLevel.
  detailedLevels: DetailedAutoModLevelsInput
  # This field will be a value between 0 and 4, inclusive, it is not required.
  overallLevel: Int
}

# Defines the new AutoMod levels of a channel.
type UpdateAutoModLevelsPayload {
  # The new levels after applying the mutation.
  autoModConfiguration: AutoModConfiguration
}

input UpdateAutoModPropertiesInput {
  # These fields should be values between 0 and 6 inclusive.
  aggressiveLevel: Int!
  # String ID of the channel AutoModProperties are being updated for.
  channelID: String!
  identityLevel: Int!
  profanityLevel: Int!
  sexualLevel: Int!
}

type UpdateAutoModPropertiesPayload {
  # The new properties after applying the mutation.
  autoModProperties: AutoModProperties
}

# UpdateBitsBadgeTierNotificationInput is the input required when updating a bits badge tier notification.
input UpdateBitsBadgeTierNotificationInput {
  # Optional message to send when sharing notification. If supplied, will accompany user notice.
  message: String
  # Unique Identifier for the notification.
  notificationID: ID!
  # New state for notification.
  notificationState: BitsBadgeTierNotificationState!
}

# UpdateBitsBadgeTierNotificationPayload is the payload returned after updating a bits badge tier notification.
type UpdateBitsBadgeTierNotificationPayload {
  # The user that updated the bits badge tier notification.
  user: User
}

# Errors for updating bits badges.
type UpdateBitsBadgeTiersError {
  # The associated error code.
  code: UpdateBitsBadgeTiersErrorCode!
}

# Possible error codes returned for updating bits badges.
enum UpdateBitsBadgeTiersErrorCode {
  # Invalid parameters in the request.
  INVALID_PARAMETER
  # Badge title is too long.
  BADGE_TITLE_EXCEEDS_CHARACTER_LIMIT
  # Badge title did not pass moderation check.
  BADGE_TITLE_FAILED_MODERATION
  # The emote code submitted collides with an existing emote code.
  EMOTE_CODE_ALREADY_EXISTS
  # The emote code submitted is unacceptable (contains offensive, banned, or "bad" words, which violates guidelines).
  EMOTE_CODE_UNACCEPTABLE
  # The user cannot own any more emotes of this type.
  USER_OWNED_EMOTE_LIMIT_REACHED
  # Data for least one of the image sizes is not provided.
  INCOMPLETE_BADGE_IMAGE_DATA
  # Other errors returned from the service.
  UNKNOWN_ERROR
}

# Settings related to bits badges.
input UpdateBitsBadgeTiersInput {
  # A list of bits badge tiers to be modified.
  tiers: [BitsBadgeTierInput!]
  # The owner ID of the channel that the badge tiers belong to.
  userID: ID!
}

# Results of bits badge tier updates.
type UpdateBitsBadgeTiersPayload {
  # Whether or not the broadcaster is enabled to upload bits badge tier emote rewards.
  canUploadBadgeTierEmoticons: Boolean
  # Service error, if any.
  error: UpdateBitsBadgeTiersError
  # Updated bits badge tiers.
  tiers: [BitsBadgeTier!]
}

# Error code for an error that occurs while updating boost settings.
type UpdateBoostSettingsError {
  # Error code for error that occurred while updating boost settings.
  code: UpdateBoostSettingsErrorCode!
}

# Error types recognized.
enum UpdateBoostSettingsErrorCode {
  # Invalid parameter in the request.
  INVALID_PARAMETER
  # Internal error being returned from service.
  INTERNAL_ERROR
}

# The required input for a updateBoostSettings mutation.
input UpdateBoostSettingsInput {
  # The Id of the channel where we want to update the boost enable/disable settings.
  channelID: ID!
  # Whether the channel has enabled boost challenges.
  isEarnedEnabled: Boolean
  # Whether the channel has enabled boosts.
  isEnabled: Boolean
  # Whether the channel has enabled boosts paid for by the community.
  isPaidEnabled: Boolean
}

# The result of an updateBoostSettings mutation.
type UpdateBoostSettingsPayload {
  # The updated channel.
  channel: Channel
  # The possible error returned from the service.
  error: UpdateBoostSettingsError
}

# Possible error codes returned from updating broadcast settings.
enum UpdateBroadcastSettingsErrorCode {
  # User is not authorized to update broadcast settings for this channel.
  AUTH_FAILURE
  # Too many attempts to update broadcast settings.
  REQUESTS_THROTTLED
  # Language is invalid.
  LANGUAGE_NOT_VALID
  # Streaming status is too long.
  STATUS_TOO_LONG
  # Streaming status uses banned words.
  STATUS_USES_BANNED_WORDS
  # Game name is too long.
  GAME_NAME_TOO_LONG
  # Unrecognized error returned from the backend service.
  UNKNOWN_ERROR
}

# The required input for a updateBroadcastSettings mutation.
input UpdateBroadcastSettingsInput {
  # Indicate broadcaster's streaming language.
  broadcasterLanguage: String
  # The title of the game that the broadcaster is playing.
  game: String
  # The isMature boolean to set onto the user broadcast.
  isMature: Boolean
  # Channel's streaming Status.
  status: String
  # The Id of the user whose broadcast setting is being updated.
  userID: ID!
}

# The result of a updateBroadcastSettings mutation.
type UpdateBroadcastSettingsPayload {
  # The modified broadcast settings.
  broadcastSettings: BroadcastSettings
  # Error from updating broadcast settings, if any.
  error: UpdateBroadcastSettingsErrorCode
}

# Inputs for updating the user's celebration config.
input UpdateCelebrationConfigInput {
  # ID of channel to update the celebration config.
  channelID: ID!
  # If turn, celebrations are enabled on the channel.
  isEnabled: Boolean!
}

# Outputs from the update celebration config mutation.
type UpdateCelebrationConfigPayload {
  # The updated celebration config.
  celebrationConfig: CelebrationConfig
  # If present, there was an error with the request.
  error: CelebrationError
}

# Inputs for creating a new celebration.
input UpdateCelebrationInput {
  # Where on the channel page the celebration will show.
  area: CelebrationArea
  # ID of celebration to update.
  celebrationID: ID!
  # ID of channel where the celebration to update exists.
  channelID: ID!
  # Length the celebration will play.
  durationMilliseconds: Int
  # Effect which will show when the celebration triggers (ex Fireworks).
  effect: CelebrationEffect
  # Threshold which will trigger the celebration (ex: Cheering 100 Bits).
  eventThreshold: Int
  # Event type which will trigger the celebration (ex: Cheering Bits).
  eventType: CelebrationEventType
  # Intensity of the celebration.
  # Should be bounded (TBA) value which will determine the spectacle of the celebration.
  intensity: Int
  # If true, the celebration is enabled.
  isEnabled: Boolean
}

# Outputs from the Update celebration mutation.
type UpdateCelebrationPayload {
  # The updated celebration.
  celebration: Celebration
  # If present, there was an error with the request.
  error: CelebrationError
}

# Inputs for updating the user's celebration product config.
input UpdateCelebrationProductConfigInput {
  # List of celebrations products for purchase in the channel.
  celebrationProducts: [CelebrationProductConfigInput!]!
  # ID of channel to update the celebration product config.
  channelID: ID!
}

# Outputs from the updated celebration product config mutation.
type UpdateCelebrationProductConfigPayload {
  # The updated celebration products.
  celebrationProducts: [CelebrationProduct!]
  # If present, there was an error with the request.
  error: CelebrationError
}

# Inputs for updating the user's celebration user settings.
input UpdateCelebrationUserSettingsInput {
  # If true, celebrations are disabled for the user to see.
  isOptedOut: Boolean
}

# Outputs from the update celebration config mutation.
type UpdateCelebrationUserSettingsPayload {
  # The updated logged in user.
  currentUser: User
}

# The result of a UpdateChangelogReadTimePayload mutation.
type UpdateChangelogReadTimePayload {
  # The user whose changelog was marked as read.
  user: User
}

# Mutation input for updating chanlet content attributes.
input UpdateChanletContentAttributesInput {
  # Identifier of the chanlet.
  chanletID: ID!
  # A list of multi-view content attribute IDs.
  # The provided list will override the list of IDs currently stored.
  contentAttributeIDs: [ID!]
}

# Response payload.
type UpdateChanletContentAttributesPayload {
  # Updated chanlet.
  chanlet: Channel
}

# The possible error returned.
enum UpdateChannelCategoryShelfError {
  # The user making the update is not authorized to do so.
  FORBIDDEN
  # One or more of the category IDs in the input are invalid.
  INVALID_CATEGORY
  # The same category ID cannot be both shown and hidden.
  CANNOT_SHOW_AND_HIDE_CATEGORY
}

# The required input for a updateChannelClipsSetting mutation.
input UpdateChannelClipsSettingInput {
  # The Id of the channel where we want to update the clips enable/disable setting.
  channelID: ID!
  # If isClipsEnabled is true, allow the following roles to create Clips on the channel.
  creationRestrictedTo: ChannelClipsCreationRestrictedToInput
  # If there are clip creation restrictions, use the following to add options to those restrictions.
  creationRestrictionOptions: ChannelClipsCreationAuthRestrictionOptionsInput
  # Set whether or not users can create Clips on this channel.
  isClipsEnabled: Boolean!
}

# The result of a updateChannelClipsSetting mutation.
type UpdateChannelClipsSettingPayload {
  # The updated channel.
  channel: Channel
}

# The input to update a channel's category shelf content.
input UpdateChannelHomePreferencesInput {
  # A list of category IDs to hide from the category shelf.
  categoryIDsToHide: [ID!]
  # A list of category IDs to unhide from the category shelf.
  categoryIDsToUnhide: [ID!]
  # The ID of the channel whose category shelf is being updated.
  channelID: ID!
  # The hero preset.
  heroPreset: HeroPreset
  # The type of streamer shelf to display.
  streamerShelfType: StreamerShelfType
}

# The result of an update to the category shelf.
type UpdateChannelHomePreferencesPayload {
  # The channel with the modified category shelf.
  channel: Channel
  # The possible error returned.
  error: UpdateChannelCategoryShelfError
}

# An error returned from the updateChannelPredictionSettings mutation.
type UpdateChannelPredictionSettingsError {
  # Code describing the error.
  code: UpdateChannelPredictionSettingsErrorCode!
}

# Possible error codes from the updateChannelPredictionSettings mutation.
enum UpdateChannelPredictionSettingsErrorCode {
  # The authorized user is not allowed to update prediction settings for this channel.
  FORBIDDEN
  # An unknown error occurred.
  UNKNOWN
}

# Update a channel's Prediction Settings.
# All fields other than channelID are nullable; only specify fields that you wish to update.
input UpdateChannelPredictionSettingsInput {
  # Whether channel moderators are allowed to create and resolve Prediction Events.
  canModeratorsManagePredictions: Boolean
  # The ID of the channel to update the settings of.
  channelID: ID!
}

# Payload for updating a channel's Prediction Settings.
type UpdateChannelPredictionSettingsPayload {
  # If present, there was an error with the request.
  error: UpdateChannelPredictionSettingsError
  # The updated settings.
  settings: ChannelPredictionSettings
}

input UpdateChatColorInput {
  # Named color for normal users (e.g. "Blue"  or "Coral", see https://help.twitch.tv/customer/portal/articles/659095-twitch-chat-and-moderation-commands)
  # or a hex color for Turbo users (e.g. "#001122").
  color: String!
}

type UpdateChatColorPayload {
  # The user whose chat color was set.
  user: User
}

# Possible chat settings modifiable for the channel specified via ChannelID.
#
# NOTE: Subscribers-only chat mode settings are in the UpdateSubscriptionProduct
# mutation.
input UpdateChatSettingsInput {
  # autoModLevel is an integer from 0-4 representing the level of automoderation of chat
  # 0 is off, 4 is the highest level of moderation.
  #
  # Deprecated: No longer used.
  autoModLevel: Int
  # ID of the channel for which chat settings are being updated.
  channelID: String!
  # chatDelayInMs is the delay before non-mods see a message.
  chatDelayInMs: Int
  # followersOnlyDurationMinutes is the number of minutes a user must have
  # followed the broadcaster before being able to chat.
  followersOnlyDurationMinutes: Int
  # hideLinks indicates if links should be deleted from non-mod messages.
  hideLinks: Boolean
  # isBroadcasterLanguageModeEnabled indicates if the broadcaster requires chat messages to
  # match their language.
  #
  # Deprecated: No longer used.
  isBroadcasterLanguageModeEnabled: Boolean
  # Indicates whether chat is currently enforcing that messages may only contain
  # emotes.
  isEmoteOnlyModeEnabled: Boolean
  # If isOptedOutOfGlobalBannedWordsList is true, the legacy twitch banned words list will
  # be inserted into automod if the channel has automod enabled.
  #
  # Deprecated: No longer used.
  isOptedOutOfGlobalBannedWordsList: Boolean
  # Indicates whether chat is currently enforcing that messages must be
  # reasonably unique from recent messages. Previously known as "r9k mode".
  isUniqueChatModeEnabled: Boolean
  # requireVerifiedAccount indicates if users must be verified to chat.
  requireVerifiedAccount: Boolean
  # A list of chat rules to display to users when joining a chat channel.
  rules: [String!]
  # The number of seconds a user must wait in between sending chat messages
  # If value is null, slow mode is not enabled.
  slowModeDurationSeconds: Int
}

# Result of mutation is the updated ChatSettings object.
type UpdateChatSettingsPayload {
  # The new chatSettings after applying the mutation.
  chatSettings: ChatSettings
}

# Errors for updating a cheermote tier.
type UpdateCheermoteTierError {
  # The associated error code.
  code: UpdateCheermoteTierErrorCode!
}

# Possible error codes returned for updating a cheermote tier.
enum UpdateCheermoteTierErrorCode {
  # Only the cheermote owner is allowed to upload cheermotes.
  INVALID_OWNER
  # The uploaded image assets could not be parsed.
  INVALID_IMAGE_UPLOAD
  # The uploaded image assets could not be found.
  EMOTE_IMAGE_NOT_FOUND
  # There were not enough image assets supplied for the cheermote.
  NOT_ENOUGH_EMOTE_IMAGE_ASSETS
  # There were more image assets supplied than required for the cheermote.
  TOO_MANY_EMOTE_IMAGE_ASSETS
  # A static image asset was not supplied, but is required for the cheermote.
  EMOTE_MISSING_STATIC_ASSET
  # An animated image asset was not supplied, but is required for the cheermote.
  EMOTE_MISSING_ANIMATED_ASSET
  # Other errors returned from the service.
  UNKNOWN_ERROR
}

# The data needed to update or create a broadcaster's custom cheermotes for a given tier.
input UpdateCheermoteTierInput {
  # A list containing the image IDs for all assets needed for the cheermote tier.
  imageAssets: [EmoteImageAssetInput!]!
  # The cheermote tier that should be updated.
  tierThreshold: CheermoteTierThreshold!
  # The user whose cheermotes are being updated.
  userID: ID!
}

# Results of the cheermote tier update.
type UpdateCheermoteTierPayload {
  # Service error, if any.
  error: UpdateCheermoteTierError
}

# Partner settings related to chat badges with bits.
input UpdateCheerPartnerSettingsBadgesInput {
  # A list of tiers to modify.
  tiers: [BitsBadgeTierInput!]
}

# Partner settings related to chat messages with bits.
input UpdateCheerPartnerSettingsChatMessageInput {
  # The setting that controls if the user has project v enabled on their channel.
  isOptedOutOfProjectV: Boolean
  # The minimnm setting that controls the minimum bits that must be part of a cheer emote.
  minBitsPerEmote: Int
  # The minimum setting that controls the minimum amount a user must cheer in the channel.
  minBitsToCheer: Int
}

# Settings related to bits cheer bomb events.
input UpdateCheerPartnerSettingsCheerBombInput {
  # Flag that is true if the user has opted out of the cheer bomb event.
  isOptedOut: Boolean
}

# Partner settings related to the custom cheermote prefix.
input UpdateCheerPartnerSettingsCustomPrefixInput {
  # Flag that is set if the user has the custom cheermote prefix enabled.
  isEnabled: Boolean
}

# Mutation input for updating Bits partner channel settings.
input UpdateCheerPartnerSettingsInput {
  # Partner settings related to chat badges with bits.
  badges: UpdateCheerPartnerSettingsBadgesInput
  # Partner settings related to chat messages with bits.
  chatMessage: UpdateCheerPartnerSettingsChatMessageInput
  # Partner settings related to cheer bomb events.
  cheerBombEvent: UpdateCheerPartnerSettingsCheerBombInput
  # Partner settings related to the custom cheermote prefix.
  customPrefix: UpdateCheerPartnerSettingsCustomPrefixInput
  # Whether to onboard or offboard the user with bits.
  isOnboarded: Boolean
  # Partner settings related to the bits leaderboard.
  leaderboard: UpdateCheerPartnerSettingsLeaderboardInput
  # Partner settings related to the recent cheer message.
  recentCheer: UpdateCheerPartnerSettingsRecentCheerInput
  # Partner settings related to sponsored cheermote campaigns.
  sponsoredCheermote: UpdateCheerPartnerSettingsSponsoredCheermoteInput
  # The user ID to update channel settings.
  userID: ID!
}

# Partner settings related to the bits leaderboard.
input UpdateCheerPartnerSettingsLeaderboardInput {
  # Flag that is true if the user has bits leaderboards turned on.
  isEnabled: Boolean
  # The time period the user wants the leaderboard to be displayed as.
  timePeriod: String
}

# Result of mutation is the updated UserSettings object.
type UpdateCheerPartnerSettingsPayload {
  # The updated user settings object.
  cheer: CheerPartnerSettings!
}

# Partner settings related to the recent cheer message.
input UpdateCheerPartnerSettingsRecentCheerInput {
  # Flag that when true pins the recent cheer to their channel.
  canPin: Boolean
  # The minimum bits a user must cheer to show their cheer on the chat header.
  minimumBits: Int
  # The amount of time a recent cheer is shown before being dismissed.
  timeoutMilliseconds: Int
}

# Settings related to sponsored cheermote campaigns.
input UpdateCheerPartnerSettingsSponsoredCheermoteInput {
  # The campaign ID we are modifying for the user.
  id: ID!
  # Flag that is true if the user has opted in of the sponsored cheermote campaign.
  isOptedIn: Boolean!
}

# UpdateClipError is an error associated with the updateClip mutation.
type UpdateClipError {
  # The error when the clip fails to update a clip.
  message: String
}

# UpdateClipInput updates the title of the clip with the provided slug.
input UpdateClipInput {
  # The slug of the clip to update.
  slug: ID!
  # The new title of the clip.
  title: String
}

# UpdateClipPayload returns the updated clip.
type UpdateClipPayload {
  # The clip with its updated properties.
  clip: Clip!
  # The error when the clip fails to update a clip.
  error: UpdateClipError
}

# UpdateClipViewCountInput increments the viewcount of the provided slug.
input UpdateClipViewCountInput {
  # The slug of the clip to increment viewcount on.
  slug: ID!
}

# UpdateClipViewCount returns the clip that was updated.
type UpdateClipViewCountPayload {
  # The clip that was updated.
  # The views field is the only field that is updated, and the change is not reflected immediately.
  clip: Clip
}

# UpdateCollectionInput accepts a collection ID and parameters to update a collection.
input UpdateCollectionInput {
  # The id of the collection to be updated.
  collectionID: ID!
  # The updated description of the collection.
  description: String
  # The itemID of the item whose thumbnail will be collection's thumbnail.
  thumbnailInput: UpdateCollectionThumbnailInput
  # The updated title of the collection.
  title: String
  # The updated type of the collection.
  type: CollectionType
}

# UpdateCollectionPayload resolves the updated collection.
type UpdateCollectionPayload {
  # The collection that was just updated.
  collection: Collection!
}

# UpdateCollectionThumbnailInput accepts a item ID and item Type for the new collection's thumbnail.
input UpdateCollectionThumbnailInput {
  # The id of the item whose thumbnail will be collection's thumbnail.
  id: ID!
  # The type of the item whose thumbnail will be collection's thumbnail.
  type: String!
}

# An error from updating an automatic Community Points reward in a channel.
type UpdateCommunityPointsAutomaticRewardError {
  # An identifier for the error that occurred.
  code: UpdateCommunityPointsAutomaticRewardErrorCode
  # On COST_TOO_LOW, the minimum cost that can be set.
  minimumCost: Int
}

# The possible reasons updating an automatic Community Points reward in a channel could fail.
enum UpdateCommunityPointsAutomaticRewardErrorCode {
  # An unexpected error occurred.
  UNKNOWN
  # The current user is not allowed to update a reward in this channel.
  FORBIDDEN
  # The cost is below the minimum.
  COST_TOO_LOW
  # The cost is invalid. Must be a positive integer.
  COST_INVALID
  # The background color is invalid. Backgrounds must be a valid hex color, for example "FF0000".
  BACKGROUND_COLOR_INVALID
}

# Input for updating an automatic Community Points reward in a channel.
# Only the channelID and rewardType are required. All other fields are optional.
# Only set fields that are intended to be updated.
input UpdateCommunityPointsAutomaticRewardInput {
  # The optional custom background color for this reward.
  # Should be a hex color string, for example "FF0000".
  backgroundColor: String
  # The channel ID that the reward is being updated in.
  channelID: ID!
  # The point cost of this reward.
  cost: Int
  # Whether the reward is enabled.
  isEnabled: Boolean
  # The ID of the reward being updated.
  rewardType: CommunityPointsAutomaticRewardType!
  # A flag to reset this automatic reward's background color to default.
  shouldResetBackgroundColor: Boolean
  # A flag to reset this automatic reward's cost to default.
  shouldResetCost: Boolean
  # A flag to reset this automatic reward's image to default.
  shouldResetImage: Boolean
}

# The response from updating an automatic Community Points reward in a channel.
type UpdateCommunityPointsAutomaticRewardPayload {
  # An error that occurred while updating an automatic Community Points reward in a channel.
  error: UpdateCommunityPointsAutomaticRewardError
  # The newly updated reward.
  reward: CommunityPointsAutomaticReward
}

# An error from updating a channel's Community Points channel settings.
type UpdateCommunityPointsChannelSettingsError {
  # An identifier for the error that occurred.
  code: UpdateCommunityPointsChannelSettingsErrorCode
}

# The possible reasons updating a channel's Community Points channel settings could fail.
enum UpdateCommunityPointsChannelSettingsErrorCode {
  # An unexpected error occurred.
  UNKNOWN
  # The current user is not allowed to update this channel's settings.
  FORBIDDEN
  # The custom name failed AutoMod.
  NAME_AUTOMOD_FAILED
}

# Input for updating Community Points channel settings..
# Only the channelID is required. All other fields are optional.
# Only set fields that are intended to be updated.
input UpdateCommunityPointsChannelSettingsInput {
  # The channel ID to update the settings of.
  channelID: ID!
  # Whether the channel has community points turned on.
  isEnabled: Boolean
  # The channel's custom community points name.
  name: String
  # A flag to reset this channel's community points image to default.
  shouldResetImage: Boolean
  # A flag to reset this channel's community points name to default.
  shouldResetName: Boolean
}

# The response from updating a channel's Community Points channel settings.
type UpdateCommunityPointsChannelSettingsPayload {
  # The channel with the newly updated settings.
  channel: Channel
  # An error that occurred while updating a channel's Community Points channel settings.
  error: UpdateCommunityPointsChannelSettingsError
}

# Update community goal error.
type UpdateCommunityPointsCommunityGoalError {
  # The error code.
  code: UpdateCommunityPointsCommunityGoalErrorCode!
}

# Update community goal error code.
enum UpdateCommunityPointsCommunityGoalErrorCode {
  # Goal already exists.
  DUPLICATE_GOAL
  # Goal title failed automod.
  TITLE_AUTOMOD_FAILED
  # Goal title is invalid.
  TITLE_INVALID
  # Goal description failed automod.
  DESCRIPTION_AUTOMOD_FAILED
  # Goal description is invalid.
  DESCRIPTION_INVALID
  # Goal amount is invalid.
  GOAL_AMOUNT_INVALID
  # Goal duration is invalid.
  DURATION_INVALID
  # Goal background color is invalid.
  BACKGROUND_COLOR_INVALID
  # Goal cannot be updated since it has already been started.
  GOAL_STARTED
  # Goal status change invalid.
  INVALID_STATUS_CHANGE
  # Goal was not found.
  NOT_FOUND
  # The current user is not allowed to update goals for this channel.
  FORBIDDEN
  # An unknown error occurred.
  UNKNOWN
}

# Update community goal input.
input UpdateCommunityPointsCommunityGoalInput {
  # The amount of community points that this goal needs to succeed.
  amountNeeded: Int
  # The background color of this goal.
  backgroundColor: String
  # The channel.
  channelID: ID!
  # The description of this goal.
  description: String
  # The *initial* duration the streamer set for the goal.
  # Only really used during the UNSTARTED state; once the goal is started
  # the endedAt timestamp is populated (and updated for extended deadlines).
  durationDays: Int
  # The time the goal is scheduled to end. Used to extend a goal.
  endsAt: Time
  # The id of the goal.
  goalID: ID!
  # Reset background color to default if true.
  resetBackgroundColor: Boolean
  # Reset image to default if true.
  resetImage: Boolean
  # Reset max contribution per stream to default if true.
  resetMaxContributionPerStream: Boolean
  # The current status of this goal.
  status: CommunityPointsCommunityGoalStatus
  # The title of this goal.
  title: String
}

# Update community goal payload.
type UpdateCommunityPointsCommunityGoalPayload {
  # The error, if any.
  error: UpdateCommunityPointsCommunityGoalError
  # The community goal.
  goal: CommunityPointsCommunityGoal
}

# An error from updating a custom Community Points reward in a channel.
type UpdateCommunityPointsCustomRewardError {
  # An identifier for the error that occurred.
  code: UpdateCommunityPointsCustomRewardErrorCode!
}

# The possible reasons updating a custom Community Points reward in a channel could fail.
enum UpdateCommunityPointsCustomRewardErrorCode {
  # An unexpected error occurred.
  UNKNOWN
  # The current user is not allowed to update a reward in this channel.
  FORBIDDEN
  # The reward was not found.
  NOT_FOUND
  # The title failed AutoMod.
  TITLE_AUTOMOD_FAILED
  # The prompt failed AutoMod.
  PROMPT_AUTOMOD_FAILED
  # The cost is invalid. Costs must be greater than 0.
  COST_INVALID
  # The maxPerStream is invalid. maxPerStream must be greater than 0.
  MAX_PER_STREAM_INVALID
  # The title is invalid. Titles must not be empty and must be at most 45 characters long.
  TITLE_INVALID
  # The background color is invalid. Backgrounds must be a valid hex color, for example "FF0000".
  BACKGROUND_COLOR_INVALID
  # A reward with the provided title already exists. Custom reward titles must be unique.
  DUPLICATE_REWARD
  # The maxPerUserPerStream is invalid. maxPerUserPerStream must be greater than 0.
  MAX_PER_USER_PER_STREAM_INVALID
  # The globalCooldown is invalid. globalCooldown must be greater tham 0.
  GLOBAL_COOLDOWN_INVALID
}

# Input for updating a custom Community Points reward in a channel.
# Only the channelID and rewardID are required. All other fields are optional.
# Only set fields that are intended to be updated.
input UpdateCommunityPointsCustomRewardInput {
  # The optional custom background color for this reward.
  # Should be a hex color string, for example "FF0000".
  backgroundColor: String
  # The channel ID that the reward is being updated in.
  channelID: ID!
  # The point cost of this reward.
  cost: Int
  # The length of the global cooldown applied to rewards redeemed of this type.
  globalCooldownSetting: CommunityPointsCustomRewardGlobalCooldownSettingInput
  # Whether this reward has real world value.
  hasRealWorldValue: Boolean
  # Whether the reward is enabled.
  isEnabled: Boolean
  # Whether the reward is temporarily paused.
  isPaused: Boolean
  # Whether only subscribers are allowed to redeem this reward in this channel.
  isSubOnly: Boolean
  # Whether this reward requires users to enter text input.
  isUserInputRequired: Boolean
  # The most rewards of this type that can be redeemed per stream.
  maxPerStreamSetting: CommunityPointsCustomRewardMaxPerStreamSettingInput
  # The most rewards of this type that can be redeemed per user per stream.
  maxPerUserPerStreamSetting: CommunityPointsCustomRewardMaxPerUserPerStreamSettingInput
  # The optional user-facing prompt for this reward.
  prompt: String
  # The ID of the reward being updated.
  rewardID: ID!
  # Whether redemptions for this reward should skip the broadcaster's request queue and get
  # automatically fulfilled.
  shouldRedemptionsSkipRequestQueue: Boolean
  # A flag to reset this custom reward's image to the default.
  shouldResetImage: Boolean
  # The short title displayed for this reward.
  title: String
}

# The response from updating a custom Community Points reward in a channel.
type UpdateCommunityPointsCustomRewardPayload {
  # An error that occurred while updating a custom Community Points reward in a channel.
  error: UpdateCommunityPointsCustomRewardError
  # The newly updated reward.
  reward: CommunityPointsCustomReward
}

# An error from acting on a Community Points redemption.
type UpdateCommunityPointsCustomRewardRedemptionStatusError {
  # An identifier for the error that occurred.
  code: UpdateCommunityPointsCustomRewardRedemptionStatusErrorCode
}

# The possible reasons acting on a Community Points redemption could fail.
enum UpdateCommunityPointsCustomRewardRedemptionStatusErrorCode {
  # The redemption was not found.
  NOT_FOUND
  # The current user is not allowed to update the status of this redemption.
  FORBIDDEN
}

# Input for acting on all Community Points redemptions for a channel.
input UpdateCommunityPointsCustomRewardRedemptionStatusesByChannelInput {
  # The channel ID the redemptions were made in.
  channelID: ID!
  # The new status to set the redemptions to.
  newStatus: CommunityPointsCustomRewardRedemptionStatus!
  # The old status redemptions are currently set to.
  oldStatus: CommunityPointsCustomRewardRedemptionStatus!
}

# The response from acting on all Community Points redemptions for a channel.
# Most of the work is done as an async task and redemption status changes are pushed over pubsub.
type UpdateCommunityPointsCustomRewardRedemptionStatusesByChannelPayload {
  # An error that occurred while updating the redemption statuses.
  error: UpdateCommunityPointsCustomRewardRedemptionStatusesError
}

# Input for acting on the Community Points redemptions from the provided list.
input UpdateCommunityPointsCustomRewardRedemptionStatusesByRedemptionsInput {
  # The channel ID the redemptions were made in.
  channelID: ID!
  # The new status to set the redemptions to.
  newStatus: CommunityPointsCustomRewardRedemptionStatus!
  # The old status redemptions are currently set to.
  oldStatus: CommunityPointsCustomRewardRedemptionStatus!
  # The redemption IDs to update.
  redemptionIDs: [ID!]!
}

# The response from acting on the Community Points redemptions from the provided list.
# Most of the work is done as an async task and redemption status changes are pushed over pubsub.
type UpdateCommunityPointsCustomRewardRedemptionStatusesByRedemptionsPayload {
  # An error that occurred while updating the redemption statuses.
  error: UpdateCommunityPointsCustomRewardRedemptionStatusesError
}

# Input for acting on all Community Points redemptions for a reward.
input UpdateCommunityPointsCustomRewardRedemptionStatusesByRewardInput {
  # The channel ID the redemptions were made in.
  channelID: ID!
  # The new status to set the redemptions to.
  newStatus: CommunityPointsCustomRewardRedemptionStatus!
  # The old status redemptions are currently set to.
  oldStatus: CommunityPointsCustomRewardRedemptionStatus!
  # The reward ID to update all redemptions with oldStatus for.
  rewardID: ID!
}

# The response from acting on all Community Points redemptions for a reward.
# Most of the work is done as an async task and redemption status changes are pushed over pubsub.
type UpdateCommunityPointsCustomRewardRedemptionStatusesByRewardPayload {
  # An error that occurred while updating the redemption statuses.
  error: UpdateCommunityPointsCustomRewardRedemptionStatusesError
}

# An error from acting on a Community Points redemption.
type UpdateCommunityPointsCustomRewardRedemptionStatusesError {
  # An identifier for the error that occurred.
  code: UpdateCommunityPointsCustomRewardRedemptionStatusesErrorCode
}

# The possible reasons acting on a Community Points redemption could fail.
enum UpdateCommunityPointsCustomRewardRedemptionStatusesErrorCode {
  # An unexpected error occured.
  UNKNOWN
  # The current user is not allowed to update the statuses of these redemptions.
  FORBIDDEN
  # There is already a bulk update in progress for this reward / all rewards. Only one can be	processed at a time.
  IN_PROGRESS
}

# Input for acting on a Community Points redemption.
input UpdateCommunityPointsCustomRewardRedemptionStatusInput {
  # The channel ID the redemption was made in.
  channelID: ID!
  # The new status to set the redemption to.
  newStatus: CommunityPointsCustomRewardRedemptionStatus!
  # The redemption ID.
  redemptionID: ID!
}

# The response from acting on a Community Points redemption.
type UpdateCommunityPointsCustomRewardRedemptionStatusPayload {
  # An error that occurred while updating the redemption status.
  error: UpdateCommunityPointsCustomRewardRedemptionStatusError
  # The updated redemption.
  redemption: CommunityPointsCustomRewardRedemption
}

# An error returned when updating a user's enrollment in Community Points early access.
type UpdateCommunityPointsEarlyAccessError {
  # The error code identifying this error.
  code: UpdateCommunityPointsEarlyAccessErrorCode!
}

# An error returned when updating a user's enrollment in Community Points early access.
enum UpdateCommunityPointsEarlyAccessErrorCode {
  # The user is not allowed to opt in to the Community Points early access program.
  FORBIDDEN
  # There was some other error updating the user's enrollment.
  UNKNOWN
}

# Requests to change a user's enrollment status in the Community Points early access program.
input UpdateCommunityPointsEarlyAccessSettingsInput {
  # Sets whether the user is signing up for or removing themself from the early access program.
  isSignedUp: Boolean!
}

# Returns updated early access status for Community Points.
type UpdateCommunityPointsEarlyAccessSettingsPayload {
  # The channel whose Early Access preference was updated.
  channel: Channel
  # Optionally, an error that occurred while attempting to update the user's enrollment status.
  error: UpdateCommunityPointsEarlyAccessError
}

# An error from updating the last viewed community points content timestamps on a channel.
type UpdateCommunityPointsLastViewedContentError {
  # An identifier for the error that occurred.
  code: UpdateCommunityPointsLastViewedContentErrorCode
}

# The possible reasons updating the last viewed community points content timestamps on a channel could fail.
enum UpdateCommunityPointsLastViewedContentErrorCode {
  # An unexpected error occurred.
  UNKNOWN
  # The current user is not allowed to update last viewed timestamps for this channel.
  FORBIDDEN
}

# Input for updating the last viewed community points content timestamps on a channel.
# The global content that was viewed on the channel will also have the timestamps updated.
input UpdateCommunityPointsLastViewedContentInput {
  # The channelID where the content was viewed.
  channelID: ID!
  # The content types that were viewed.
  viewedContent: [CommunityPointsContentType!]!
}

# The response from updating the last viewed community points content timestamps on a channel.
type UpdateCommunityPointsLastViewedContentPayload {
  # An error that occurred while updating the last viewed content timestamps.
  error: UpdateCommunityPointsLastViewedContentError
  # The updated last viewed timestamps for a channels content.
  lastViewedChannelContent: [CommunityPointsLastViewedContentByType!]
  # The updated last viewed timestamps for global content across all of twitch.
  lastViewedGlobalContent: [CommunityPointsLastViewedContentByTypeAndID!]
}

# An error from updating a Community Points Smart Costs Acknowledgements in a channel.
type UpdateCommunityPointsSmartCostsAcknowledgementsError {
  # An identifier for the error that occurred.
  code: UpdateCommunityPointsSmartCostsAcknowledgementsErrorCode
}

# The possible reasons updating a Community Points Smart Costs Acknowledgement in a channel could fail.
enum UpdateCommunityPointsSmartCostsAcknowledgementsErrorCode {
  # An unexpected error occurred.
  UNKNOWN
  # The current user is not allowed to update a smart costs acknowledgement in this channel.
  FORBIDDEN
  # The cost is invalid. Must be a positive integer.
  LAST_ACKNOWLEDGED_COST_INVALID
}

# Input required for updating community points smart costs acknowledgements.
input UpdateCommunityPointsSmartCostsAcknowledgementsInput {
  # List of acknowledgements to update.
  acknowledgements: [SmartCostsAcknowledgementInput!]!
  # The channel ID that the reward is being updated in.
  channelID: ID!
}

# Payload returned after updating Community Points Smart Costs Acknowledgements.
type UpdateCommunityPointsSmartCostsAcknowledgementsPayload {
  # List of acknowledgements for community points smart costs that were updated.
  acknowledgements: [SmartCostsAcknowledgement!]
  # An error that occurred while updating a Community Points Smart Costs Acknowledgements in a channel.
  error: UpdateCommunityPointsSmartCostsAcknowledgementsError
}

# The competition contact info for updates.
input UpdateCompetitionContactInfoInput {
  # Link to Discord server for competition contact purposes.
  discordURL: String
  # Email address point of contact for the competition.
  email: String
}

# Update a Competition.
input UpdateCompetitionInput {
  # Banner image for the competition event page.
  bannerImageURL: String
  # This is the amount of time (in minutes) available for participants to check-in once competition startAt has passed.
  checkInDurationMinutes: Int
  # Long form description of the competition.
  description: String
  # The time the competition is scheduled to end.
  endAt: Time
  # The predefined structure of phases and lobbies.
  formatType: FormatType
  # The game being played in the competition>.
  gameID: ID
  # ID of the Competition we want to update.
  id: ID!
  # Primary artwork for the competition.
  imageURL: String
  # Specific format restrictions for a competition.
  leaderboardDetails: UpdateCompetitionLeaderboardDetailsInput
  # The name of the competition.
  name: String
  # The participant-facing points of contact for the competition that only registered participants can see.
  participantOnlyContactInfo: UpdateCompetitionContactInfoInput
  # Long form text block description that explains the prizing for the competition
  # and will be converted to Markdown client-side.
  prizeDescription: String
  # The public points of contact for the competition that anyone can see.
  publicContactInfo: UpdateCompetitionContactInfoInput
  # The time the competition is scheduled to end registration.
  registrationEndAt: Time
  # The maximum number of players in a REGISTERED state.
  registrationLimit: Int
  # Long form text block description that explains the rules for the competition
  # and will be converted to Markdown client-side.
  rulesDescription: String
  # The time the competition is scheduled to start.
  startAt: Time
  # The state of the tournament.
  state: CompetitionState
  # The size of a team when ParticipantType is Team.
  teamSize: Int
  # Link URL to any additional terms and conditions.
  termsURL: String
}

# Editable fields for Leaderboard competition details.
input UpdateCompetitionLeaderboardDetailsInput {
  # The max participant count for a lobby in phase.
  lobbyMaxSize: Int
  # The number of phases a competition should have.
  phaseCount: Int
  # The way points are assigned to a participant in case of a tie.
  tiebreakerLabel: TiebreakerLabel
}

# Data that was mutated after the competition was updated.
type UpdateCompetitionPayload {
  # The competition which was updated.
  competition: Competition
  # Used for competition mutation errors.
  error: CompetitionError
}

# Update the state of a player in a Competition.
input UpdateCompetitionPlayerInput {
  # Unique Competition ID.
  competitionID: ID!
  # The discord username for the player.
  discordUsername: String
  # The in game username for the player.
  inGameUsername: String
  # Indicates whether the player is disqualified.
  isDisqualified: Boolean
  # The state a player has in the competition we want to change.
  state: CompetitionPlayerState
  # Twitch user id of the player.
  userID: ID!
}

# Data that was mutated after the player was updated.
type UpdateCompetitionPlayerPayload {
  # The new state of competition after updating a competition player in the competition.
  competition: Competition
  # Used for competition mutation errors.
  error: CompetitionError
}

# Update a team in a Competition.
input UpdateCompetitionTeamInput {
  # Twitch user id of the participant to make into the TeamCaptain.
  captainID: ID
  # Unique Competition ID.
  competitionID: ID!
  # Indicates whether the team is disqualified.
  isDisqualified: Boolean
  # The user ids of the team members.
  members: [ID!]
  # Unique Team ID for the specified Competition.
  teamID: ID!
  # The new name of the team.
  teamName: String
}

# Data that was mutated after the CompetitionTeam was updated.
type UpdateCompetitionTeamPayload {
  # The competition that was updated.
  competition: Competition
  # Used for competition mutation errors.
  error: CompetitionError
}

# Error associated with mutation UpdateConsent.
type UpdateConsentError {
  # Error code.
  code: UpdateConsentErrorCode
}

# Client Error Code.
enum UpdateConsentErrorCode {
  # Invalid vendor name or law name or consent status.
  INVALID_VENDOR_LAW_CONSENT_STATUS
}

# UpdateConsentInput updates or creates a consent status for a privacy law.
input UpdateConsentInput {
  # Consent Session ID.
  consentSessionID: ID!
  # Privacy rule set of applicable law, e.g. CCPA or GDPR.
  privacyLawName: PrivacyLawName!
  # Consent status for each vendor.
  vendorStatus: [VendorConsentStatusInput!]!
}

# UpdateConsentPayload returns the created or updated consent status.
type UpdateConsentPayload {
  # The full consent status given by the user after the create request.
  consent: Consent
  # The possible error returned from service.
  error: UpdateConsentError
}

# Update tags associated with CLIP, STREAM, or VOD with contentID.
input UpdateContentTagsInput {
  # List of tag IDs to be added from the content.
  addedTagIDs: [ID!]
  # ID of the channel owning the content.
  authorID: ID!
  # ID of content: Channel ID for Streams, Slugs for Clips, and VOD ids for VODs.
  contentID: ID!
  # Type of content being returned. Can only be of values CLIP, STREAM, or VOD.
  contentType: ContentType!
  # List of tag IDs to be removed from the content.
  removedTagIDs: [ID!]
}

# Result of mutation is the contentID.
type UpdateContentTagsPayload {
  # Content which tags have been updated.
  content: TaggedContent
}

# Error codes for issues that may occur when trying to update an
# existing Mosaic layout.
enum UpdateDashboardViewMosaicLayoutErrorCode {
  # An unhandled error.
  UNKNOWN
  # A layout matching the provided ID was not found.
  NOT_FOUND
  # The name argument is invalid.
  INVALID_ARGUMENT_NAME
  # The layout argument is invalid.
  INVALID_ARGUMENT_LAYOUT
  # The version argument is invalid.
  INVALID_ARGUMENT_VERSION
  # The layoutID argument is required.
  INVALID_ARGUMENT_LAYOUTID
  # The userID argument is required.
  INVALID_ARGUMENT_USERID
  # One or more unspecified aguments are invalid. These are not
  # user-actionable, but might indicate a logic error.
  INVALID_ARGUMENT
}

# Input for updating properties of an existing Mosaic layout.
# Must specify the id of the layout, which is validated based
# on the current userID. Must also specify the type of the layout.
# Other fields are optional; only specified fields are updated,
# and undefined ones are left unchanged.
input UpdateDashboardViewMosaicLayoutInput {
  # The Mosaic data blob (in string form) representing a Mosaic layout.
  # If left undefined, the data will not be changed.
  data: MosaicData
  # The id of the specific mosaic layout to be updated. This identifies
  # a combination of type and channel for this user, and has an additional
  # unique component to distinguish it from other layouts for this type and channel.
  id: ID!
  # The display name of the layout. This allows the display name to be changed.
  # If left undefined, the display name will not be changed.
  name: String
  # The version tag for a Mosaic layout, which can be optionally updated.
  # If left undefined, the value will not be changed.
  version: String
}

# Result of the updateDashboardViewMosaicLayout mutation.
type UpdateDashboardViewMosaicLayoutPayload {
  # Represents an error when attempting to update a layout, if applicable.
  errorCode: UpdateDashboardViewMosaicLayoutErrorCode
  # The the layout that was updated.
  layout: ChannelDashboardLayout
}

# UpdateDropBenefitInput has fields required to update a drop benefit.
input UpdateDropBenefitInput {
  # The redirect URL where a user can link their account.
  accountLinkURL: String!
  # The ID of this benefit object.
  benefitID: ID!
  # The global limit of how often this benefit can be entitled to a user.
  entitlementLimit: Int!
  # The game that awarded the Drop.
  gameID: ID!
  # Specifies if this reward is considered for a game that is available on iOS.
  isIosAvailable: Boolean
  # The display name of this benefit object.
  name: String!
  # The RBAC organization ID of the owner.
  ownerID: ID!
}

# UpdateDropBenefitOnDropInput has fields required to update a drop's benefit.
input UpdateDropBenefitOnDropInput {
  # The benefit to add to the drop.
  benefitID: ID!
  # How many times the drop can award the benefit.
  dropEntitlementLimit: Int!
  # The drop to add the benefit to.
  dropID: ID!
}

# UpdateDropBenefitOnDropPayload returns the result of the update.
type UpdateDropBenefitOnDropPayload {
  # Returns the updated Campaign.
  dropCampaign: DropCampaign
  # A mapped error returned by the drops management service.
  error: DropsError
}

# UpdateDropBenefitPayload returns the result of the update.
type UpdateDropBenefitPayload {
  # Returns the updated Benefit.
  dropBenefit: DropBenefit
  # A mapped error returned by the drops management service.
  error: DropsError
}

# UpdateDropPreconditionsInput has fields required to update multiple drops and their precondition drop.
input UpdateDropPreconditionsInput {
  # The campaign we want to update drops for.
  campaignID: ID!
  # A list of drops and their drop precondition.
  dropPreconditions: [DropPrecondition]!
}

# UpdateDropPreconditionsPayload returns the result of the update.
type UpdateDropPreconditionsPayload {
  # Returns the updated Campaign.
  dropCampaign: DropCampaign
  # A mapped error returned by the drops management service.
  error: DropsError
}

# The required input for a updateDropsOptOutStatus mutation.
input UpdateDropsOptOutStatusInput {
  # Channel's drop opt-out Status.
  isOptedOut: Boolean!
  # The Id of the user whose broadcast setting is being updated.
  userID: ID!
}

# The result of a updateDropsOptOutStatus mutation.
type UpdateDropsOptOutStatusPayload {
  # Status is the updated status.
  isOptedOut: Boolean
  # userID is the user who wishes to opt out of drops.
  userID: ID
}

# Errors for updating emote orders.
type UpdateEmoteOrdersError {
  # The associated error code.
  code: UpdateEmoteOrdersErrorCode!
}

# The expected errors that can be returned from the UpdateEmoteOrders mutation.
enum UpdateEmoteOrdersErrorCode {
  # The user is not permitted to update the orders of the requested emotes or group.
  UNAUTHORIZED
  # No emote was found with the requested emote ID.
  BAD_EMOTE_REQUEST
  # No group was found with the requested group ID.
  BAD_GROUP_REQUEST
  # The orders provided result in an invalid set of orders in a particular group.
  BAD_NON_UNIQUE_ORDERS_REQUEST
  # An unexpected error occurred.
  UNKNOWN_ERROR
}

# The required input for an updateEmoteOrders mutation.
input UpdateEmoteOrdersInput {
  # The list of emotes with their newly requested orders in a particular group.
  orders: [EmoteOrder!]!
}

# The result of an updateEmoteOrders mutation.
type UpdateEmoteOrdersPayload {
  # Emotes are the newly reordered emotes.
  emotes: [Emote!]
  # Service error, if any.
  error: UpdateEmoteOrdersError
}

# UpdateExtensionDiscoveryDataError is an error associated with the updateExtensionDiscoveryData mutation.
enum UpdateExtensionDiscoveryDataError {
  # User is unable to make modifications to the extension.
  UNAUTHORIZED
  # Version specified is invalid.
  INVALID_VERSION
  # Extension names must be shorter than 40 characters.
  INVALID_NAME_LENGTH
  # Extension description must be shorter than 1024 characters.
  INVALID_DESCRIPTION_LENGTH
  # Extension summary must be shorter than 140 characters.
  INVALID_SUMMARY_LENGTH
  # Extension author email must not be nil. Lenght must be < 254, Parses a single RFC 5322 address.
  INVALID_AUTHOR_EMAIL
  # Extension support email must not be nil. Lenght must be < 254, Parses a single RFC 5322 address.
  INVALID_SUPPORT_EMAIL
  # Extension author name length must be > 40.
  INVALID_AUTHOR_NAME_LENGTH
  # Extension testing base uri must not be nil and empty scheme. Scheme should be http or https. User should not be nil.
  INVALID_TESTING_BASE_URI
  # Extension terms uri must not be nil and empty scheme. Scheme should be http or https. User should not be nil.
  INVALID_TERMS_URI
  # Extension privacy uri must not be nil and empty scheme. Scheme should be http or https. User should not be nil.
  INVALID_PRIVACY_URI
}

# UpdateExtensionDiscoveryDataInput updates the discovery data of a given extension version.
input UpdateExtensionDiscoveryDataInput {
  # Extension metadata used for discovery.
  discoveryManifest: ExtensionDiscoveryManifestInput!
  # The extension ID of the manifest to update.
  id: ID!
  # The extension version to update.
  version: String!
}

# UpdateExtensionDiscoveryDataPayload returns the update Extension discovery metadata.
type UpdateExtensionDiscoveryDataPayload {
  # The error when the mutation fails to update an extension.
  error: UpdateExtensionDiscoveryDataError
  # The updated extension discovery data.
  manifest: ExtensionVersionDiscoveryManifest
}

# UpdateExtensionManifestError is an error associated with the updateExtensionManifest mutation.
enum UpdateExtensionManifestError {
  # User is unable to make modifications to the extension.
  UNAUTHORIZED
  # Version specified is invalid.
  INVALID_VERSION
  # At least one anchor must be specified.
  ANCHOR_REQUIRED
  # HasZoom was specified but ZoomPixels is missing.
  INVALID_ZOOM
  # The number of whitelisted broadcasters exceeds the limit.
  MAX_BROADCASTERS
  # The number of whitelisted testing users exceeds the limit.
  MAX_TESTERS
  # The number of whitelisted config URLs exceeds the limit.
  MAX_WHITELISTED_CONFIG_URLS
  # The number of whitelisted panel URLs exceeds the limit.
  MAX_WHITELISTED_PANEL_URLS
  # Extension names must be shorter than 40 characters.
  INVALID_NAME_LENGTH
  # Extension description must be shorter than 1024 characters.
  INVALID_DESCRIPTION_LENGTH
  # Extension summary must be shorter than 140 characters.
  INVALID_SUMMARY_LENGTH
  # Extension author email must not be nil. Lenght must be < 254, Parses a single RFC 5322 address.
  INVALID_AUTHOR_EMAIL
  # Extension support email must not be nil. Lenght must be < 254, Parses a single RFC 5322 address.
  INVALID_SUPPORT_EMAIL
  # Extension author name length must be > 40.
  INVALID_AUTHOR_NAME_LENGTH
  # Extension testing base uri must not be nil and empty scheme. Scheme should be http or https. User should not be nil.
  INVALID_TESTING_BASE_URI
  # Extension terms uri must not be nil and empty scheme. Scheme should be http or https. User should not be nil.
  INVALID_TERMS_URI
  # Extension privacy uri must not be nil and empty scheme. Scheme should be http or https. User should not be nil.
  INVALID_PRIVACY_URI
  # Extension component viewer path must not be nil. Format should be BaseUri/Extension_Path.
  INVALID_COMPONENT_VIEWER_PATH
  # Extension panel viewer path must not be nil. Format should be BaseUri/Extension_Path.
  INVALID_PANEL_VIEWER_PATH
  # Extension video overlay viewer path must not be nil. Format should be BaseUri/Extension_Path.
  INVALID_VIDEO_OVERLAY_VIEWER_PATH
  # Extension config viewer path must not be nil. Format should be BaseUri/Extension_Path.
  INVALID_CONFIG_VIEWER_PATH
  # Extension live config viewer path must not be nil. Format should be BaseUri/Extension_Path.
  INVALID_LIVE_CONFIG_VIEWER_PATH
  # Extension mobile viewer path must not be nil. Format should be BaseUri/Extension_Path.
  INVALID_MOBILE_VIEWER_PATH
  # Extension component aspect width must be < 50 or > 1.
  INVALID_COMPONENT_ASPECT_WIDTH
  # Extension component aspect height must be < 50 or > 1.
  INVALID_COMPONENT_ASPECT_HEIGHT
  # Extension panel hiehgt must be < 500 or > 100.
  INVALID_PANEL_HEIGHT
  # Extension Bits Support Level must ba valid member of the BitsSupportLevelEnum.
  INVALID_BITS_SUPPORT_LEVEL
}

# UpdateExtensionManifestInput updates the manifest.
input UpdateExtensionManifestInput {
  # ExtensionAssetManifest is data related to the assets of an extension.
  assetManifest: ExtensionAssetManifestInput!
  # Data about what an Extension can do, in general, and at the time of interaction.
  capabilities: ExtensionCapabilitiesInput!
  # ExtensionDeveloperManifest is the developer specific extension data.
  developerManifest: ExtensionDeveloperManifestInput!
  # Extension metadata used for discovery.
  discoveryManifest: ExtensionDiscoveryManifestInput!
  # The extension ID of the manifest to update.
  id: ID!
  # The extension version to update.
  version: String!
  # Extension views.
  views: ExtensionViewsInput!
}

# UpdateExtensionManifestPayload returns the update Extension manifest.
type UpdateExtensionManifestPayload {
  # The error when the mutation fails to update an extension.
  error: UpdateExtensionManifestError
  # The updated extension manifest.
  manifest: ExtensionManifest
}

# UpdateHypeTrainConfigInput takes series of optional config settings.
input UpdateHypeTrainConfigInput {
  # Custom emote to be rendered in Hype Train messaging.
  calloutEmoteID: ID
  # Length of the cooldown period after a hype train ends.
  cooldownPeriodMinutes: Int
  # The difficulty of hype train levels.
  difficulty: HypeTrainDifficulty
  # Whether hype train should be enabled.
  isEnabled: Boolean
  # Hype Train kickoff settings.
  kickoff: HypeTrainKickoffInput
  # A boolean flag that indicates if the hype train settings should be personalized by Twitch.
  shouldUsePersonalizedSettings: Boolean
  # Use creator color as base color of the Hype Train progress bar.
  willUseCreatorColor: Boolean
}

# UpdateHypeTrainConfigPayload is the response that contains the updated config.
type UpdateHypeTrainConfigPayload {
  # The updated hype train config for the channel.
  config: HypeTrainConfig
}

# Updates the user's activity sharing setting. This must only be sent in response to a direct action by the user
# intended to change the setting.
input UpdateIsSharingActivityInput {
  # Determines whether or not to show the user's activity in their shared status. When false, the user will always
  # appear as if they are performing no activity.
  isSharingActivity: Boolean!
}

type UpdateIsSharingActivityPayload {
  # The modified user.
  user: User
}

# Mutation input for updating partner leaderboard settings.
input UpdateLeaderboardSettingsInput {
  # The default leaderboard the user wants to show.
  defaultLeaderboard: LeaderboardType
  # Setting for enabling bits cheering leaderboards.
  isCheerEnabled: Boolean
  # Setting for enabling sub gifting leaderboards.
  isSubGiftEnabled: Boolean
  # The time period the user wants the leaderboard to be displayed as.
  timePeriod: LeaderboardTimePeriodType
  # The user ID to update leaderboard settings.
  userID: ID!
}

# Result of mutation is the updated user object.
type UpdateLeaderboardSettingsPayload {
  # The user whose settings were updated.
  user: User
}

# The required input for a updateLiveUpNotification mutation.
input UpdateLiveUpNotificationInput {
  # The text that will be in the notification that sends when the user starts broadcasting.
  # If updated to "", the default value of "<user> went live!" will be used/returned.
  liveUpNotification: String!
  # The ID of the user whose live up notification is being updated.
  userID: ID!
}

# Returned after live up notification state is mutated.
type UpdateLiveUpNotificationPayload {
  # The modified broadcast settings.
  broadcastSettings: BroadcastSettings
  # If any validation errors occur, this will not be nil.
  error: UpdateLiveUpNotificationValidationError
}

# Resolver for validation errors that occur on update live up notification.
type UpdateLiveUpNotificationValidationError {
  # Error code that describes the validation error.
  code: UpdateLiveUpNotificationValidationErrorCode!
}

# Validation error status codes.
enum UpdateLiveUpNotificationValidationErrorCode {
  # The notification text sent did not pass auto mod.
  FAILED_AUTOMOD
  # The notification text sent is too long.
  TOO_LONG
  # The target user is not found.
  USER_NOT_FOUND
}

# Inputs for updating the score for the lobby participant, who is a competition player or competition team, in a competition.
input UpdateLobbyParticipantScoreInput {
  # ID of the competition.
  competitionID: ID!
  # ID of the competition lobby.
  lobbyID: ID!
  # ID of the competition player or competition team.
  participantID: ID!
  # ID of the competition phase.
  phaseID: ID!
  # The assigned score value.
  score: Int!
}

# UpdateLobbyParticipantScorePayload is the success response updating the score
# for the lobby participant, who is a competition player or competition team, in a competition.
type UpdateLobbyParticipantScorePayload {
  # The new state of competition after scoring a competition player or competition team for that lobby.
  competition: Competition
  # Used for competition mutation errors.
  error: CompetitionError
}

# Exchanges one of two auth inputs for an AccessToken and RefreshToken.
input UpdateLWATokenInput {
  # Either an AuthorizationCode or a RefreshToken.
  grant: String!
  # The type of grant provided.
  grantType: GrantType!
}

# Returns updated tokens, or an error if a new LWA flow is required.
type UpdateLWATokenPayload {
  # An error in this flow means the client should redo the LWA flow.
  error: WatchPartyError
  # Contains all token information.
  token: LWAToken
}

# Contains a list of multi-view content attributes to be updated.
input UpdateMultiviewContentAttributesInput {
  # List of multi-view content attributes to be updated.
  params: [MultiviewContentAttributeParams!]!
}

# Contains the server response payload.
type UpdateMultiviewContentAttributesPayload {
  # Unprocssed content attribute updates.
  failedUpdates: [MultiviewContentAttribute!]!
  # Processed content attribute updates.
  succeededUpdates: [MultiviewContentAttribute!]!
}

# Used for mutating onboarding status.
input UpdateOnboardingSkippedChannelsInput {
  # List of channels the user skips during the onboarding process.
  channelIDs: [ID!]!
  # ID for the user to update.
  userID: ID!
}

# Returned after onboarding state is mutated.
type UpdateOnboardingSkippedChannelsPayload {
  # Current state of the given user.
  user: User
}

# Error that may be returned by the UpdateOrganizationMemberRole mutation.
type UpdateOrganizationMemberRoleError {
  # Type of mutation error.
  code: UpdateOrganizationMemberRoleErrorCode!
}

# UpdateOrganizationMemberRoleErrorCode is the client error type that occurred
# during the UpdateOrganizationMemberRole mutation.
enum UpdateOrganizationMemberRoleErrorCode {
  # The user is not a member of the organization, or the organization does not exist.
  MEMBER_NOT_FOUND
  # The user doesn't meet the requirements to have this role. For example, when trying to assign the
  # "BILLING_MANAGER" role, but the user doesn't have 2FA enabled or completed Extension Monetization Onboarding.
  MEMBER_INELIGIBLE
  # Current user not allowed to update the role.
  # For example, developers can not assign roles, and no one can assign the owner role to another user.
  PERMISSION_DENIED
  # One of the input parameters is malformed. This should not happen when properly using the UI.
  INVALID_ARGUMENT
}

# Inputs to the UpdateOrganizationMemberRole mutation.
input UpdateOrganizationMemberRoleInput {
  # ID of the organization where the user is a member.
  organizationID: ID!
  # New role of the user in the organization.
  role: OrganizationMemberRole!
  # User's Twitch ID.
  userID: ID!
}

# Outputs from the UpdateOrganizationMemberRole mutation.
type UpdateOrganizationMemberRolePayload {
  # Logical error that could be returned by the mutation.
  error: UpdateOrganizationMemberRoleError
  # Updated member with the new role.
  organizationMember: OrganizationMember
}

# UpdateOwnerChanletAttributesInput updates the owner chanlet attributes.
input UpdateOwnerChanletAttributesInput {
  # The ID of the owner chanlet (channel that owns chanlets).
  channelID: ID!
  # Whether the chanlets should return for the viewers.
  isChanletFeatureEnabled: Boolean!
}

# UpdateOwnerChanletAttributesPayload returns the new chanlet that was created.
type UpdateOwnerChanletAttributesPayload {
  # Resulted OwnerChanletAttributes from the update. This is expected to match the input.
  ownerChanletAttributes: OwnerChanletAttributes
}

input UpdatePanelInput {
  description: String
  id: ID!
  imageURL: String
  linkURL: String
  slotID: String
  title: String
}

type UpdatePanelPayload {
  panel: Panel!
}

# Error returned during a invalid user request.
type UpdatePhoneNumberConfirmationError {
  # Error code returned by the backend.
  code: UpdatePhoneNumberConfirmationErrorCode!
  # The localized external error message.
  message: String!
}

# The possible error enums returned while trying to change a users phone number.
enum UpdatePhoneNumberConfirmationErrorCode {
  # The user needs to re-authenticate to perform this operation.
  REAUTH_NEEDED
  # Phone number was not valid.
  INVALID_PHONE_NUMBER
  # The phone number has requested checks on too many verification codes.
  REQUEST_THROTTLED
  # The phone number provided is used for too many Twitch accounts.
  LIMIT_REACHED
  # The one time password provided is invalid.
  INVALID_OTP
  # The one time password provided is missing. A SMS to the phone number will be triggered when this error occurs.
  MISSING_OTP
  # Something unexpected occured.
  UNKNOWN_ERROR
}

# The required input for a updatePhoneNumberConfirmation mutation.
input UpdatePhoneNumberConfirmationInput {
  # The one time password required to complete phone number registration. This can
  # only be generated from the UpdatePhoneNumber mutation.
  oneTimePassword: String!
  # The phone number being added to a twitch user profile.
  phoneNumber: String!
  # The ID of the user that is requesting to add or modify their phone number.
  userID: ID!
}

# The result of a updatePhoneNumberConfirmationPayload mutation.
type UpdatePhoneNumberConfirmationPayload {
  # error code and localized error.
  error: UpdatePhoneNumberConfirmationError
}

# Error returned during a invalid user request.
type UpdatePhoneNumberError {
  # Error code returned by the backend.
  code: UpdatePhoneNumberErrorCode!
  # The localized external error message.
  message: String!
}

# The possible error enums returned while trying to change a users phone number.
enum UpdatePhoneNumberErrorCode {
  # The user needs to re-authenticate to perform this operation.
  REAUTH_NEEDED
  # Phone number was not valid.
  INVALID_PHONE_NUMBER
  # The phone number has requested too many verification codes.
  REQUEST_THROTTLED
  # The phone number provided is used for too many Twitch accounts.
  LIMIT_REACHED
  # Something unexpected occured.
  UNKNOWN_ERROR
}

# The required input for a updatePhoneNumber mutation.
input UpdatePhoneNumberInput {
  # The phone number being added to a twitch user profile.
  phoneNumber: String!
  # The ID of the user that is requesting to add or modify their phone number.
  userID: ID!
}

# The result of a updatePhoneNumberPayload mutation.
type UpdatePhoneNumberPayload {
  # error code and localized error.
  error: UpdatePhoneNumberError
}

# Error code for an error that occurs while updating prime offer status.
type UpdatePrimeOfferStatusError {
  # Error code for error that occurred while updating prime offer status.
  code: UpdatePrimeOfferStatusErrorCode!
}

# Error types recognized.
enum UpdatePrimeOfferStatusErrorCode {
  # Status when the offers fail to be updated.
  OFFERS_FAILED_TO_UPDATE
  # Unknown error being returned from service.
  UNKNOWN
}

# The offer id you wish to update as well as the status for the update.
input UpdatePrimeOfferStatusInput {
  # The list of offers and statuses to update.
  statusChanges: [OfferAndStatus!]!
  # The user to update the offer statuses for.
  userID: ID!
}

# The returned value for an update prime offer status query.
type UpdatePrimeOfferStatusPayload {
  # The possible error returned from the service.
  error: UpdatePrimeOfferStatusError
  # The connection for the status of the offer for the user.
  self: [PrimeOfferSelfConnection!]!
}

# UpdatePrimeSettingsInput contains boolean for setting the users preference on chat notifications,
# and the users preference on the emoticon set name to be selected.
input UpdatePrimeSettingsInput {
  # The Prime Emoticons Set Name for Prime Emoticons Smilies.
  primeEmoticonsSetName: PrimeEmoticonsSetName
  # True or False for whether the user wants notifications enabled.
  shouldEnableSubCreditChatNotification: Boolean
  # The ID of the user who's settings are being updated.
  userID: ID!
}

# Data that was mutated.
type UpdatePrimeSettingsPayload {
  # The mutated PrimeSettings.
  primeSettings: PrimeSettings
}

# UpdateRaidSettingsInput update a user's raid settings.
input UpdateRaidSettingsInput {
  # Determines what other channels can raid this channel.
  incomingRaidsPolicy: IncomingRaidsPolicy
  # UserID to update settings for.
  userID: ID!
}

# UpdateRaidSettingsPayload returns the user whose settings had been updated.
type UpdateRaidSettingsPayload {
  # User whose raid settings has been updated.
  user: User
}

type UpdateRoomError {
  code: UpdateRoomErrorCode!
  # On NAME_LENGTH_INVALID, TOPIC_LENGTH_INVALID: Maximum number of characters.
  maxLength: Int
  # On NAME_LENGTH_INVALID, TOPIC_LENGTH_INVALID: Minimum number of characters.
  minLength: Int
}

enum UpdateRoomErrorCode {
  # User does not have permission to update room.
  FORBIDDEN
  # Could not find a room with the given room ID.
  ROOM_NOT_FOUND
  # Name too short or too long.
  NAME_LENGTH_INVALID
  # Name contains invalid characters (e.g. spaces).
  NAME_CONTAINS_INVALID_CHARACTERS
  # Name failed automod check.
  NAME_INAPPROPRIATE
  # Name was not unique to channel.
  NAME_NOT_UNIQUE
  # Topic too short or too long.
  TOPIC_LENGTH_INVALID
  # Topic failed automod check.
  TOPIC_INAPPROPRIATE
  # Invalid roles specified (e.g. a more permissive role for send than read).
  ROLES_INVALID
}

input UpdateRoomInput {
  # Deprecated. Use minimumReadMessagesRole instead.
  isPreviewable: Boolean
  # Deprecated. Use minimumReadMessagesRole and minimumSendMessagesRole instead.
  minimumAllowedRole: RoomRole
  # Minimum role required to read messages in the room.
  minimumReadMessagesRole: RoomRole
  # Minimum role required to send messages in the room.
  minimumSendMessagesRole: RoomRole
  name: String
  roomID: ID!
  topic: String
}

type UpdateRoomModesError {
  code: UpdateRoomModesErrorCode!
  # On SLOW_MODE_DURATION_INVALID: Maximum number of seconds slow mode can be set to.
  maximumSlowModeDurationSeconds: Int
  # On SLOW_MODE_DURATION_INVALID: Minimum number of seconds slow mode can be set to.
  minimumSlowModeDurationSeconds: Int
}

enum UpdateRoomModesErrorCode {
  # RoomID referred to an invalid or the user does not have permissions to see the room.
  ROOM_NOT_FOUND
  # User did not have permission to update room modes.
  FORBIDDEN
  # Slow mode duration was too short, too long, or not a number.
  SLOW_MODE_DURATION_INVALID
}

input UpdateRoomModesInput {
  # Turns emotes only mode on or off.
  enableEmotesOnlyMode: Boolean
  # Turns r9k mode on or off.
  enableR9KMode: Boolean
  # Turns slow mode on or off.
  enableSlowMode: Boolean
  roomID: ID!
  # If slow mode enabled, the number of seconds users must wait between messages.
  slowModeDurationSeconds: Int
}

type UpdateRoomModesPayload {
  error: UpdateRoomModesError
  room: Room
}

type UpdateRoomPayload {
  error: UpdateRoomError
  room: Room
}

input UpdateRoomViewInput {
  isArchived: Boolean
  isMuted: Boolean
  lastReadAt: Time
  roomID: ID!
}

type UpdateRoomViewPayload {
  roomView: RoomView
}

# UpdateScheduleSegmentError is a wrapper for error associated with the UpdateScheduleSegment mutation.
type UpdateScheduleSegmentError {
  # Error code.
  code: UpdateScheduleSegmentErrorCode!
  # If the error is related to overlapping segments, provide the existing segment causing a conflict.
  conflictingSegment: ScheduleSegment
  # If the error is related to an input out of service-defined bounds, provide the maximum allowed value.
  maximum: Int
  # If the error is related to an input out of service-defined bounds, provide the miniimum allowed value.
  minimum: Int
}

# The possible error returned.
enum UpdateScheduleSegmentErrorCode {
  # Not authorized to update this segment.
  PERMISSION_DENIED
  # The number of categories is invalid. Refer to the error for min and max acceptable values.
  INVALID_CATEGORY_COUNT
  # The specified segment could not be found.
  NOT_FOUND
  # No update was made because no updated attributes were provided.
  NO_UPDATED_ATTRIBUTES_PROVIDED
  # No update was made because the update would cause a segment overlap.
  OVERLAPPING_SEGMENTS
  # The title length is invalid. Refer to the error for min and max acceptable values.
  INVALID_TITLE
  # The title failed the moderation check.
  TITLE_FAILED_MODERATION
  # The timezone is not valid.
  INVALID_TIMEZONE
  # The categories are not valid.
  INVALID_CATEGORIES
  # The segment start day is invalid.
  INVALID_START_DAY
  # The segment start hour is invalid.
  INVALID_START_HOUR
  # The segment start minute is invalid.
  INVALID_START_MINUTE
  # The duration is invalid. Refer to the error for min and max acceptable values.
  INVALID_DURATION
  # The segment is invalid.
  INVALID_SEGMENT
  # The input is not valid.
  INVALID_ARGUMENT
  # The segment first occurrence date is set in the past.
  FIRST_OCCURRENCE_DATE_IN_PAST
  # Cannot set the first occurrence date on an infinitely recurring segment.
  FIRST_OCCURRENCE_DATE_ON_RECURRING_SEGMENT
  # The segment has already started and can't be edited.
  ALREADY_STARTED
}

# The input to update a schedule segment.
input UpdateScheduleSegmentInput {
  # The categories of the segment.
  categories: [ID!]
  # The duration of the segment in minutes.
  durationMinutes: Int
  # The start date and time of the first occurrence of the segment.
  firstOccurrenceDate: Time
  # Whether the segment is cancelled.
  isCancelled: Boolean
  # The schedule id.
  scheduleID: ID!
  # The segment id to update.
  segmentID: ID!
  # The start time of the segment.
  start: SegmentStartTimeInput
  # The geographic timezone of the segment.
  timezone: String
  # The title of the segment.
  title: String
}

# The returned payload when updating a schedule segment.
type UpdateScheduleSegmentPayload {
  # The possible error returned.
  error: UpdateScheduleSegmentError
  # The updated schedule with the updated segment.
  schedule: Schedule
}

# Updates the list of streamer onboarding content that a user has seen.
input UpdateSeenCreatorOnboardingContentInput {
  # A list of content IDs that should be marked as seen.
  onboardingContentIDs: [ID!]!
  # UserID for the user to update seen content.
  userID: ID!
}

# The result of an UpdateSeenCreatorOnboardingContent mutation.
type UpdateSeenCreatorOnboardingContentPayload {
  # The user who viewed onboarding content.
  user: User
}

# UpdateSocialMediaError is a user error while creating a social media.
enum UpdateSocialMediaError {
  # The title failed moderation.
  FAILED_TITLE_MODERATION
  # The provided title was too long.
  TITLE_TOO_LONG
  # The provided url is invalid.
  INVALID_URL
  # The social medias does not exist.
  NOT_FOUND
}

# UpdateSocialMediaInput updates existing a social media item under the given channelID.
input UpdateSocialMediaInput {
  # The unique channel identifier.
  channelID: ID!
  # The unique indentifier of the social media item.
  id: ID!
  # The visible text of the social media item.
  title: String
  # The web address of the social media item.
  url: String
}

# UpdateSocialMediaPayload returns the updated social media.
type UpdateSocialMediaPayload {
  # The social media channel that was updated.
  channel: Channel
  # The potential error when updating a social media.
  error: UpdateSocialMediaError
}

# UpdateSquadInvitePolicyError is the error associated with an updateSquadInvitePolicy.
type UpdateSquadInvitePolicyError {
  # The associated error code.
  code: UpdateSquadInvitePolicyErrorCode!
}

# UpdateSquadInvitePolicyErrorCode are the possible errors that this mutation returns.
enum UpdateSquadInvitePolicyErrorCode {
  # The caller is not authorized to update the user's squad invite policy.
  UNAUTHORIZED
}

# The required input for an updateSquadInvitePolicy mutation.
input UpdateSquadInvitePolicyInput {
  # The new invite policy that will replace what is currently set for the user.
  incomingInvitePolicy: SquadStreamIncomingInvitePolicy!
  # The ID corresponding to the user whose invite policy should be updated.
  userID: ID!
}

# Returns after the invite policy is mutated.
type UpdateSquadInvitePolicyPayload {
  # The possible error returned from the service.
  error: UpdateSquadInvitePolicyError
  # The modified user.
  user: User
}

# UpdateSquadStreamError is the error associated with a updateSquadStream.
type UpdateSquadStreamError {
  # The associated error code.
  code: UpdateSquadStreamErrorCode!
}

# UpdateSquadStreamErrorCode are the possible errors that this mutation returns.
enum UpdateSquadStreamErrorCode {
  # The squad is not found.
  SQUAD_NOT_FOUND
  # The squad cannot be updated (e.g. squad is not in pending status).
  SQUAD_CANNOT_BE_UPDATED
  # The squad has too few members to be updated to live.
  SQUAD_TOO_FEW_MEMBERS
  # The user is not authorized to update the squad.
  UNAUTHORIZED
}

# Inputs to the updateSquadStream mutation.
input UpdateSquadStreamInput {
  # The ID of the squad stream to be updated.
  squadStreamID: ID!
  # If specified, the new status of the squad stream.
  status: SquadStreamStatus
}

# Outputs from the updateSquadStream mutation.
type UpdateSquadStreamPayload {
  # The possible error returned from the service.
  error: UpdateSquadStreamError
  # The updated squad stream.
  squadStream: SquadStream
}

# Inputs to updating a stucco.
input UpdateStuccoInput {
  # ID of the channel this stucco belongs to.
  channelID: ID!
  # Description representing the stucco, should be the words contained in the stucco, used by screen readers.
  description: String!
  # Base64 encoded binary data of the 92x28px stucco ("1x") image asset.
  imageData1x: String!
  # Base64 encoded binary data of the 182x56px stucco ("2x") image asset.
  imageData2x: String!
  # Base64 encoded binary data of the 368x112px stucco ("4x") image asset.
  imageData4x: String!
  # Unique ID of the stucco to update.
  stuccoID: ID!
  # Text code representing the stucco without any prefixes (prefixes are added in the backend).
  suffix: String!
}

# Inputs for updating a stucco pack (exchanging stuccos contained in the pack).
input UpdateStuccoPackInput {
  # Id of the channel this pack is part of.
  channelID: ID!
  # Id of the stucco pack to update.
  stuccoPackID: ID!
  # Updated list of stuccos for this pack.
  stuccos: [UpdateStuccoPackItemInput!]
}

# Single item in a stuccopack, as part of the update stucco pack call, representing one stucco to be used in a certain slot.
input UpdateStuccoPackItemInput {
  # Slot index in the pack (used for ordering).
  slotIndex: Int!
  # Id of the stucco.
  stuccoID: ID!
}

# Outputs from the update stucco pack mutation.
type UpdateStuccoPackPayload {
  # The updated stucco pack.
  stuccoPack: StuccoPack
}

# The output for the update stucco mutation.
type UpdateStuccoPayload {
  # The updated stucco.
  stucco: Stucco
}

# Inputs to the updateSubscriptionProduct mutation.
input UpdateSubscriptionProductInput {
  # Name of the product.
  displayName: String
  # Toggle to enable add free viewing.
  hasAdFree: Boolean
  # Toggle to enable fast chat (or disable slow mode).
  hasFastChat: Boolean
  # Toggle to enable sub only chat.
  hasSubOnlyChat: Boolean
  # Toggle to enable sub only video.
  hasSubOnlyVideoArchive: Boolean
  # The id of the subscription product.
  id: ID!
  # User the update belongs to.
  targetUserID: ID!
}

# Output from the updateSubscriptionProduct mutation.
type UpdateSubscriptionProductPayload {
  # Subscription product output.
  product: SubscriptionProduct
  # User/channel to update the subscription product.
  targetUser: User
}

# The possible error returned.
type UpdateUserColorsError {
  # The error code.
  code: UpdateUserColorsErrorCode!
}

# The possible types of error codes returned.
enum UpdateUserColorsErrorCode {
  # Hex string is invalid.
  INVALID_HEX_COLOR
}

# The required input for a UpdateUserColorsInput mutation.
input UpdateUserColorsInput {
  # The user's primary color hex string (e.g. "FFFFFF").
  primaryColorHex: String!
  # The ID of the user whose creator colors are being updated.
  userID: ID!
}

# The result of a UpdateUserColorsInput mutation.
type UpdateUserColorsPayload {
  # The possible error returned.
  error: UpdateUserColorsError
  # The modified user.
  user: User
}

# The required input for a updateUserCreateDateHidden mutation.
input UpdateUserCreateDateHiddenInput {
  # The hide create date boolean to set onto the user.
  isCreateDateHidden: Boolean!
  # The ID of the user whose privacy setting is being updated.
  userID: ID!
}

# The result of a updateUserCreateDateHidden mutation.
type UpdateUserCreateDateHiddenPayload {
  # The modified user.
  user: User
}

# The required input for a updateUserDirectoryHidden mutation.
input UpdateUserDirectoryHiddenInput {
  # The directory hidden boolean to set onto the user.
  IsDirectoryHidden: Boolean!
}

# The result of a updateUserDirectoryHidden mutation.
type UpdateUserDirectoryHiddenPayload {
  # The modified user.
  user: User
}

# The required input for a updateUserEmailReuseable mutation.
input UpdateUserEmailReusableInput {
  # The email reusable boolean to set onto the user.
  IsEmailReusable: Boolean!
  # The ID of the user whose broadcast setting is being updated.
  userID: ID!
}

# The result of a updateUserEmailReuseable mutation.
type UpdateUserEmailReusablePayload {
  # The modified user.
  user: User
}

# The possible error returned.
type UpdateUserError {
  # The error code.
  code: UpdateUserErrorCode!
}

# The possible error codes returned from updating a user.
enum UpdateUserErrorCode {
  # User is not authorized to update this user.
  AUTH_FAILURE
  # Too many attempts to update user.
  REQUESTS_THROTTLED
  # User cannot be found.
  USER_NOT_FOUND
  # Sudo token expired, prompt the user to log in again.
  REAUTH_NEEDED
  # Display name not available.
  DISPLAY_NAME_NOT_AVAILABLE
  # Display name is too short.
  DISPLAY_NAME_TOO_SHORT
  # Display name is too long.
  DISPLAY_NAME_TOO_LONG
  # Display name contains invalid characters.
  INVALID_CHARS_IN_DISPLAY_NAME
  # User is not allowed to change their display name again.
  DISPLAY_NAME_CHANGE_AGAIN
  # User can only change the capitalization of their display name.
  DISPLAY_NAME_ONLY_CAP
  # Unexpected error during displayname override.
  DISPLAY_NAME_UNEXPECTED_ERR
  # The login you selected is not available.
  LOGIN_NOT_AVAILABLE
  # The login you selected is not yet available for re-use.
  LOGIN_BLOCKED
  # Login change rate limited.
  NOT_ALLOWED_TO_CHANGE_LOGIN
  # The login you selected is too short.
  LOGIN_TOO_SHORT
  # The login you selected is too long.
  LOGIN_TOO_LONG
  # The login you selected contains invalid characters.
  INVALID_CHARS_IN_LOGIN
  # Login contains banned words.
  LOGIN_USE_BANNED_WORDS
  # Login contains variations on banned words.
  LOGIN_USE_VARIATION_ON_BANNED_WORDS
  # User exists but was excluded by filter criteria.
  FILTERED_USER_REQUESTED
  # The IP is blocked.
  IP_BLOCKED
  # Too many users associated with the email.
  TOO_MANY_USERS_FOR_EMAIL
  # Email disabled for reuse.
  EMAIL_DISABLED_FOR_REUSE
  # Email address is not valid.
  INVALID_EMAIL
  # Admins must use their work email.
  WORK_EMAIL_REQUIRED
  # Email address uses an invalid domain.
  INVALID_EMAIL_DOMAIN
  # Email change cooldown.
  NOT_ALLOWED_TO_CHANGE_EMAIL
  # Phone number is invalid.
  PHONE_NUMBER_INVALID
  # Phone number cannot contain letters.
  PHONE_NUMBER_HAS_LETTERS
  # Description contains banned words.
  DESCRIPTION_FAILED_MODERATION
  # Description field is too long.
  DESCRIPTION_TOO_LONG
  # No properties found for this user identifier.
  NO_PROPERTIES
  # Reservation does not exist in db.
  RESERVATION_NOT_EXITS
  # The specified locale is invalid.
  LANGUAGE_NOT_VALID
  # Age cannot be under 13 years.
  INVALID_BIRTHDAY
  # Last Login doesn't follow format "%Y-%m-%d %H:%M:%S".
  INVALID_LAST_LOGIN
  # Phone number or email update cannot be combined with delete pohone number.
  INVALID_PARAMETER_COMBINATION
  # Phone number can only be removed for an account with a verifed email.
  NOT_ALLOWED_TO_DELETE_PHONE_NUMBER
  # Phone number already exists.
  PHONE_NUMBER_ALREADY_EXISTS
  # Hex color is not valid.
  INVALID_HEX_COLOR
  # Unknown error.
  UNKNOWN
}

# The required input for a UpdateUser mutation.
input UpdateUserInput {
  # If true the phone number associated with this user will be deleted.
  deletePhoneNumber: Boolean
  # The user's personal description.
  description: String
  # The user's display name.
  displayName: String
  # The user's personal email.
  email: String
  # Whether or not to send a mobile verification code if email verification is required.
  includeVerificationCode: Boolean
  # User id of the user being updated.
  userID: ID!
}

# The required input for a updateUserIsEmailRevertSuccess mutation.
input UpdateUserIsEmailRevertSuccessInput {
  # The show email revert success msg boolean to set onto the user.
  isEmailRevertSuccess: Boolean!
  # The ID of the user whose email revert success flag is being updated.
  userID: ID!
}

# The result of a updateUserIsEmailRevertSuccess mutation.
type UpdateUserIsEmailRevertSuccessPayload {
  # The modified user.
  user: User
}

# The result of an updateUser mutation.
type UpdateUserPayload {
  # The possible error returned.
  error: UpdateUserError
  # The modified user.
  user: User
}

# An error returned from the updateUserPredictionSettings mutation.
type UpdateUserPredictionSettingsError {
  # Code describing the error.
  code: UpdateUserPredictionSettingsErrorCode!
}

# Possible error codes from the updateUserPredictionSettings mutation.
enum UpdateUserPredictionSettingsErrorCode {
  # An unknown error occurred.
  UNKNOWN
}

# Update the current authorized user's Prediction Settings.
# All fields are nullable; only specify fields that you wish to update.
input UpdateUserPredictionSettingsInput {
  # Whether the user has accepted the latest Predictions Terms of Service.
  hasAcceptedTOS: Boolean
  # Whether the user has opted to display a temporary chat badge indicating their choices during Predictions Events.
  isTemporaryChatBadgeEnabled: Boolean
}

# Payload for updating a user's Prediction Settings.
type UpdateUserPredictionSettingsPayload {
  # If present, there was an error with the request.
  error: UpdateUserPredictionSettingsError
  # The updated settings.
  settings: UserPredictionSettings
}

# UpdateUserSubscriptionSettingsInput updates the users subscription settings.
input UpdateUserSubscriptionSettingsInput {
  # Whether the user only wants to receive gifts to channels they follow.
  giftsInFollowedChannelsOnly: Boolean
  # Whether the user wants to hide Badge Modifiers.
  isBadgeModifierHidden: Boolean
  # If the user wants to hide their Founder Badges.
  isFounderBadgesHidden: Boolean
  # Whether the user wants to show how many gifts they've purchased.
  isGiftCountHidden: Boolean
  # Whether the user wants to show their subscription tenure and status in the chat viewer card.
  isSubscriptionStatusHidden: Boolean
}

# UpdateUserSubscriptionGiftSettingsPayload returns the user's current gift settings.
type UpdateUserSubscriptionSettingsPayload {
  subscriptionSettings: UserSubscriptionSettings
}

# Inputs to the updateUserTeamMembership mutation.
input UpdateUserTeamMembershipInput {
  # Whether or not the team should be the user's primary team.
  # Note only True values are effective here. A user must always have one and only
  # one primary team, and setting false would break that invariant.
  # Setting a team as Primary will make all of a user's other team memberships non-primary.
  primary: Boolean
  # Whether or not the membership should reveal its revenue.
  revenueRevealed: Boolean!
  # Whether or not the membership should reveal its stats.
  statsRevealed: Boolean!
  # The team which the membership belongs to.
  teamID: ID!
  # The user whose membership is being modified.
  userID: ID!
}

# Output from the updateUserTeamMembership mutation.
type UpdateUserTeamMembershipPayload {
  # The user whose membership was modified.
  user: User
}

# Error information in the update user video shelves response.
type UpdateUserVideoShelvesError {
  # An http error code to identify the error response.
  code: Int!
  # The translated error response message for this given error.
  message: String
}

# Input information for updating a user's video shelves. Video shelves are
# added/removed and reordered based on the provided shelfOptions.
input UpdateUserVideoShelvesInput {
  # Channel for which to update shelves.
  channelID: ID!
  # A list of different shelf options to populate the user's video shelves.
  shelfOptions: [ShelvesAvailableOptions!]!
}

# Response to a request to update a user's video shelves.
type UpdateUserVideoShelvesPayload {
  # The error response for this update request.
  error: UpdateUserVideoShelvesError
  # The list of shelves for this user.
  shelves: [VideoShelf]
}

# Input information for updating a resume watching entry for a specified user and video.
input UpdateUserViewedVideoInput {
  # Position for where in the video to update for the resume watching entry.
  position: Int!
  # User for which to update the resume watching entry.
  userID: ID!
  # Video for which to update the resume watching entry.
  videoID: ID!
  # Type of the video for which to update the resume watching entry.
  videoType: VideoType!
}

# Response to a request to update a resume watching entry for a specified user and video.
type UpdateUserViewedVideoPayload {
  # The video returned from the request.
  video: Video
}

input UpdateVideoCommentInput {
  # ID of the comment being updated.
  commentID: ID!
  # The state of the comment.
  state: VideoCommentState!
}

type UpdateVideoCommentPayload {
  # The comment that was updated.
  comment: VideoComment!
}

# Input information for updating a video.
input UpdateVideoInput {
  # The description of the video.
  description: String
  # The name of the game presented in the video.
  game: String
  # The language of the video.
  language: String
  # Determines viewability of the video; PUBLIC or PRIVATE.
  scope: VideoPrivacyScope
  # The thumbnail URL of the video.
  thumbnailPath: String
  # The title of the video.
  title: String
  # ID of the video being updated.
  videoID: ID!
}

# Response to a request to update a video.
type UpdateVideoPayload {
  # The video with updated fields.
  video: Video
}

# Error that may be returned by the UpdateVideoStreamSettings mutation.
type UpdateVideoStreamSettingsError {
  # Type of mutation error.
  code: UpdateVideoStreamSettingsErrorCode!
}

# UpdateVideoStreamSettingsErrorCode is the client error type that occurred during the UpdateVideoStreamSettings mutation.
enum UpdateVideoStreamSettingsErrorCode {
  # The broadcaster is not found.
  CHANNEL_NOT_FOUND
  # Permission denied to add an authorized user.
  PERMISSION_DENIED
  # Invalid argument to add an authorized user.
  INVALID_ARGUMENT
}

# UpdateVideoStreamSettingsInput updates the broadcaster's stream settings such as stream delay length seconds or stream key.
input UpdateVideoStreamSettingsInput {
  # ChannelID of the broadcaster. This has to be same as authenticated user's userID.
  channelID: ID!
  # The number of seconds delay for a stream. When this is set, a stream will be
  # ingested with specified delay in seconds. Maximum is set to 900 seconds.
  delaySeconds: Int
  # Whether or not a stream should be started as a low latency stream.
  isLowLatency: Boolean
  # Whether or not the broadcaster prefers to archive the vod for a stream.
  shouldArchiveVODs: Boolean
  # Whether or not to show the disconnect slate.
  shouldShowDisconnectSlate: Boolean
}

# UpdateVideoStreamSettingsPayload returns the updated video stream settings for the broadcaster.
type UpdateVideoStreamSettingsPayload {
  # The updated Channel for the broadcaster.
  channel: Channel
  # Error code.
  error: UpdateVideoStreamSettingsError
}

# Error associated with mutation UpdateVideosViewability.
type UpdateVideosViewabilityError {
  # Error code.
  code: UpdateVideosViewabilityErrorCode!
}

# Client error code.
enum UpdateVideosViewabilityErrorCode {
  # Internal error.
  INTERNAL_ERROR
  # The request body was invalid.
  BAD_REQUEST
  # Permission Denied.
  PERMISSION_DENIED
  # Unknown error.
  UNKNOWN
}

# Inputs for the updating videos by id mutation.
input UpdateVideosViewabilityInput {
  # Determines viewability of the videos; PUBLIC or PRIVATE.
  scope: VideoPrivacyScope
  # The IDs of the videos to be updated.
  videoIDs: [ID!]!
}

# The returned payload from the DeleteVideos mutation.
type UpdateVideosViewabilityPayload {
  # The possible error returned from service.
  error: UpdateVideosViewabilityError
}

# The change that will be applied to the user's visibility. See VisibilityInput for details on the effects of each
# value.
input UpdateVisibilityInput {
  visibility: VisibilityInput!
}

type UpdateVisibilityPayload {
  # The modified user.
  user: User
}

# The request to the UpdateWhisperSettings mutation.
input UpdateWhisperSettingsInput {
  # Whether to disallow strangers from iniating a whisper thread to this user.
  isBlockingWhispersFromStrangers: Boolean
}

# The response from the UpdateWhisperSettings mutation.
type UpdateWhisperSettingsPayload {
  # The user whose whisper settings were updated.
  user: User
}

input UpdateWhisperThreadInput {
  # Whether to archive the room.
  isArchived: Boolean
  # Whether to mute the room.
  isMuted: Boolean
  # Whether to mark the message as spam.
  isSpam: Boolean
  # ID of last message read by the user.
  lastReadMessageID: ID
  # Whether to revoke temporary send Whisper permission from the other user.
  removeWhitelist: Boolean
  # ID of thread to be marked as read.
  threadID: ID!
}

type UpdateWhisperThreadPayload {
  # Thread that was updated.
  thread: WhisperThread!
}

# Generates an image URL to upload to.
input UploadCompetitionImageInput {
  # Unique Competition ID.
  competitionID: ID!
  # Type of image being uploaded.
  imageType: CompetitionImageType!
}

# Data required to upload an image to the competition.
type UploadCompetitionImagePayload {
  # Used for upload competition image errors.
  error: CompetitionUploadImageError
  # The metadata required to access an image for a competition.
  image: CompetitionImageUpload
}

# Individual upload config.
type UploadConfig {
  # Upload id used when listening to pubsub.
  ID: ID!
  # URL to upload images to.
  URL: String!
  # The type of asset of the emote image that should be uploaded.
  assetType: EmoteAssetType!
  # Images that will result out of the upload.
  images: [UploadImage!]!
  # Size of the image that should be uploaded.
  size: EmoteImageSize!
}

type UploadImage {
  # Image ID generated by Mako for image.
  ID: ID!
  # Size of the image.
  Size: EmoteImageSize!
  # The asset type of the image.
  assetType: EmoteAssetType!
}

# The url metadata of a twitch webpage.
type URLMetadata {
  # The linked data (JSON format) of the page.
  jsonld: String
  # The list of metatags of the page.
  metatags: [SEOMetatag!]!
  # The data that power URL sharing.
  share: URLMetadataShare!
  # The title of the page.
  title: String!
}

# The data that power URL sharing.
type URLMetadataShare {
  # The text to share.
  text: String!
  # The title to share.
  title: String!
  # The url to share.
  url: String!
}

# UseChatNotificationTokenInput is the input required for the UseChatNotificationToken mutation.
input UseChatNotificationTokenInput {
  # The channel that this token will be used on.
  channelLogin: String!
  # Whether or not to include user's streak tenure.
  includeStreak: Boolean!
  # An optional message that will be displayed when this chat token is used.
  message: String
  # An optional ID of token to be used.
  tokenID: ID
}

# UseChatNotificationTokenPayload is the return of the UseChatNotificationToken mutation.
type UseChatNotificationTokenPayload {
  # If the token was successfully used.
  isSuccess: Boolean!
}

# Twitch user.
type User {
  # Information about a user's connected accounts.
  accountConnections: AccountConnectionSet!
  # Information about a user's account health status.
  accountHealth: UserAccountHealth
  # Fetch active challenges for the user based on a variety of sorting options.
  # By default returns 10 challenges, sorted by start time.
  activeChallenges(
    first: Int = 10
    after: Cursor
    sort: ChannelChallengeSort = START_TIME
    direction: SortOrder = DESC
  ): ChannelChallengeConnection
  # An action that a user or session is performing. This field is null if the user is not friends with
  # the authenticated user.
  activity: Activity
  # Ad Properties for the given user.
  adProperties: AdProperties
  # The user's relationship with Amazon.
  amazon: UserAmazonConnection @deprecated(reason: "Retail sales discontinued")
  # List of authenticated Twitch sessions.
  authenticatedSessionList: [AuthenticatedSession!]
  # AutoModProperties is a mapping of automod categories to levels, i.e. a user has indicated they want level 4, or
  # the highest level of moderation for profanity, but level 1 for everything
  # else. (These are based on Sift levels, and will be deprecated).
  autoModProperties: AutoModProperties
  # A user's configured auto refill information, contains all auto refill profiles.
  # Will have an optional filter argument in the future.
  autoRefill: AutoRefill
  # The list of channels that this user has configured to automatically host
  # when their channel is not streaming live. Users can only view their own
  # autohost channels.
  autohostChannels: AutohostChannelConnection
  # Options and preferences for autohost behavior, including whether
  # autohosting is enabled at all and how to choose which channel to host.
  # Users can only view their own autohost settings.
  autohostSettings: AutohostSettings
  # The list of channels that have added this user as a channel to automatically host when their channel is not
  # streaming live. Users can only view their own autohosted by channels.
  autohostedByChannels: AutohostedByChannelConnection
    @deprecated(reason: "This functionality has been removed")
  # An action that a user or session is performing. This field is null if the user is not friends with
  # the authenticated user.
  availability: Availability
  # The badges which are available for the authenticated user to select for use on
  # another user's streams and videos if no channel-specific preference is set.
  # If no domain is not specified, all emote sets will be returned.
  # This is only returned if the request is authenticated by the same user whose email is requested.
  availableBadges(domains: [BadgeDomain!]): [Badge]
  # A list of this user's balances in FIAT currencies
  # If this isn't the `currentUser` this will return null.
  balances(walletType: WalletType): [Balance]
    @deprecated(reason: "Use walletBalances")
  # A list of this user's banned users.
  # A maximum of 100 users by most recent are returned
  # Only resolves for the authenticated user.
  bannedUsers: [ChannelBannedUser!]
  # A URL to the user's banner image.
  bannerImageURL: String
  # bitsBalance is the number of bits this user currently has available to spend.
  # If this isn't the `currentUser` or the user has been banned from using bits this will return null.
  # This field can only be requested if an OAuth token is supplied with the request.
  bitsBalance: Int
  # bitsEvents returns a paginated list of this user's bits usage transactions
  # If this isn't the `currentUser` this will return null.
  # This field can only be requested if an OAuth token is supplied with the request.
  bitsEvents(
    first: Int = 50
    after: Cursor
    criteria: BitsEventConnectionCriteriaInput!
  ): BitsEventConnection
  # bitsOffers is a list of the ways this user can obtain more bits.
  # If this isn't the `currentUser` or the user has been banned from using bits this will return null.
  # This field can only be requested if an OAuth token is supplied with the request.
  bitsOffers: [BitsOffer]
  # BitsPaymentMethods has a list of eligible payment methods for a user to transact with.
  bitsPaymentMethods: BitsPaymentMethods
  # BitsProductEligibility checks for a given user if they are eligible to purchase a given product from the associated
  # provider, quantity, and locale.
  # bitsProduct(id: ID!, provider: BitsProductProvider!, quantity: Int!, locale: String!): BitsProductEligibility!
  # bitsProducts is a list of bits products that a user is able to purchase.
  # Unlike bitsOffers, this does not return any pricing information, only information
  # about the purchasable. A provider must be supplied, which is the payment platform
  # being currently used. An optional list of SKUs can be provided if we are looking up
  # a specific set of products for a user.
  bitsProducts(
    provider: BitsProductProvider!
    skus: [String!]
    paymentProvider: PaymentProvider
  ): [BitsProduct!]
  # Settings tied to a bits user.
  bitsUserSettings: BitsUserSettings
  # bitsUserState dictates the state of the Bits user (new to Bits, existing Bits user, etc.)
  # If this isn't the `currentUser` or the user has been banned from using bits this will return null.
  # This field can only be requested if an OAuth token is supplied with the request.
  bitsUserState: BitsUserState
  # Resolves account information that Twitch has stored for a user's blizzard account information.
  blizzardAccount: BlizzardUser
  # Get the blocked terms of a user.
  blockedTerms: [ChannelBlockedTerm!]!
    @deprecated(reason: "Use channel.blockedTerms instead")
  # blockedUsers returns a list users that are restrained from directly communicating with this user.
  blockedUsers: [User]!
  # bounties is a list of bounty board bounties for this user.
  bounties(status: String!): [Bounty!]
    @deprecated(reason: "Use user.bountiesPage instead")
  # bountiesPage is a paginated list of bounty board bounties for this user.
  bountiesPage(
    first: Int = 10
    after: Cursor
    status: String!
  ): BountyConnection
  # bountyBoardSettings are settings and rules around the behavior of bounty boards for this user.
  bountyBoardSettings: BountyBoardSettings
  # Badges that are displayed in chat during this user's broacasts or videos.
  broadcastBadges: [Badge]
  # A User's broadcast settings that persists between streams.
  broadcastSettings: BroadcastSettings
  # A User's campaign for their channel.
  campaign(campaignID: ID!): Campaign
    @deprecated(reason: "campaign events have been deprecated")
  # A User's campaign properties for their channel.
  campaignProperties: CampaignProperties
    @deprecated(reason: "campaign events have been deprecated")
  # A container for celebration settings for the logged in user.
  celebrationSettings: CelebrationUserSettings
  # The channel which belongs to the user. This is still deprecated for previous uses.
  # This should only be used for the multi-view experience.
  channel: Channel
  # What other similar content are my viewers watching.
  channelAnalyticsContentOverlap: ChannelAnalyticsContentOverlap
  # A user's channel feed.
  # No authorization required.  Returns even if channel feed is disabled in the UI.
  channelFeed: Feed
  # Returns the list of chatrooms in the channel visible by the current user.
  channelRooms: [Room]! @deprecated(reason: "The Rooms product has been sunset")
  # Hex color of the user's name in chat, e.g. "#ccaa44".
  chatColor: String
  # chatSettings are settings and rules for chatting in this user's channel.
  chatSettings: ChatSettings
  # chatUISettings are settings for the user's chat UI.
  chatUISettings: ChatUISettings
  # cheer is the channel-specific cheer settings and current state.
  # Returns null if cheering isn't enabled for this channel.
  cheer: CheerInfo
  # The list of OAuth clients authorized by the current user.
  clientAuthorizations: [ClientAuthorization!]
  # A paginated list of clips featuring this user.
  # When criteria is not specified, the default values are used.
  clips(
    first: Int = 10
    after: Cursor
    criteria: UserClipsInput
  ): ClipConnection
  # A paginated list of collections (playlists) created by the user.
  collections(
    first: Int = 10
    after: Cursor
    options: CollectionsOptions
  ): CollectionsConnection
  # Properties relating to the authenticated user's community points on twitch.
  communityPoints: CommunityPointsUserProperties
  # The company that the user belongs to.
  # Returns null if the user doesn't belong to a company.
  company: Company @deprecated(reason: "Use organizations instead.")
  # The competitions that a user is involved in.
  # Returns null if the user doesn't have any competitions.
  # user and competition state can be null.
  competitions(
    first: Int = 10
    after: Cursor
    userState: CompetitionPlayerState
    competitionState: CompetitionState
    userCompetitionRelationship: UserCompetitionRelationship!
  ): CompetitionConnection
  # When the user created their account.
  createdAt: Time!
  # The container for creator gifts the creator has. This will be null if the creator
  # does not have this feature enabled.
  creatorGifting: CreatorGifting
  # Creator metrics for the given time period.
  creatorMetricsByInterval(
    startAt: Time!
    endAt: Time!
    timeZone: String
    numberOfIntervals: Int = 1
  ): CreatorMetricsByInterval
  # Get the user's referral links sorted by most recently created first. Will be a
  # null CreatorReferralLinkConnection if the user is not eligible.
  creatorReferralLinks(
    first: Int = 1
    after: Cursor
  ): CreatorReferralLinkConnection
  # Get the user's creator referral link statistics summary.
  creatorReferralSummary(startAt: Time!, endAt: Time!): CreatorReferralSummary!
  # Paginated past activities for the Dashboard Activity Feed.
  # Always ordered by descending timestamp.
  dashboardActivityFeedActivities(
    first: Int = 10
    after: Cursor
  ): DashboardActivityFeedActivityConnection
  # Paginated past activities for the Dashboard Alert Queue.
  # Always ordered by descending timestamp.
  dashboardAlertQueueActivities(
    first: Int = 10
    after: Cursor
  ): DashboardAlertQueueActivityConnection
  # Preferences that control what alerts are sent to the user for the Dashboard Alert Queue.
  dashboardAlertQueuePreferences: DashboardAlertQueuePreferences
  # Timestamp when a user's account was deleted/disabled.
  deletedAt: Time
  # A user-provided blurb describing themselves.
  # Returns null when a description has not been set.
  description: String
  # The directories the user is currently set to broadcast in.
  directories: UserDirectoryConnection
  # Lists the chat badges that should be displayed by the user's display name in
  # features like chat and whispers. If a channelID is passed in, fetches the
  # display badges that user will have in that channel's context.
  # Includes the following badges:
  # - global authority (staff/admin/global mod)
  # - channel authority (broadcaster/mod, if channelID is set)
  # - subscriber (if channelID is set)
  # - channel selected (bits) or global selected (prime, turbo, ...).
  displayBadges(channelID: ID, channelLogin: String): [Badge]!
  # A user-styled version of their login.
  # For international users, this could be the user's login with localized characters.
  displayName: String!
  # Number of DMCA violations user has received.
  dmcaViolationCount: Int
  # A drop 2.0 campaign including personal settings (e.g. account connection status). (Viewer dashboard individual item).
  dropCampaign(id: ID!): DropCampaign
  # A list of all available Drops 2.0 Campaigns that a user is eligible to participate in. (Viewer dashboard list).
  dropCampaigns: [DropCampaign!]
  # Fetch User's current session, which describes the minutes-watched progress towards a drop.
  dropCurrentSession: DropCurrentSession
  # A list of channels where the user is an editor.
  editableChannels: EditableChannelConnection
  # A list of channel editors.
  editors: EditorConnection
  # The user's email address.
  # This is only returned if the request is authenticated by the same user who's email is requested.
  email: String
  # The emote sets this user is entitled to use.
  # If no domains are specified, all emote sets will be returned.
  # If multiple domains are specified, emotes that belong to either domain are returned (OR).
  # If this user is not the current user, it returns nil and a "forbidden" error.
  emoteSets(domains: [EmoteSetDomain!]): [EmoteSet!]
  # The channel's emoticon prefix settings.
  emoticonPrefix: EmoticonPrefix
  # The list channels that have been endorsed by the user.
  endorsedChannels(
    first: Int = 10
    recommendationsContext: RecommendationsContext!
  ): EndorsedChannelConnection
  # A paginated list of user's all expired subscriptions.
  # Only resolves for the current user. Returns a forbidden error if requested for another user.
  expiredSubscriptions(
    first: Int = 10
    after: Cursor
  ): ExpiredSubscriptionConnection
  # Feature flags specific to this user.
  # Always returns nil.
  featureFlags: FeatureFlags
    @deprecated(reason: "this functionality has been removed")
  # A follow relationship between this user and the one which has the target ID or login.
  # Null if no relationship exists.
  follow(targetID: ID, targetLogin: String): Follow
    @deprecated(reason: "Use user.self.follower instead.")
  # Retrieves a list of games which the user is following.
  followedGames(
    first: Int = 10
    type: FollowedGamesType = ALL
  ): FollowedGameConnection
  # A list of broadcasters this user follows, who are hosting other broadcasters.
  # Only resolves for the authenticated user.
  followedHosts(first: Int = 10): FollowedHostConnection
    @deprecated(
      reason: "This field is intended to be replaced as soon as an alternative is available."
    )
  # A list of live-streaming broadcasters this user is following.
  # Only resolves for the authenticated user.
  # NOTE: the sort input parameter is not supported and should not be used.
  followedLiveUsers(
    first: Int = 10
    after: Cursor
    includeRestricted: [StreamRestrictionType!]
    sort: StreamSort = VIEWER_COUNT
  ): FollowedLiveUserConnection
    @deprecated(
      reason: "This field is intended to be replaced as soon as an alternative is available."
    )
  # Retrieves recent/popular VODs from the streamers you follow.
  # If this isn't the `currentUser` this will return null.
  followedVideos(
    first: Int = 10
    after: Cursor
    languages: [String!]
    types: [BroadcastType!]
    sort: VideoSort = TIME
  ): VideoConnection
  # A paginated list of users which follow this user.
  followers(
    first: Int = 10
    after: Cursor
    order: SortOrder = ASC
  ): FollowerConnection
  # A paginated list of users this user is following.
  follows(
    first: Int = 10
    after: Cursor
    filter: FollowsFilter = ALL
    order: SortOrder = ASC
  ): FollowConnection
  # A list of this user's Twitch friends.
  # A maximum of 500 friends are returned, although most users have less than the maximum.
  # Only accessible if the user is authenticated with the `user_presence_friends_read` scope.
  friends: FriendConnection
  # Notification connection information for a time range.
  goLiveNotificationConnection(
    startAt: Time!
    endAt: Time!
    first: Int = 100
    after: Cursor
    sort: SortOrder = DESC
  ): GoLiveNotificationConnection
  # Notification information for a time range.
  goLiveNotifications(
    startAt: Time!
    endAt: Time!
    first: Int = 100
    sort: SortOrder = DESC
  ): [GoLiveNotification!]
  # Notifications timeseries analytics for a time range.
  goLiveNotificationsTimeseries(
    startAt: Time!
    endAt: Time!
    granularity: Granularity!
    numberOfIntervals: Int = 1
    timeZone: String!
  ): [GoLiveNotificationTimeseries!]
  # Always returns false, will be deleted soon.
  hasBadgesTimedOut: Boolean!
    @deprecated(reason: "this functionality has been removed")
  # Whether this user has Twitch Presto.
  hasPresto: Boolean
  # Whether this user has Twitch Prime.
  hasPrime: Boolean!
  # Whether this user has streamed before.
  hasStreamed: Boolean
  # Whether this user has Twitch Turbo.
  hasTurbo: Boolean!
  # Whether this user has unread creator changelog items.
  hasUnreadChangelogItems: Boolean
  # This user's Hero configuration.
  hero: Hero
  # A curated list of suggested channels to host.
  hostRecommendations: [User]
  # The users hosting this user.
  # This field only resolves for the authenticated user, otherwise resolves to null.
  hostedBy(first: Int = 10, after: Cursor): HostConnection
  # The user who this user is hosting.
  hosting: User
  # The user's unique identifier.
  id: ID!
  # Returns a SHA-1 hash of the id field.
  idSHA1: ID!
  # A list of open friend requests sent to this user. Friend requests from non-strangers are always placed in front of
  # friend requests from strangers; `sort` affects how the two components are ordered within themselves. Only accessible
  # if the user is authenticated with the `user_presence_friends_read` scope.
  incomingFriendRequests(
    first: Int = 10
    after: Cursor
    sort: FriendSort = DESC
  ): IncomingFriendRequestConnection
  # A list of the squad stream invitations that the user has received.
  # Each invitation has a network type of either in-network or out-of-network. The invitations are sorted by creation
  # time, with the latest invitation first.
  # This field only resolves for the authenticated user.
  incomingSquadStreamInvitations: SquadStreamInvitationConnection
  # The list of extensions the user has installed.
  # installedExtensions gives a set of Extension installations, but does not include some of the information required
  # to render extensions.  For this, use extensionsForChannel instead, where you will get more accurate response, and
  # which includes fetched extension configuration and extension permissions.
  installedExtensions: [ExtensionInstallation!]
  # Items (crates, drops, etc.) the user owns.
  inventory: Inventory
  # A list of teams that the user has been invited to.
  # Only resolves for the current user.
  invitedTeams: [Team]
  # Whether or not the broadcaster is eligible for payout through twitch game commerce revenue share.
  isCommerceRevShareEnabled: Boolean!
    @deprecated(reason: "Game sales discontinued")
  # Whether the user's Twitch account is connected to a Twitter account.
  # Returns nil if there was an error. This field is only accessible on the current user.
  isConnectedToTwitter: Boolean
  # Whether or not the user has enabled their email to be reused to create another twitch account.
  isEmailReusable: Boolean!
  # Whether or not the user can update their email.
  isEmailUpdateable: Boolean!
  # Whether or not the user has verified their email address by clicking a link sent to their email.
  isEmailVerified: Boolean!
  # Indicates that the owner of the email on the account did not signup for this account
  # This mainly implies that the account is being deleted and not eligible for self service reactivation.
  isFlaggedToDelete: Boolean!
  # Whether or not the user can moderate any broadcast chat.
  isGlobalMod: Boolean!
    @deprecated(reason: "Use user.roles.isGlobalMod instead.")
  # Whether or not the user is in good standing, granting automatic emote approval.
  # Passes both the authed twitch user who is requesting and the user they are requesting.
  # Applies to both affiliates and partners.
  isInEmoteGoodStanding: Boolean
  # Whether or not the user is in good standing generally.
  # Authenticated to current user. Will error if not a partner.
  isInGoodStanding: Boolean!
  # Whether the user meets the GDPR compliance as per his/her country's minimum compliance age.
  isMinimumGDPRConsentAge: Boolean!
  # Whether or not the user is moderator of a another user's channel.
  isModerator(channelID: String!): Boolean!
  # Whether or not the user is a partnered broadcaster with Twitch.
  isPartner: Boolean @deprecated(reason: "Use user.roles.isPartner instead.")
  # Whether or not the user has verified their phone number.
  # This is currently always true if the user has a phone number.
  # We do not not allow a user to set a phone number without verifying.
  isPhoneNumberVerified: Boolean!
  # Whether or not the user is a site admininistrator.
  isSiteAdmin: Boolean!
    @deprecated(reason: "Use user.roles.isSiteAdmin instead.")
  # Whether or not the user is a Twitch staff member.
  isStaff: Boolean! @deprecated(reason: "Use user.roles.isStaff instead.")
  # The key pools associated with a user.
  keyPools(after: String): KeyPoolConnection
  # The user's language preference.
  language: Language
    @deprecated(reason: "Use user.settings.preferredLanguageTag instead.")
  # The user's last broadcast.
  lastBroadcast: Broadcast
  # When the user last updated their login name.
  # This special field only resolves for the authenticated user.
  lastLoginChangeAt: Time
  # The last time the user's availability or activity changed.
  # This special field only resolves for the authenticated user; use friends.edges.lastStatusChangeAt to retrieve this
  # information about friends..
  # Requires the `user_presence_friends_read` scope.
  lastStatusChangeAt: Time
  # Fetches the latest created Poll for the user.
  latestPoll: Poll
  # The extensions this user has shared their identity with.
  linkedExtensions: [Extension!]
  # The user's standard alphanumeric Twitch name.
  login: String!
  # The user's profile image.
  # Valid widths are 28, 50, 70, 150, 300, and 600.
  # The image height will be the same as the given width.
  logoURL(width: Int!): String
    @deprecated(reason: "Replaced by profileImageURL")
  # Lists a User's Uploaded Loyalty Badge.
  loyaltyBadges: [LoyaltyBadge!]
  # Returns the max number of channel rooms that the current user is allowed to
  # create for their channel.
  maxAllowedChannelRooms: Int!
    @deprecated(reason: "The Rooms product has been sunset")
  # Returns a resolver to query different subsets of the moderation logs.
  modLogs: ModLogs
  # Returns all channel roles' access permissions to moderator logs.
  modLogsAccess: [ModLogsAccess!]
  # Returns a channel role's access permission to moderator logs.
  modLogsRoleAccess(role: ChannelUserRole!): ModLogsAccess
  # A user's settings related to the moderation view page.
  modViewSettings: ModViewSettings
  # Returns a paginated list of channel moderators.
  mods(first: Int = 10, after: Cursor): ModConnection
  # A user's event notification settings.
  notificationSettings: [EventNotificationSetting!]
  # A user's notifications.
  # This is only returned if the request is authenticated by the same user whose onsite notifications are requested.
  # `language` is a letter code for the language the requesting user speaks (ex. "en").
  notifications(
    first: Int = 10
    after: Cursor
    language: String
    displayType: OnsiteNotificationDisplayType
    capabilities: [OnsiteNotificationsCapability!]
  ): OnsiteNotificationConnection
  # OAuth applications developed by the current user.
  oauthApps(after: Cursor): OAuthAppConnection
  # A URL to the image that is displayed when the user is not broadcasting nor hosting another user's broadcast.
  offlineImageURL: String
  # Information about the current user's onboarding state.
  onboarding: Onboarding @deprecated(reason: "This feature has been sunset.")
  # List of invites to join an organization.
  organizationInvites(
    first: Int = 10
    after: Cursor
  ): OrganizationInviteUserConnection
  # Returns a list of developer organizations.
  # Returns null if the user doesn't belong to any organizations.
  organizations: [Organization!]
  # A list of open friend requests sent by this user. Friend requests to non-strangers are always placed in front of
  # friend requests to strangers; `sort` affects how the two components are ordered within themselves. Only accessible
  # if the user is authenticated with the `user_presence_friends_read` scope.
  outgoingFriendRequests(
    first: Int = 10
    after: Cursor
    sort: FriendSort = DESC
  ): OutgoingFriendRequestConnection
  # A list of teams owned by the user.
  # Only resolves for the current user.
  ownedTeams: [Team]
  # panels is a list of `Panel` objects with information related to this channel.
  panels(hideExtensions: Boolean = false): [Panel]!
  # Fetch participating challenges for the user based on a variety of sorting options.
  # By default returns 10 challenges, sorted by end time.
  participatingChallenges(
    first: Int = 10
    after: Cursor
    sort: ChannelChallengeSort = END_TIME
    direction: SortOrder = ASC
    status: [ChannelChallengeStatus!]
  ): ChannelChallengeConnection
  # Non-partnered users can submit a partnership application via createPartnershipApplication mutation.
  # PartnershipApplication includes the status of the most recently submitted application.
  partnershipApplication: PartnershipApplication
  # Whether or not the user is able to be paid.
  payableStatus: PayableStatus
  # Metrics that are relevant to incentive-based contracts for some partnered
  # streamers. This API returns a year-to-date, rolling list of the past 12
  # months and includes the current (in-progress) month.
  paymentIncentiveMetrics: [PaymentIncentiveMetricsRollup!]
  # Holds configuration necessary to start payment method management. Only the
  # authenticated user can access their own configs.
  # This is the second step of the payment method management flow.
  # (User.paymentMethods -> User.paymentMethodConfigs -> Mutation.setDefaultPaymentMethod).
  paymentMethodConfigs: PaymentProviderConfigs
  # List of payment methods that will be used to pay for Twitch subscriptions that renew in the future
  # This is the first step of the payment method management flow.
  # (User.paymentMethods -> User.paymentMethodConfigs -> Mutation.setDefaultPaymentMethod).
  paymentMethods: [PaymentMethod!]
  # Get user's list of payment transactions. This currently aggregates subscriptions related transactions but plans
  # to also aggregate other product types such as Bits. The ultimate goal is to record, aggregate, and provide the
  # payment history of Twitch users in a convenient way.
  paymentTransactions(
    first: Int = 50
    after: Cursor
    criteria: PaymentTransactionConnectionCriteriaInput!
  ): PaymentTransactionConnection
  # Payout Information.
  payout: Payout
  # Accrued balance since last payout.
  payoutBalance: PayoutBalance
  # A user's invite into a payout program.
  payoutInvite: PayoutInvite
  # List of payout plans a user has when enrolled in any payout programs.
  payoutPlans: [PayoutPlan!]
  # Get the permitted terms of a user.
  permittedTerms: [ChannelPermittedTerm!]!
    @deprecated(reason: "Use channel.permittedTerms instead")
  # The user's phone number. Format is always in E.164 format.
  # This is only returned if the request is authenticated by the same user whose phone is requested.
  phoneNumber: String
  # Fetch polls for the user based on a variety of sorting options.
  # By default returns 15 polls, sorted by start time.
  polls(
    first: Int = 15
    after: Cursor
    sort: PollSort = START_TIME
    direction: SortOrder = DESC
    status: [PollStatus!]
  ): PollConnection
  # Options and preferences for how the user participates in Predictions Events.
  # Users can only view their own Predictions Settings.
  predictionsSettings: UserPredictionSettings
  # The amount of preroll free time in seconds that a user has earned on their channel.
  prerollFreeTimeSeconds: Int
  # The hex string for the user's primary creator color.
  # Example: "FFFFFF".
  primaryColorHex: String
  # The primary team this user belongs to. A user may belong to more than one team at the same time but must select a single
  # team as the primary. If the user doesn't have a primary team this will be null.
  primaryTeam: Team
  # Always returns null, will be removed soon.
  primePayoutDetails: PrimePayoutDetails
    @deprecated(reason: "Use primePayoutHistory, this will be removed soon")
  # The prime payout details over a period of time for the user.
  primePayoutHistory: [PrimePayoutDetail!]
  # The Twitch Prime settings data for the user.
  primeSettings: PrimeSettings
  # A URL to the user's profile image.
  # Valid widths are 28, 50, 70, 96, 150, 300, and 600.
  # The image height will be the same as the given width.
  profileImageURL(width: Int!): String
  # The URL to viewing this user's profile.
  # This is typically https://twitch.tv/<login> .
  profileURL: String!
  # The number of views this user's profile has received since creation.
  profileViewCount: Int
  # The program agreement for a user enrolled in a payout program.
  programAgreement: ProgramAgreement
  # A user's pulse feed.
  # This is only returned if the request is authenticated by the same user whose email is requested.
  pulseFeed: Feed
  # PurchaseOrder returns a user's purchase order.
  purchaseOrder(id: ID!): PurchaseOrder
  # Quests associated with a user.
  quests: Quests
  # Twitch Radio for the user.
  radio: Radio
  # Twitch Radio account information.
  radioAccount: RadioAccount
    @deprecated(reason: "Use user.radio.account instead.")
  # Always returns null.
  raid: Raid @deprecated(reason: "this feature has been moved")
  # Preferences for raid behavior, including whether
  # raids are enabled and from whom can raids orignate.
  # Users can only view their own raid settings.
  raidSettings: RaidSettings
  # An array of recent raids by the broadcaster.
  recentRaids: [Raid!]
  # The feedback a user has given about recommended content.
  recommendationFeedback(
    limit: Int = 5
    after: Cursor
    type: String!
  ): RecommendationFeedbackConnection
  # Recommendations for the user. Recommendations can be retrieved only if the request
  # is authenticated and only for the authenticated user.
  recommendations: Recommendations
  # The recommended prefix which is generated based on user name.
  recommendedEmoticonPrefix: String!
  # This user's relationship with another user.
  relationship(targetUserID: ID): UserRelationship
  # User's declared country of residence.
  residence: UserResidence
  # Info on rewarded video for a user (eligibility).
  rewardedVideo: RewardedVideo
  # The roles this user fulfills on Twitch.
  roles: UserRoles
  # Search through a paginated list of public and private videos for this user.
  searchVideos(
    first: Int = 10
    after: Cursor
    search: VideoConnectionSearchParams
  ): VideoConnection
  # A list of streamer onboarding content IDs that that the user has been shown, and when it was first shown.
  seenCreatorOnboardingContent: [CreatorOnboardingContent!]
  # The badge this user has selected for global use on Twitch.
  selectedBadge: Badge
  # The authenticated user's relationship with this user.
  self: UserSelfConnection
  # Loads the extension installation data for the queried userID's channel that is relevant to the calling user.
  # This includes the extension configuration data & auth tokens for the extension-channel-user combination.
  selfInstalledExtensions(
    isMobile: Boolean = false
  ): [ExtensionInstallationSelfEdge!]
  # The settings this user has on Twitch.
  settings: UserSettings
  # The squad stream that this user is currently a member of, or null if the user is not a member of
  # any squad stream.
  squadStream: SquadStream
  # squadStreamSettings are the user's rules and settings for the squad stream feature.
  # Some fields only resolve for the authenticated user. See schema definition for more detail.
  squadStreamSettings: SquadStreamSettings
  # The relationship between the authenticated user and the single sign-on (SSO)
  # apps they have linked to their Twitch account.
  ssoLinks(app: String): [SSOLink!]
    @deprecated(reason: "Service has been shut down")
  # The user's live stream.
  # Null if the user is not currently broadcasting.
  stream: Stream
  # A list of the start and end times of stream sessions.
  streamSessions(first: Int, lastStartedAt: Time): [StreamSession!]
  # A list stream sessions that started and ended during the specified interval.
  streamSessionsByInterval(startAt: Time!, endAt: Time!): [StreamSession!]
  # A list of stream summaries. Stream summaries provide analytics information
  # for a streaming session. Last started time is for querying sessions from a previous time stamp.
  streamSummaries(first: Int, lastStartedAt: Time): [StreamSummary!]
  # Stucco packs displayed in the user's dashboard stucco settings.
  stuccoPacksBroadcaster: [StuccoPack]
  # stuccos available in the library in the user's dashboard stucco settings.
  stuccos: [Stucco]
  # A list of channels to which the user is subscribed.
  # Only resolves for the authenticated user.
  subscribedChannels(
    first: Int = 10
    after: Cursor
    live: Boolean
  ): SubscribedChannelConnection
  # The subscription score of the user. Returns both a breakdown of subscriptions and points by tier.
  # Authenticated to the current user. Will be nil if the user is not a partner or affiliate.
  subscriberScore: SubscriberScore
  # A paginated list of user's all active subscriptions.
  # Only resolves for the current user. Returns a forbidden error if requested for another user.
  subscriptionBenefits(
    first: Int = 10
    after: Cursor
    criteria: SubscriptionBenefitCriteriaInput!
  ): SubscriptionBenefitConnection
  # A list of subscription products available for purchase on the user's page.
  subscriptionProducts: [SubscriptionProduct]
  # A list of subscription products available for purchase on the user's page, including handleable errors.
  subscriptionProductsResult: SubscriptionProductsResult!
  # Subscription preferences for the current user.
  # Only resolves for the current user. Returns an error if request for another user.
  subscriptionSettings: UserSubscriptionSettings
  # Subtoken information associated with the user.
  # Includes balance of tokens which can be used to redeem Subscriptions.
  subscriptionToken: SubscriptionToken
  # Analytics of the frequency of tags used in discovery.
  tagAnalytics: [TagAnalytic!]
  # Tags are used as a discovery and search mechanism for channels.
  # The tag data is from Graffiti directly. Graffiti is not designed to handle huge traffic.
  # Please use Stream.tags instead if know the stream is live and you can accept a 5 min delay in the data.
  # For example, you should use Stream.tags for the channel page and the browse page, but use User.tags for the dashboard.
  tags: [Tag!]
  # A list of UserTeamMemberships which includes all the teams the user is a member of.
  # This includes the primary team.
  # Only resolves for the current user.
  teamMemberships: [UserTeamMembership]
  # Retrieves all the statistics within the start and end time broken down by granularity.
  # Default endAt time will be the current time (now).
  # Granularity defaults to 5 minutes.
  timeseriesStats(
    startAt: Time!
    endAt: Time
    timeZone: String!
    granularity: Granularity = FIVE_MINUTE
  ): TimeseriesStats
  # Tournament associated with the user. This is used with the Bits custom cheering experience.
  tournament: Tournament @deprecated
  # The user's relationship with Twitch.
  twitch: UserTwitchConnection
  # Get unacknowledged subscription events.
  unacknowledgedSubscriptionEvents(
    platform: String!
  ): [UnacknowledgedSubscriptionEvent!]
  # When the user last updated their account.
  # Returns null when the user's account has never been updated.
  updatedAt: Time
  # Verification request object for the user and an associated contact address.
  # If no address is provided, the current email address associated with the user account will be used.
  verificationRequest(address: String): VerificationRequest
  # Aggregated analytics for several video referral sources, for use in channel analytics.
  videoPlayReferrals(
    start: Time!
    end: Time!
    filter: ReferralsFilter = ALL
    dimension: ReferralsDimension!
    first: Int = 15
  ): VideoPlayReferrals
  # A paginated list of video shelves to display on the user's channel.
  videoShelves(
    first: Int = 10
    after: Cursor
    options: ShelvesOptions
  ): VideoShelfConnection
  # A paginated list of video shelves that are available to be displayed on the
  # user's channel. Only accessible for authorized users (user & editors).
  videoShelvesAvailable(
    first: Int = 10
    after: Cursor
    options: ShelvesAvailableOptions
  ): VideoShelfConnection
  # A paginated list of videos for this user.
  videos(
    first: Int = 10
    after: Cursor
    type: BroadcastType
    types: [BroadcastType!]
    sort: VideoSort = TIME
    options: VideoConnectionOptionsInput
  ): VideoConnection
  # The viewable poll for a channel.
  # Null if no viewable poll is present.
  viewablePoll: Poll
  # A paginated list of viewed videos and their histories for this user.
  # Only resolves for current user.
  viewedVideos(first: Int = 10): ViewedVideosConnection
  # A paginated list of channel VIPs.
  vips(first: Int = 10, after: Cursor): VIPConnection
  # A user's balances in their Twitch Wallet in different FIAT currencies
  # If this isn't the `currentUser` this will return null.
  walletBalances(
    walletType: WalletType
    bestGuessCountryCode: String
  ): WalletBalances
  # A list of restrictions that prevent a user from hosting Watch Parties. A
  # user can only host Watch Parties if there are no restrictions.
  watchPartiesRestrictions: [WatchPartiesRestriction!]
  # A Watch Party if the User is currently broadcasting one.
  watchParty(accessToken: String, decorated: Boolean = false): WatchPartyResult
  # Settings related to the Whispers (private user-to-user messaging) feature.
  # Only resolves for the authenticated user.
  whisperSettings: WhisperSettings
  # A paginated list of whisper threads for the current user, sorted by recent first.
  whisperThreads(first: Int = 10, after: Cursor): WhisperThreadConnection
  # Withholding Tax Detail is the withholding tax rates for the creator.
  withholdingTaxDetail: WithholdingTaxDetail
}

# Groups users account health information around security of their account.
type UserAccountHealth {
  # Is the user required to reset their password.
  isPasswordResetRequired: Boolean!
  # Is the users email address verified.
  isVerifiedEmail: Boolean!
  # Current status of the users password.
  passwordStatus: PasswordStatus!
  # The list of Two factor Methods the user has registered with.
  # Empty list means the user does not have two factor.
  twoFactorMethods: [TwoFactorMethod!]!
  # Whether the user's two factor account ID is associated to multiple twitch accounts.
  isTwoFactorAccountShared: Boolean!
}

# The relationship between the user and Amazon.
type UserAmazonConnection {
  # The Amazon associates store linked to this user.
  associatesStore: AssociatesStore
}

# The edge between a User and a Blizzard connection.
type UserBlizzardConnectionLink {
  # Returns battletag if available. Can be string or nil.
  battleTag: String
}

# Exactly one of the identifiers must be specified.
input UserByAttribute {
  # The human-readable identifier for a clip.
  # When specified, returns the broadcaster of the clip.
  broadcasterOfClipSlug: String
  # The user's login.
  login: String
  # The identifier for a video collection.
  # When specified, returns the owner of the collection.
  ownsCollectionID: ID
  # The identifier for a video.
  # When specified, returns the owner of the video.
  ownsVideoID: ID
}

# Filtering criteria for paginated user clips results.
input UserClipsInput {
  # The ID of the broadcaster to filter results by.
  broadcasterID: ID
  # The ID of the curator to filter results by.
  curatorID: ID
  # DEPRECATED: `filter` should no longer be used. Prefer `period` and `sort` instead.
  # A filter which restricts results.
  filter: ClipsFilter
  # The name of the game to filter results by.
  gameName: String
  # The time period to restrict clips based on creation time.
  period: ClipsPeriod = LAST_WEEK
  # The sort order for the clips results.
  sort: ClipsSort = VIEWS_DESC
}

# Enum that specifies which role the user is taking when querying for competitions.
enum UserCompetitionRelationship {
  # Player in a competition.
  PLAYER
  # Owner of a competition.
  OWNER
  # Unknown competition role.
  UNKNOWN
}

# Paginated list of Users, where the relationship between the source type and the User is
# generic enough that no information needs to be encoded on the edge.
type UserConnection {
  edges: [UserEdge!]
  pageInfo: PageInfo!
  # The total number of users.
  totalCount: Int
}

# The connection between a user and the directories they have selected to broadcast in.
type UserDirectoryConnection {
  # The directories selected by this user.
  nodes: [Directory]!
}

# When resolving a User, the underlying service may claim that
# no user actually exists for the inputs (i.e. banned, deleted, or
# there's no record of an account with that login/ID).
type UserDoesNotExist {
  # Key that was used to resolve the user, could be an ID or login.
  key: String!
}

# A list of Drops awarded to the user. // deprecated.
type UserDropAwardConnection {
  # The Drops awarded to the user.
  nodes: [DropAward]! @deprecated
  # The number of drop awards a user has received.
  totalCount: Int @deprecated
}

# A list of Drops awarded to the user via Drops2.0.
type UserDropReward {
  # The DropBenefit that a user is entitled to.
  benefit: DropBenefit!
  # The game that awarded the Drop.
  game: Game @deprecated(reason: "use benefit.Game")
  # The assigned ID of the awarded reward.
  id: ID! @deprecated(reason: "use benefit.id")
  # The image URL of the Benefit. Images are 80x80 pixels.
  imageURL: String! @deprecated(reason: "use benefit.imageAssetURL")
  # Flag if the user is connected to the game in order to receive the Reward.
  isConnected: Boolean!
  # Specifies if this reward is considered for a game that is available on iOS.
  isIosAvailable: Boolean! @deprecated(reason: "use benefit.isIosAvailable")
  # The timestamp when the Benefit was last awarded to the user.
  lastAwardedAt: Time!
  # The developer-provided name of the awarded Benefit.
  name: String! @deprecated(reason: "use benefit.name")
  # Link where the user can connect their account necessary to receive the reward.
  requiredAccountLink: String! @deprecated(reason: "use benefit.accountLinkURL")
  # The number of drop awards a user has received.
  totalCount: Int!
}

# Generic edge between some type and a User, where there is no information that needs to
# to be encoded on the edge.
type UserEdge {
  cursor: Cursor
  node: User
}

# An attempt to resolve a user has failed due to an error.
type UserError {
  # Key that was used to resolve the user, could be an ID or login.
  key: String!
}

# The edge between a User and a Facebook connection.
type UserFacebookConnectionLink {
  # The user's full name on Facebook. eg. "John Doe".
  fullName: String!
}

# UserLeaderboard contains a leaderboard whose entries are Users.
type UserLeaderboard {
  # id is the id of this leaderboard.
  id: ID!
  # items is the list of users in the leaderboard ordered by their score.
  items: UserLeaderboardItemConnection!
  # myPosition contains the item representing the authed user's position on this leaderboard.
  myPosition: UserLeaderboardItem
  # SecondsRemaining is the number of seconds left before the leaderboard expires (or zero for all-time).
  secondsRemaining: Int!
}

# UserLeaderboardItem at a specific node in a leaderboard connection.
type UserLeaderboardItem {
  # id the id of this leaderboard item.
  id: ID!
  # rank the ordinal rank of this leaderboard item.
  rank: Int!
  # score the numerical value by which this leaderboard is sorted.
  score: Int!
  # user is the user that holds this position.
  user: User
}

# UserLeaderboardItemConnection is used to show the various leaderboard items.
type UserLeaderboardItemConnection {
  # edges ...
  edges: [UserLeaderboardItemEdge!]!
  # pageInfo ...
  pageInfo: PageInfo!
}

# UserLeaderboardItemEdge describes an edge in a bits leaderboard.
type UserLeaderboardItemEdge {
  # The cursor for this leaderboard edge.
  cursor: Cursor!
  # The leaderboard entry at this edge.
  node: UserLeaderboardItem
}

# The available types of lookups for a user query.
enum UserLookupType {
  # Retrieves only active users without TOS/DMCA violations.
  ACTIVE
  # Includes suspended or deleted users in the results.
  ALL
}

# Restrictions on a user participating in a given Prediction Event.
enum UserPredictionEventRestriction {
  # The user is restricted from participating because they have the ability to manage Predictions on this channel.
  CAN_MANAGE_PREDICTIONS
  # The user is restricted from participating because their geographic location has a blanket ban on Prediction participation.
  REGION_LOCKED
  # The user is restricted from participating because their geographic location
  # has a ban on Predictions for the specific game/category being played.
  CATEGORY_REGION_LOCKED
}

# Options and preferences for how the user participates in Predictions Events.
# Users can only view their own Predictions Settings.
type UserPredictionSettings {
  # Whether the user has accepted the latest Predictions Terms of Service.
  hasAcceptedTOS: Boolean!
  # Whether the user is in a region that is restricted from participation in making predictions.
  isInRestrictedRegion: Boolean
  # Whether the user has opted to display a temporary chat badge indicating their choices during Predictions Events.
  isTemporaryChatBadgeEnabled: Boolean!
}

# Statistics concerning how a user has performed when making Predictions in a given channel.
type UserPredictionStatistics {
  # The total number of events that this user has participated in on this channel.
  eventsTotal: Int!
  # The number of events that this user has successfully predicted in this channel.
  eventsWon: Int!
  # The most recent prediction made by this user on this channel. Null if they have not made a Prediction recently.
  mostRecentPrediction: Prediction
  # The total number of points that this user has spent making predictions in this channel.
  pointsUsed: Int!
  # The total number of points that this user has won from correct predictions in this channel.
  pointsWon: Int!
  # The highest number of points that this user has won from a correct prediction in this channel.
  pointsWonMax: Int!
  # The user's current win-streak in Events on this channel.
  winStreak: Int!
  # The highest win-streak in Events on this channel the user has ever had.
  winStreakMax: Int!
}

# Subjective data on a User (user/channel) for the target user.
type UserRelationship {
  # The time when a follower relationship between the user and the target user was established.
  followedAt: Time
  # Statistics concerning how well the target user has performed in Prediction Events on the user's channel.
  predictionStatistics: UserPredictionStatistics
  # The subscription benefit relationship between the user and the target user.
  # Null if the user is not subscribed to the other user.
  subscriptionBenefit: SubscriptionBenefit
  # Subscription tenure data for the user to the target user.
  subscriptionTenure(
    tenureMethod: SubscriptionTenureMethod!
  ): SubscriptionTenure
}

# User's residence.
type UserResidence {
  # Country in ISO alpha-2.
  countryCode: String!
  # Postal code.
  postalCode: String
}

# The set of results that can occur when resolving a user query.
union UserResult = User | UserDoesNotExist | UserError
# The edge between a User and a Youtube Connection.
type UserRiotConnectionLink {
  # The PUUID for the user's Riot account.
  id: ID!
}

# Groups site-wide user roles together.
type UserRoles {
  # Whether or not the user is enrolled in the affiliate program.
  # See https://affiliate.twitch.tv for more information.
  isAffiliate: Boolean
  # Whether or not the user is allowed to approve extensions on Twitch.
  isExtensionsApprover: Boolean
    @deprecated(reason: "This role is no longer surfaced through the API")
  # Whether or not the user is enrolled in the extensions developer program.
  # See https://dev.twitch.tv/docs/extensions/onboarding for more information.
  isExtensionsDeveloper: Boolean
  # Whether or not the user can moderate any broadcast chat.
  isGlobalMod: Boolean
  # Whether or not the user is a partnered broadcaster with Twitch.
  isPartner: Boolean
  # Whether or not the user is a site admininistrator.
  isSiteAdmin: Boolean
  # Whether or not the user is a Twitch staff member.
  isStaff: Boolean
}

# UserSelfBitsBadge contains the current user's badge tier in a channel and progress toward the next tier.
# NOTE: should probably have been named CurrentUserBitsBadge.
type UserSelfBitsBadge {
  # current is the highest bits chat badge the authenticated user has achieved in this channel.
  # If a badge tier is disabled after being earned it will still appear here until the next tier is earned.
  # If the user hasn't earned any bits badges yet this will be null.
  current: Badge
  id: ID!
  # next is the next chat badge the authenticated user can earn in this channel.
  # If this is null then there are no higher tiers to earn.
  next: Badge
  # nextBits is the bits value of the next chat badge the authenticated user can earn in this channel.
  # If this is null then there are no higher tiers to earn.
  nextBits: Int
  # progress is the fraction of the way the user is toward the next badge tier [0.0-1.0).
  # If `next` is null this will be zero.
  progress: Float!
  # tierNotification represents a notification sent to a user when they have achieved
  # a new bits badge in a channel. Used to send a special message.
  # If no notification is pending this will be null.
  tierNotification: BitsBadgeTierNotification
  # totalBits is the number of bits the authenticated user has used in this channel.
  totalBits: Int!
}

# Subjective data on another User (user/channel) for the current user.
type UserSelfConnection {
  # The badges which are available for the authenticated user to select for use on another user's streams and videos.
  availableBadges: [Badge]
  # Ban status of the authenticated user with respect to this user's channel.
  banStatus: ChatRoomBanStatus
  # bitsBadge contains information about bits badge progression in a channel.
  # This field can only be requested if an OAuth token is supplied with the request.
  bitsBadge: UserSelfBitsBadge
  # The bits leaderboard entry shows the current user's entry in the
  # channel's leaderboard. It does not show context entries around it.
  bitsLeaderboardEntry: BitsLeaderboardEntry
    @deprecated(reason: "use user.self.bitsLeaderboardItem instead.")
  # The bits leaderboard item shows the current user's entry in the
  # channel's leaderboard. It does not show context entries around it.
  bitsLeaderboardItem: BitsLeaderboardItem
  # The bits leaderboard position shows the curreent users rank
  # and the surrounding users in the current channel.
  bitsLeaderboardPosition: BitsLeaderboard
  # Whether or not the authenticated user can follow this user.
  canFollow: Boolean!
  # CanGift relationship between the authenticated user, another user, and a product.
  # True is the authenticated user can gift the product to the other user.
  canGift(product: String!): Boolean!
    @deprecated(
      reason: "Transitioning to SubscriptionProductSelfConnection instead"
    )
  # CanGiftInChannel relationship between the authenticated user and a product.
  # True is the authenticated user is allowed to send gifts in this channel.
  canGiftInChannel(product: String!): Boolean!
    @deprecated(
      reason: "Transitioning to SubscriptionProductSelfConnection instead"
    )
  # Checks if the authenticated user can subscribe to this channel via Prime.
  canPrimeSubscribe: Boolean!
  # Whether the authenticated user has permission to redeem a subscription to this Channel.
  # Return Values are.
  # 1) Null - The Channel to which the User is subscribed to is not supporting any subscription redemption.
  # 2) False - The User has already utilized their redemption to the channel offering subscription redemption.
  # 2) True - The User can use the subscription redemption offered by the channel.
  canRedeemSubscription: Boolean
  # The list of celebration products available for the authenticated user to purchase in this channel.
  celebrationProducts: [CelebrationProduct]
  # If the authenticated user cannot chat in this channel, a list of reasons.
  # Null if the user can chat.
  chatRestrictedReasons: [ChatRestrictedReason!]
  # Lists the chat badges that should be displayed by the user's display name in
  # features on a particular user's channel (i.e. chat, feeds).
  # Includes the following badges:
  # - global authority (staff/admin/global mod)
  # - channel authority (broadcaster/mod)
  # - subscriber
  # - channel selected (bits) or global selected (prime, turbo, ...).
  displayBadges: [Badge]!
  # A follower relationship between the authenticated user and another user.
  # Null if the relationship does not exist.
  follower: FollowerEdge
  # The friendship-type relationship (friendship, incoming friend request, outgoing friend request) between the
  # authenticated user and another user. Null if no friendship-type relationship exists.
  friendship: FriendRelationship
  # True if the authenticated user has joined this channel.
  isChannelMember: Boolean
  # Whether or not the authenticated user is editor of another user's channel.
  isEditor: Boolean
  # Whether or not the authenticated user is a founder badge owner of another user's channel.
  isFounder: Boolean
  # Whether or not the authenticated user is a moderator of another user's channel.
  isModerator: Boolean
  # Whether or not the authenticated user is a VIP of another user's channel.
  isVIP: Boolean
  # The timestamp of the last time the authenticated user sent a chat message in
  # another user's channel within the last 30 minutes.
  # Null if the authenticated user has not chatted in the channel in the last 30 minutes.
  lastRecentChatMessageAt: Time
  # Information about the authenticated user's Prime subscription credit benefit.
  primeSubCreditBenefit: PrimeSubCreditBenefit
  # The most recent resub token to use for sending a special message.
  # If no notification is pending this will be null.
  resubNotification: ResubNotification
  # Lists ritual tokens that can be requested or displayed to the user in another user's channel.
  ritualTokens: [RitualToken!]
  # The badge the authenticated user selected for use on another user's streams and videos.
  selectedBadge: Badge
  # Stucco packs that are available to viewers of a broadcaster.
  stuccoPacksViewer: [StuccoPack]
  # The current subscriber badge that a user would have if subscribed & remaining locked subscriber badges with progress.
  subscriberBadgeProgress(limit: Int = 5): [SubscriberBadgeProgress!]
  # The subscription benefit relationship between the authenticated user and another user.
  # Null if the authenticated user is not subscribed to the other user.
  subscriptionBenefit: SubscriptionBenefit
  # The number of gift subscriptions that the authenticated user has given to other users in this channel.
  subscriptionGiftCount: Int
  # Subscription tenure data for the user to this channel.
  subscriptionTenure(
    tenureMethod: SubscriptionTenureMethod!
  ): SubscriptionTenure
  # Whether the authenticated user can send or receive Whispers to/from another user.
  whisperPermissions: WhisperPermissions
}

# Groups site-wide user settings together.
type UserSettings {
  # Whether the user is whitelisted to host Prime Video watch parties. This
  # takes precedence over user.watchPartiesRestrictions.
  canHostWatchParties: Boolean!
  # The user's channel feed on/off switch.
  # The channel feed is displayed if set to true and is
  # hidden if set to false.
  channelFeedEnabled: Boolean! @deprecated
  # The cheer settings for a user, configured in their partner dashboard.
  cheer: CheerPartnerSettings
  # Whether or not the user has a second authentication method configured.
  hasTwoFactorEnabled: Boolean
  # Whether or not the broadcaster is eligible for payout through Amazon retail revenue share.
  isAmazonRetailRevShareEnabled: Boolean
    @deprecated(reason: "Game sales discontinued")
  # Whether or not the broadcaster is eligible for payout through twitch game commerce revenue share.
  isCommerceRevShareEnabled: Boolean
    @deprecated(reason: "Game sales discontinued")
  # Whether or not the user has requested that their registration date be hidden in the viewer card.
  isCreateDateHidden: Boolean
  # Whether or not the user has elected to be hidden from search results.
  isDirectoryHidden: Boolean
  # Whether or not the email was successfully reverted.
  isEmailRevertSuccess: Boolean
  # Whether the user's channel has rituals enabled.
  isRitualsEnabled: Boolean!
  # Whether the user's channel is whitelisted into the rituals experiment.
  isRitualsWhitelisted: Boolean!
    @deprecated(reason: "Rituals is whitelisted only for launch.")
  # The user's activity sharing setting.
  # Activity is the part of a user's status that shows what they're currently playing, watching, or streaming.
  # Requires the `user_presence_friends_read` scope.
  isSharingActivity: Boolean!
  # Partner settings related to leaderboards.
  leaderboard: LeaderboardSettings
  # The user's preferred language tag for displaying text content.
  preferredLanguageTag: LanguageTag
  # The user's shared availability while online.
  # A value of ONLINE (typically called "invisibility") additionally means that the user's activity will not be shared
  # regardless of the isSharingActivity setting.
  # Requires the `user_presence_friends_read` scope.
  visibility: Visibility!
}

# The edge between a User and a Steam connection.
type UserSteamConnectionLink {
  # A Steam user ID.
  id: ID!
}

# UserSubscriptionSettings displays the users subscription settings.
type UserSubscriptionSettings {
  # If the user only wants to receive gifts to channels they follow.
  giftsToFollowedChannelsOnly: Boolean!
  # If the user wants to hide Badge Modifier.
  isBadgeModifierHidden: Boolean!
  # If the user wants to hide their Founder Badges.
  isFounderBadgesHidden: Boolean!
  # If the user wants to hide the number of gifts they've gifted.
  isGiftCountHidden: Boolean!
  # If the user wants to hide their subscription tenure and status in the chat viewer card.
  isSubscriptionStatusHidden: Boolean!
}

# UserTeamMembership represents a User's membership to a Twitch Team.
# UserTeamMemberships are collections of teams that the User is a part of.
type UserTeamMembership {
  # Whether the team is the primary team for the given User.
  isPrimary: Boolean!
  # Whether the team is revenue revealed for the given User.
  isRevenueRevealed: Boolean!
  # Whether the team is stats revealed for the given User.
  isStatsRevealed: Boolean!
  # The Team the user is a member of.
  team: Team!
}

# The relationship between the user and Twitch.
type UserTwitchConnection {
  # Returns the User's preferred team in Overwatch League.
  overwatchLeagueTeamPreference: OverwatchLeagueTeamPreference
}

# The edge between a User and a Twitter connection.
type UserTwitterConnectionLink {
  # A Twitter username, without the "@" (eg. "Twitch").
  username: String!
}

# The edge between a User and a Youtube Connection.
type UserYoutubeConnectionLink {
  # The URL for the user's Youtube channel.
  channelURL: String!
}

# Error that occurred while validating with code.
type ValidateVerificationCodeError {
  # Error code for error that occurred while validating with code.
  code: ValidateVerificationCodeErrorCode
}

# Error types for verification.
enum ValidateVerificationCodeErrorCode {
  # Verification failed because provided code does not match.
  INCORRECT_CODE
  # Validation code was incorrect and the code has been regenerated and resent due to too many failed attempts.
  TOO_MANY_FAILED_ATTEMPTS
  # Verification failed due to being rate limited.
  RATE_LIMITED
  # Verification failed due to some unknown, unclassified error.
  UNKNOWN
}

# ValidateVerificationCodeInput is input required to verify a user contact method
# in EVS by validating their verification code.
input ValidateVerificationCodeInput {
  # Address that the user is verifying. This will most likely be an email address or phone number.
  address: String!
  # Code used to validate if the verification request is valid.
  code: String!
  # Key for the entity associated with the address. This is generally the Twitch ID of the user.
  key: String!
}

# ValidateVerificationCodePayload is the VerificationRequest document returned from EVS on success.
type ValidateVerificationCodePayload {
  # Mutation error based on user input.
  error: ValidateVerificationCodeError
  # The updated verification request.
  request: VerificationRequest
}

# Vendor consent is a union of different vendors supported based on privacy law.
union VendorConsent = CCPAVendorConsent | GDPRVendorConsent | ROWVendorConsent
# VendorConsentStatus is the consent status of each vendor.
type VendorConsentStatus {
  # User consentStatus for this vendor.
  consentStatus: ConsentStatus!
  # A flag that shows if the consent is given by the user or by consent service as default value.
  hasUserSetConsent: Boolean!
  # A flag that shows if the vendor should be visible to the consent settings page.
  isVisible: Boolean!
  # Vendor name.
  name: VendorName!
}

# VendorConsentStatusInput is the input struct for vendor consent status.
input VendorConsentStatusInput {
  # Consent status of this vendor.
  consentStatus: ConsentStatus!
  # name of the vendor.
  name: VendorName!
}

# VendorName is the name of the cookie vendor.
enum VendorName {
  # AMAZON is Amazon.
  # DEPRECATED vendor.
  AMAZON
  # TWITCH_AMAZON is a vendor replacement for Amazon.
  # This should be the vendor used to get consent on Amazon.
  TWITCH_AMAZON
  # BRANCH is Branch.
  BRANCH
  # COMSCORE is ComScore.
  COMSCORE
  # GOOGLE is Google.
  GOOGLE
  # NIELSEN is Nielsen.
  NIELSEN
  # SALESFORCE_DMP is Salesforce_DMP.
  SALESFORCE_DMP
  # BEESWAX is Beeswax.
  BEESWAX
  # BEESWAX is Truex.
  TRUEX
  # THE_TRADE_DESK is The Trade Desk.
  THE_TRADE_DESK
  # FLASHTALKING is Flashtalking.
  FLASHTALKING
  # GAMESITE is Gamesite.
  GAMESITE
  # KANTAR is Kantar.
  KANTAR
  # SPOTX is Spotx.
  SPOTX
  # SIZMEK is Sizmek.
  SIZMEK
  # GOOGLE_ANALYTICS_DEVELOPER_EXTENSIONS is Google analytics developer Extensions.
  GOOGLE_ANALYTICS_DEVELOPER_EXTENSIONS
}

# Represents a user's request to verify a given contact method, such as email address or phone number.
type VerificationRequest {
  # Address that the user is verifying. This will most likely be an email address or phone number.
  address: String!
  # Key for the entity associated with the address. This is generally the Twitch ID of the user.
  key: String!
  # Time at which the verification request was last modified.
  modified: Time!
  # Status of the verification request: pending, verified, or rejected.
  status: VerificationStatus!
}

# Status of a given verification request.
enum VerificationStatus {
  # Unknown is used as a safe fallback status.
  UNKNOWN
  # Pending indicates not yet successfully verified.
  PENDING
  # Verified indicates successfully verified.
  VERIFIED
  # Rejected indicates we were unable to send a verification request to the given
  # address, for example if we received a hard bounce from SES.
  REJECTED
}

# VerifyContactMethodInput is input required to verify a user contact method in EVS by their opaque ID.
input VerifyContactMethodInput {
  # Used to validate the associated user contact info.
  opaqueID: ID!
}

# VerifyContactMethodPayload is the VerificationRequest document returned from EVS on success.
type VerifyContactMethodPayload {
  # The success/failure of the verification attempt.
  isSuccess: Boolean!
  # The updated verification request.
  request: VerificationRequest
}

# Error returned during a invalid user request.
type VerifyOneTimePasswordError {
  # Error code returned by the backend.
  code: VerifyOneTimePasswordErrorCode!
  # The localized external error message.
  message: String!
}

# The possible error enums returned while trying to verify a one time password.
enum VerifyOneTimePasswordErrorCode {
  # The user needs to re-authenticate to perform this operation.
  REAUTH_NEEDED
  # The one time password submitted is invalid.
  INVALID_OTP
  # The user does not have two factor enabled and cannot verify a one time password.
  NO_TWO_FACTOR
  # Something unexpected occured.
  UNKNOWN_ERROR
}

# The required input for a VerifyOneTimePasswordInput mutation.
input VerifyOneTimePasswordInput {
  # The one time password that needs to be verified.
  oneTimePassword: String!
  # The ID of the user attempting to verify a one time password.
  userID: ID!
}

# The result of a verifyOneTimePassword mutation.
type VerifyOneTimePasswordPayload {
  # error code and localized error.
  error: VerifyOneTimePasswordError
}

# Error that occurred while validating with captcha token.
type VerifyRewardedVideoEligibilityCaptchaError {
  # Error code for error that occurred while validating the captcha token.
  code: VerifyRewardedVideoEligibilityCaptchaErrorCode!
}

# Error types for captcha verification.
enum VerifyRewardedVideoEligibilityCaptchaErrorCode {
  # The input provided by the user was rejected.
  INVALID_PARAMETER
  # The service had an issue unrelated to your input.
  INTERNAL_ERROR
}

# Inputs for registering a Captcha for WATEB.
input VerifyRewardedVideoEligibilityCaptchaInput {
  # Whether we authenticated with V1 or V2 Arkose endpoint.
  arkoseEndpointVersion: ArkoseEndpointVersion!
  # The token response from Arkose to verify.
  sessionToken: String!
}

# The response from verifying a captcha with rewarded video systems.
type VerifyRewardedVideoEligibilityCaptchaPayload {
  # The error (if one exists) returned from validating the captcha token.
  error: VerifyRewardedVideoEligibilityCaptchaError
}

# IDs used to determine the context(s) by which content was determined for a given VerticalSubDirectory.
union VerticalContentContext = Game | Tag
# A container of content for a vertical grouped by shelves.
type VerticalDirectory {
  # The vertical's unique Twitch identifier.
  id: ID!
  # The vertical's backend name.
  name: String
  # List of shelf groups containing content for this vertical.
  shelfGroups: [VerticalShelfGroup!]
  # The human readable slug for the vertical directory, used in the URL.
  slug: String
  # The subtitle for the shelf group.
  subtitle: ShelfTitle!
  # The title for the shelf.
  title: ShelfTitle!
  # Used in client tracking.
  trackingID: ID!
}

# An ordered list of content to render with metadata on the content.
type VerticalShelf {
  # The ordered content for the shelf.
  content: ShelfContentConnection!
  # The one or more contexts for which this shelf contains content for.
  contentContext: [VerticalContentContext!]
  # A unique identifier for the shelf.
  id: ID!
  # The subtitle for the shelf group.
  subtitle: ShelfTitle
  # The title for the shelf.
  title: ShelfTitle
  # Used in client tracking.
  trackingID: ID!
  # The type of this shelf.
  type: VerticalShelfType!
}

# A grouping of one or more shelves.
type VerticalShelfGroup {
  # The one or more contexts for which this shelf group contains content for.
  contentContext: [VerticalContentContext!]
  # A unique identifer for this shelf group.
  id: ID!
  # The ordered shelves for this shelf group.
  shelves: [VerticalShelf!]
  # The subtitle for the shelf group.
  subtitle: ShelfTitle
  # The title for the shelf group.
  title: ShelfTitle
  # Used in client tracking.
  trackingID: ID!
}

# The types of vertical shelves supported.
enum VerticalShelfType {
  # A list of categories to be selected.
  CATEGORY_SELECTOR
  # Live matches.
  LIVE_MATCHES
  # Live professionals.
  LIVE_PROS
  # Replays.
  REPLAYS
  # Collection.
  COLLECTION
}

# A container of content for a vertical by category, grouped by shelves.
type VerticalSubDirectory {
  # The one or more contexts for which this directory contains content for.
  contentContext: [VerticalContentContext!]
  # The vertical's unique Twitch identifier.
  id: ID!
  # List of shelf groups containing content for this vertical category.
  shelfGroups: [VerticalShelfGroup!]
  # The subtitle for the shelf group.
  subtitle: ShelfTitle!
  # The title for the shelf.
  title: ShelfTitle!
  # Used in client tracking.
  trackingID: ID!
}

# The content context of a subdirectory.
input VerticalSubDirectoryContentContext {
  # The subdirectory content context category ids.
  categoryIDs: [ID!]
  # The subdirectory content context tag ids.
  tagIDs: [ID!]
}

type Video {
  # A link to an image which contains an animated preview of the video.
  animatedPreviewURL: String
  # A list of bookmarks for this video.
  bookmarks(first: Int, after: Cursor): VideoBookmarkConnection
  # The type of broadcast the video originated from.
  broadcastType: BroadcastType
  # A paginated list of clips for this video.
  # When criteria is not specified, the default values are used.
  clips(
    first: Int = 10
    after: Cursor
    curatorIDs: [ID!]
    sort: SortOrder = ASC
  ): ClipConnection
  # A paginated list of comments against this video.
  comments(
    first: Int
    after: Cursor
    last: Int
    Before: Cursor
    contentOffsetSeconds: Int
  ): VideoCommentConnection
  # A list of tags describing the video.
  contentTags: [Tag!]
  # The time the video metadata record was created.
  createdAt: Time
  # The user who created this video.
  # This will be either the broadcaster or one of their editors.
  creator: User
  # NOTE: named `deleteAt` in Vinyl.
  deletedAt: Time
  # A description of the video, formatted in markdown.
  description: String
  # Download information of the video. NOTE: Request this field only when a user is requesting a download
  # since it will go through a process to generate a download URL on the backend.
  download: VideoDownload
  # The length of the video.
  duration: Duration
    @deprecated(reason: "Use length instead, as it's easier to parse.")
  # The game the video is depicting.
  game: Game
  # The video's identifier.
  id: ID!
  # Whether the video has been soft deleted.
  isDeleted: Boolean!
  # Which language the video is in.
  language: String
  # The length of the video, as an int, in seconds.
  lengthSeconds: Int
  # A list of moments for this video.
  moments(
    first: Int = 10
    after: Cursor
    sort: SortOrder = ASC
    types: [VideoMomentType]
    momentRequestType: VideoMomentRequestType
  ): VideoMomentConnection
  # Publicly available muted segment info, detailing which parts of the video
  # have had audio removed.
  muteInfo: VideoMuteInfo
  # For highlights, the number of seconds offset from the beginning of the past broadcast the highlight starts.
  # For past broadcasts and uploads, this means nothing.
  offsetSeconds: Int
  # The owner of the video.
  owner: User
  # The playback access token that determines whether the user can watch the video.
  # Fetched for both authed and unauthed users.
  playbackAccessToken(params: PlaybackAccessTokenParams!): PlaybackAccessToken
  # The URL to the thumbnail which should be displayed for the video.
  # If either `height` or `width` are not given, a templated value (i.e.
  # `{height}
`, `{width}
`) will be present in the URL instead.
  previewThumbnailURL(height: Int, width: Int): String!
  # The time when the archive/highlight/upload was first ever available to public,
  # even if it is not currently public.
  publishedAt: Time
  # The reactions associated with this video.
  reactions: [Reaction]
  # The time the video was recorded.
  recordedAt: Time
  # The reason a video is restricted if the given video is a restricted video.
  # For a video that is not restricted, this field can be null.
  resourceRestriction: ResourceRestriction
  # The reason a video is restricted if the given video is a restricted video.
  # For a video that is not restricted, this field can be null.
  restriction: VideoRestriction
    @deprecated(
      reason: "Restriction will be moved over to resourceRestriction instead"
    )
  # Either PRIVATE or PUBLIC.
  scope: VideoPrivacyScope
  # A link to a sprite sheet image made up of preview thumbnails when seeking the video timeline.
  seekPreviewsURL: String
  # The authenticated user's relationship with this video.
  self: VideoSelfEdge
  # When broadcastType is:
  # - ARCHIVE: status goes from RECORDING to RECORDED.
  # - HIGHLIGHT: status goes from UNPROCESSED to RECORDED.
  # - UPLOAD: status goes from CREATED to UPLOADING, to PENDING_TRANSCODE, to RECORDED, or FAILED if anything goes wrong.
  # - PREMIERE_UPLOAD: status goes from CREATED to UPLOADING, to
  # PENDING_TRANSCODE, to RECORDED, or FAILED if anything goes wrong for this
  # legacy broadcast type.
  # - PAST_PREMIERE: status goes from RECORDING to RECORDED for this legacy broadcast type.
  status: VideoStatus
  # The suggested details for creating an automated highlight from this video.
  suggestedHighlight: VideoSuggestedHighlight
  # An array of tags describing the video. This field will be deprecated soon. Please use `Video.contentTag` instead.
  tags: [String]
  # A list of thumbnail URLs for the video, ordered by descending priority.
  # Owners can insert custom thumbnails into this list.
  # If either `height` or `width` are not given, a templated value (i.e.
  # `{height}
`, `{width}
`) will be present in the URL instead.
  thumbnailURLs(height: Int, width: Int): [String]
  # The title of the video.
  title: String
  # A paginated list of clips featuring this vod that is, by default, ordered by view count descending.
  # When criteria is not specified, the default values are used.
  topClips(
    first: Int = 10
    after: Cursor
    criteria: VideoTopClipsInput
  ): ClipConnection
  # The most recent time the video data was updated.
  updatedAt: Time
  # The numer of views this video has. Can be delayed by up to 15 minutes.
  viewCount: Int
  # For a scheduled video, the time when the video will be made available to the
  # public (the time when the scope will be automatically set to "public").
  # For a video that is public or not scheduled, is null.
  viewableAt: Time
}

# A video bookmark.
type VideoBookmark {
  # channel the VOD belongs to.
  channel: User!
  # Time at which the bookmark was created.
  createdAt: Time!
  # Description of the bookmark.
  description: String!
  # ID of the bookmark.
  id: ID!
  # Relative offset in the video.
  positionSeconds: Int!
  # user who created the bookmark.
  user: User!
}

# A paginated list of video bookmarks.
type VideoBookmarkConnection {
  # The elements of the paginated list.
  edges: [VideoBookmarkEdge]!
  # Error of the get video bookmarks request.
  error: VideoBookmarkConnectionError
  # Information about this page.
  pageInfo: PageInfo!
}

# VideoBookmarkConnectionError is the error associated with a getVideoBookmarks.
type VideoBookmarkConnectionError {
  # The associated error code.
  code: VideoBookmarkConnectionErrorCode
}

# VideoBookmarkConnectionErrorCode are the possible errors that this query returns.
enum VideoBookmarkConnectionErrorCode {
  # An unexpected internal server error occurred.
  INTERNAL_SERVER_ERROR
  # The user is unauthorized to fetch bookmarks for the channel.
  USER_UNAUTHORIZED
}

# A video bookmark.
type VideoBookmarkEdge {
  # Uniquely identifies this clip's position in a connection.
  cursor: Cursor!
  # The bookmark.
  node: VideoBookmark!
}

# Comment on a video.
type VideoComment {
  # Author of the comment.
  commenter: User
  # Position of the video where this comment was added.
  contentOffsetSeconds: Int!
  # The time the comment was created.
  createdAt: Time!
  # The comments's unique identifier.
  id: ID!
  # The message of the comment.
  message: VideoCommentMessage
  # DEPRECATED. List of replies on this comment.
  replies(first: Int, after: Cursor): VideoCommentConnection @deprecated
  # Where the comment originated.
  source: VideoCommentSource!
  # Current state of the comment.
  state: VideoCommentState!
  # The last time this comment was updated.
  updatedAt: Time!
  # The video on which this comment was added.
  video: Video
}

# Paginated list of comments.
type VideoCommentConnection {
  edges: [VideoCommentEdge]
  pageInfo: PageInfo!
}

# Video comment edge with cursor and the comment node.
type VideoCommentEdge {
  cursor: Cursor
  node: VideoComment
}

# Represents the message of a comment.
type VideoCommentMessage {
  # Parts of the message body with meta info.
  fragments: [VideoCommentMessageFragment]
  # List of badges the comment author had selected for use at the time of the comment.
  userBadges: [Badge]
  # Text color preferences of comment's author.
  userColor: String
}

# Represents a part of the message body with meta info.
type VideoCommentMessageFragment {
  # Embedded emote info.
  emote: EmbeddedEmote
  # User which was mentioned.
  mention: User
  # Raw text of the comment.
  text: String!
}

# Where a video comment originated.
enum VideoCommentSource {
  # The comment originated from the live broadcast.
  CHAT
  # The comment was manually created by a commenter.
  COMMENT
  # The comment source is unknown.
  UNKNOWN
}

# Represents the state of a video comment.
enum VideoCommentState {
  # The comment is published.
  PUBLISHED
  # The comment was manually unpublished by a mod or the channel owner.
  UNPUBLISHED
  # The comment was automatically flagged for review (AutoMod).
  PENDING_REVIEW
  # The comment is possibly spam and has to be reviewed by a moderator.
  PENDING_REVIEW_SPAM
  # The comment has been soft-deleted.
  DELETED
}

# A paginated list of videos, and its metadata.
type VideoConnection {
  # The list of videos in this page.
  edges: [VideoEdge]
  # Information about this page of videos.
  pageInfo: PageInfo
  # The total number of videos in the larger collection.
  totalCount: Int
}

# Optional input to filter videos.
# Add any additional optional fields to this input.
input VideoConnectionOptionsInput {
  # The IDs of any categories that should be included in the results.
  gameIDs: [ID!]
  # Whether unpublished (private) videos should be returned. Will only be returned
  # for the currently authenticated user. Defaults to false.
  includePrivate: Boolean = false
  # The maximum length in seconds of any videos returned.
  maxLengthSeconds: Int
  # The minimum length in seconds of any videos returned.
  minLengthSeconds: Int
  # The ending creation date of any videos returned (not inclusive).
  searchRangeEndAt: Time
  # The starting creation date of any videos returned (not inclusive).
  searchRangeStartAt: Time
}

# A Video Connection Search input to set params to include search term.
input VideoConnectionSearchParams {
  # The search term to filter video results by.
  term: String
}

# Video download information.
type VideoDownload {
  # Status of the download process.
  status: VideoDownloadStatus!
  # Generated URL from which to download the video.
  url: String!
}

# List of possible video download statuses.
enum VideoDownloadStatus {
  # The video download is created.
  CREATED
  # The video download is submitted.
  SUBMITTED
  # The video download is downloading.
  DOWNLOADING
  # The video download is transmuxing.
  TRANSMUXING
  # The video download failed to create.
  FAILED
  # The video download is completed.
  COMPLETE
  # The video download status is unknown.
  UNKNOWN
}

# An element in a paginated list of videos, and its metadata.
type VideoEdge {
  cursor: Cursor
  node: Video
}

# Video Ingest Session Metadata for the current or past broadcasts.
type VideoIngestSession {
  # Stream session metadata related to broadcaster's backup ingest session.
  backupIngestSession: BackupIngestSession
  # Bitrates of session by time. Recorded every 3 to 5 seconds.
  bitrates(startedAt: Time, endedAt: Time): [StreamBitrate!]
  # Broadcaster of the stream.
  broadcaster: User
  # Recorded framedrop events in stream session.
  frameDrops: [IngestFrameDrop!]
  # Framerates of session by time. Recorded every 3 to 5 seconds.
  framerates(startedAt: Time, endedAt: Time): [StreamFramerate!]
  # The ID of the stream ingest session.
  id: ID!
  # Stream session metadata related to broadcaster's ingest session.
  ingestSession: IngestSession!
  # Stream session metadata related to broadcaster's RTMP session.
  rtmpSession: RTMPSession!
  # Recorded starvation events in stream session.
  starvationEvents: [IngestStarvationEvent!]
  # Set of codes to indicate what is wrong with ingested stream.
  streamHealth: IngestStreamHealth
  # Stream session metadata related to broadcaster's transcode session.
  transcodeSessions: [TranscodeSession!]
}

# A video moment represents either a point in time, or a duration of time,
# during which structured metadata is present.
type VideoMoment {
  # channel the VOD belongs to.
  channel: User!
  # Time at which the moment was created.
  createdAt: Time!
  # The displayable context of this moment (translated, where applicable). For
  # instance, the stream marker comment, game name for game change, or â€œPack openingâ€
  # for Hearthstone VCA. Can be null.
  description: String
  # A union of the fields that are specific to individual moments, such as Game Mode
  # inside Hearthstone VCA data.
  details: VideoMomentDetails
  # The duration, in ms, that this moment is applicable, or zero if no duration.
  durationMilliseconds: Int!
  # ID of the moment.
  id: ID!
  # Moments that cover a time range can also contain moments for that time range.
  moments: VideoMomentConnection
  # The time, in ms, after the start of the video when this moment occurs.
  positionMilliseconds: Int!
  # The additional displayable context of this moment (translated, where applicable).
  # Can be null.
  subDescription: String
  # The url to the thumbnail for this moment.
  # Can be null.
  thumbnailURL: String
  # The underlying moment type.
  type: VideoMomentType!
  # The id of the video this moment is contained in.
  video: Video
}

# A paginated list of video moments.
type VideoMomentConnection {
  # The elements of the paginated list.
  edges: [VideoMomentEdge!]!
  # Information about this page.
  pageInfo: PageInfo!
}

# A union of the fields that are specific to individual moments, such as Game Mode
# inside Hearthstone VCA data.
union VideoMomentDetails =
    GameChangeMomentDetails
  | HearthstoneMomentDetails
  | OverwatchMomentDetails
  | PUBGMomentDetails
# A video moment.
type VideoMomentEdge {
  # Uniquely identifies this moment's position in the connection.
  cursor: Cursor!
  # The moment.
  node: VideoMoment!
}

# These request types allow the client to request the backend to do
# some analysis and suggest markers that are relevant.
enum VideoMomentRequestType {
  # Moments most likely to be highlighted. Shown to creators.
  HIGHLIGHTER_SUGGESTIONS
  # Chapter markers shown in the video to viewers.
  VIDEO_CHAPTER_MARKERS
}

# Marker types present in momentum.
enum VideoMomentType {
  # Creator/editor selected moment.
  STREAM_MARKER
  # GAME_CHANGE is when the streamer changes the game during their stream.
  GAME_CHANGE
  # Hearthstone video content analysis markers.
  HEARTHSTONE_VCA
  # Overwatch video content analysis markers.
  OVERWATCH_VCA
  # PUBG video content analysis markers.
  PUBG_VCA
  # VCA generic VCA analysis markers.
  VCA
}

# Information about one contiguous muted portion of video.
type VideoMutedSegment {
  # Duration in seconds of the mute. Standard length is 360 (6 mins).
  duration: Int!
  # Offset is how many seconds into the video the mute begins. 0 indicates the beginning of the video is muted.
  offset: Int!
}

# A list of all sections of the video that are muted.
# If pagination is required at any point in the future, put edges and pageInfo
# in this type.
type VideoMutedSegmentConnection {
  # No pagination functionality. All data returned in initial call.
  nodes: [VideoMutedSegment!]
}

# Details about automatic mutes applied to this video.
type VideoMuteInfo {
  # List of segments muted.
  mutedSegmentConnection: VideoMutedSegmentConnection
  # List of tracks that are flagged for copyrighted music.
  tracks: [FlaggedTrack!]
}

type VideoOEmbed implements OEmbed {
  authorName: String
  authorURL: String
  cacheAge: Int
  height: Int!
  html: String!
  inputURL: String!
  providerName: String
  providerURL: String
  thumbnail: ThumbnailOEmbed
  title: String
  type: String!
  version: String!
  width: Int!
}

# Options to include private videos.
input VideoOptions {
  includePrivate: Boolean = false
}

# The required configuration to activate a video overlay extension.
input VideoOverlayActivationInput {
  # The slot name of where the component extension should be displayed.
  slot: String!
}

# VideoOverlayView holds the view configuration of an extension if the videoOverlay anchor is supported.
type VideoOverlayView implements ExtensionView {
  # Specifies whether or not the extension has the ability to link to external websites.
  canLinkExternalContent: Boolean!
  # Relative path of the HTML file to load for this view, used by devsite to specify the layout of assets.
  viewerPath: String!
  # The URL which should be loaded in for the extension.
  viewerURL: String!
}

# VideoOverlayViewInput holds the view configuration of an extension if the videoOverlay anchor is supported.
input VideoOverlayViewInput {
  # Relative path of the HTML file to load for this view.
  viewerPath: String!
}

# Endpoints for different video referral sources, based on channel and time range.
type VideoPlayReferrals {
  # The referral groups and respective counts.
  items: [AggregatedReferrals!]
  # Sum of all referrals for a given date range.
  total: Int!
}

enum VideoPrivacyScope {
  # The video is only viewable by the owner.
  PRIVATE
  # The video is listed in search and anyone can view the video.
  PUBLIC
}

# Restrictions for viewing of a video. Resolves if a video is restricted, null otherwise.
type VideoRestriction {
  # The product "short name" a user needs to purchase to view the video.
  productName: String!
  # The name of the product shown to users.
  productTitle: String!
  # The reason a video is restricted.
  reason: String!
  # The type of restriction the video has.
  type: String!
}

# The relationship between the authenticated user and a video.
type VideoSelfEdge {
  # Can a user watch a restricted video.
  isRestricted: Boolean!
  # User's viewing history against a video.
  viewingHistory: VideoViewingHistory
}

# A video shelf contains items (clips, videos) from a user to display on their videos page.
type VideoShelf {
  # The associated collection if the shelf items are from a specified collection.
  collection: Collection
  # A description of what the video shelf contains.
  description: String
  # The associated game with the shelf if the items are from a specified game.
  game: Game
  # ID of the video shelf.
  id: ID!
  # Videos/clips in the video shelf.
  items: [VideoShelfItem!]
  # The title of the video shelf.
  title: String!
  # The type of items the video shelf contains.
  type: VideoShelfType!
}

# A paginated list of video shelves with metadata.
type VideoShelfConnection {
  # The list of video shelves available.
  edges: [VideoShelfEdge!]
  # The max number of shelves configuration.
  maxShelfCount: Int
  # Information about this page of video shelves.
  pageInfo: PageInfo!
  # The total number of shelves available.
  totalCount: Int!
}

# A video shelf.
type VideoShelfEdge {
  # Cursor represents the position of the current edge/node.
  cursor: Cursor!
  # Uniquely identifies this video shelf's position in a connection.
  node: VideoShelf
}

# The item to render in a video shelf.
union VideoShelfItem = Clip | Video
# The type of item returned in the video shelf.
enum VideoShelfType {
  # Broadcasts sorted by recency.
  LATEST_BROADCASTS
  # Non broadcasts sorted by recency.
  LATEST_NON_BROADCASTS
  # Clips created within 30 days sorted by views.
  TOP_CLIPS
  # Videos under 30 minutes sorted by recency.
  SHORT_VIDEOS
  # Videos over 30 minutes sorted by recency.
  LONG_VIDEOS
  # Videos marked with a specified game sorted by recency.
  GAME
  # Videos from a specified collection.
  COLLECTION
  # All videos.
  ALL_VIDEOS
}

# Possible sort orders for lists of videos.
enum VideoSort {
  # Sort the videos descending by time (publishedAt if available or createdAt).
  TIME
  # Sort the videos ascending by time (publishedAt if available or createdAt).
  TIME_ASC
  # Sort the videos descending by views.
  VIEWS
}

enum VideoStatus {
  # The video is being recorded from a live broadcast.
  RECORDING
  # The video needs to be processed.
  UNPROCESSED
  # The upload job is ready to begin.
  CREATED
  # The video is being uploaded.
  UPLOADING
  # The video is being transcoded.
  PENDING_TRANSCODE
  # The video is currently transcoding.
  TRANSCODING
  # Something went wrong.
  FAILED
  # The video is ready to watch.
  RECORDED
}

# Video stream settings for ingesting a stream such as stream key, latency mode, or vod save preference.
# Represents a user's channel setting when starting a streamm.
type VideoStreamSettings {
  # A list of Twitch users who are authorized to stream on behalf of a broadcaster.
  authorizedUsers: [User!]
  # A list of stream keys to be used for backup redundant stream.
  backupStreamKeys: [StreamKeyResult!]!
  # The number of seconds delay for a stream. When this is set, a stream will be ingested with specified delay in seconds.
  delaySeconds: Int!
  # The number of seconds to display the disconnect slate while the stream is unstable.
  disconnectSlateDurationSeconds: Int!
  # When isBackupEnabled is true, streamers can stream a backup stream using the streamkey on backupStreamKeys.
  isBackupEnabled: Boolean!
  # When isDelayEnabled is true, streamers can stream with specified delay seconds on delaySeconds.
  isDelayEnabled: Boolean!
  # When isDisconnectSlateEnabled is true, streams will show a disconnect slate
  # for the period specified on delaySeconds when a stream disconnects temporarily.
  isDisconnectSlateEnabled: Boolean!
  # Whether or not a stream should be started as a low latency stream.
  isLowLatency: Boolean!
  # Whether or not the broadcaster prefers to archive the vod for a stream.
  shouldArchiveVODs: Boolean!
  # The RTMP stream key for the user's channel. This key is required to stream a video to Twitch.
  streamKey: StreamKeyResult!
}

# Details about creating an automated highlight from this video.
type VideoSuggestedHighlight {
  # Boolean for whether this set of suggested segments were addressed and dismissed.
  isDismissed: Boolean!
  # List of suggested video segments.
  segments: [VideoSuggestedSegment]!
  # Status of the segments.
  status: SegmentsStatusType
}

# Information for one suggested video segment.
type VideoSuggestedSegment {
  # Ending time of the suggested segment in milliseconds.
  endMS: Int!
  # Starting time of the suggested segment in milliseconds.
  startMS: Int!
}

# Filtering criteria for paginated video top clips results.
input VideoTopClipsInput {
  # The ID of the curator to filter results by.
  curatorID: ID
  # The time period to restrict clips based on creation time.
  period: ClipsPeriod = LAST_WEEK
  # The sort order for the clips results.
  sort: ClipsSort = VIEWS_DESC
}

# Describes what type of content this originated from.
# NOTE: There is already an enum named BroadcastType which should have been named VideoBroadcastType.
enum VideoType {
  # The video type is live.
  LIVE
  # The video is a vod.
  VOD
}

# User's viewing history against a video. All fields are null if no viewing history is available.
type VideoViewingHistory {
  # Position in seconds since the start of the video.
  position: Int
  # When the viewing history was last updated.
  updatedAt: Time
}

type ViewedNotificationsPayload {
  # The modified user which contains an updated OnsiteNotificationsSummary.
  user: User
}

# A paginated list of viewed videos, their histories, and metadata.
type ViewedVideosConnection {
  # The list of videos and their viewing histories in this page.
  edges: [ViewedVideosEdge]
}

# An element in a paginated list of viewing histories, and its metadata.
type ViewedVideosEdge {
  # Viewing history of user against the video.
  history: VideoViewingHistory!
  # Video this viewing history belongs to.
  node: Video!
}

# Paginated list of VIP users of a channel.
type VIPConnection {
  # The elements of the list.
  edges: [VIPEdge!]!
  # Information about this page.
  pageInfo: PageInfo!
}

# Element in a list of VIP users of a channel.
type VIPEdge {
  # Opaque cursor describing this edge's position in the paginated list.
  cursor: Cursor!
  # Timestamp of when the VIP status was granted.
  grantedAt: Time!
  # The user who has the VIP status.
  node: User
}

# The user's shared availability while online.
# A value of ONLINE (typically called invisibility) additionally means that the user's activity will not be shared
# regardless of the isSharingActivity setting.
# NOTE: Should have been named UserOnlineVisibility.
enum Visibility {
  ONLINE
  AWAY
  BUSY
  OFFLINE
}

# A visibility type for the user.
enum VisibilityInput {
  # An ONLINE visibility (default) will cause the user's availability to be inherited from their sessions -- Online if
  # they have at least one non-idle session, Away if they have only idle sessions, or Offline if they have no sessions.
  ONLINE
  # An AWAY visibility will cause the user to appear as Away if they have any sessions, regardless of idleness, or
  # Offline if they have no sessions.
  AWAY
  # A BUSY visibility will cause the user to appear as Busy if they have any sessions, regardless of idleness, or
  # Offline if they have no sessions.
  BUSY
  # An OFFLINE visibility (also called "invisible") will cause the user to appear as Offline always. It will also
  # implicitly turn off activity sharing.
  OFFLINE
}

# Input for Visit Stream Manager.
input VisitStreamManagerInput {
  # The channel ID of the stream manager visited.
  channelID: ID!
}

# Payload returned from Visit Stream Manager call.
type VisitStreamManagerPayload {
  # The channel ID of the stream manager visited.
  channelID: ID
  # The success/failure of the client.
  isSuccess: Boolean
  # The viewer ID trying to view the stream manager.
  viewerID: ID
}

# Vote in poll error.
type VoteInAdPollError {
  # Code describing the error.
  code: VoteInAdPollErrorCode!
}

# Vote in poll error code.
enum VoteInAdPollErrorCode {
  # User tried to vote in a poll that doesn't exist i.e. there is no poll running at all).
  POLL_NOT_FOUND
  # User tried to vote in a poll that is not active.
  POLL_NOT_ACTIVE
  # Request has a vote ID that is in progress or has already been submitted.
  VOTE_ID_CONFLICT
  # Voter is trying to vote more times than the maximum number of times that the poll allows.
  MAX_VOTE_LIMIT_ERROR
  # User is trying to vote for another choice in a poll that only allows one choice.
  MULTI_CHOICE_VOTE_FORBIDDEN
  # Request is for a choice ID that invalid.
  INVALID_CHOICE_ID
  # An unknown error occurred.
  UNKNOWN
}

# Inputs for voting on an ad poll.
input VoteInAdPollInput {
  # The id of the choice the vote is casted on in the poll.
  choiceID: ID!
  # The id of the poll that is being voted in.
  pollID: ID!
  # The voter id of the voter.
  userID: ID!
  # The unique id for this vote action.
  voteID: ID!
}

# Output from the vote on poll mutation.
type VoteInAdPollPayload {
  # If present, there was an error with the request.
  error: VoteInAdPollError
  # The voter objet returned by the vote operation.
  vote: AdPollVote
}

# Inputs for voting on a poll by choice index.
# Poll id and choice id are retrieved from the backend, before sending the vote.
input VoteInPollByChoiceIndexInput {
  # The id of the channel the vote is being cast in.
  channelID: ID!
  # Important: The ***ONE INDEXED*** (NOT ZERO INDEXED) position of the choice that is chosen in the poll.
  choiceIndex: Int!
  # The tokens used for this vote.
  tokens: PollVoteTokensInput
  # The user id of the voter.
  userID: ID!
  # The unique id for this vote action.
  voteID: ID!
}

# Output from the vote on poll by choice index mutation.
type VoteInPollByChoiceIndexPayload {
  # If present, there was an error with the request.
  error: VoteInPollError
  # The voter objet returned by the vote operation.
  voter: PollVoter
}

# Vote in poll error.
type VoteInPollError {
  # Code describing the error.
  code: VoteInPollErrorCode!
}

# Vote in poll error code.
enum VoteInPollErrorCode {
  # User tried to vote in a poll that doesn't exist i.e. there is no poll running at all).
  POLL_NOT_FOUND
  # User tried to vote in a poll that is not active.
  POLL_NOT_ACTIVE
  # Request has a vote ID that is in progress or has already been submitted.
  VOTE_ID_CONFLICT
  # User is trying to vote for another choice in a poll that only allows one choice.
  MULTI_CHOICE_VOTE_FORBIDDEN
  # Request is for a channel ID that is invalid (e.g. banned channel, channel doesn't exist).
  INVALID_CHANNEL_ID
  # Request is for a choice index that is invalid (e.g. there are 3 choices and the request is for index 10).
  INVALID_CHOICE_INDEX
  # Request is for a choice ID that invalid.
  INVALID_CHOICE_ID
  # Request is for an invalid bits amount (e.g. -100 bits, or request is not for a multiple of the Bits cost).
  INVALID_BITS_AMOUNT
  # Request is for an invalid Community Points amount (e.g. -100 Points, or request is not for a multiple of the Points cost).
  INVALID_COMMUNITY_POINTS_AMOUNT
  # User's bits balance is too low to perform request (e.g. they only have 10 bits and they request to spend 100).
  INSUFFICIENT_BITS_BALANCE
  # Users's Community Points balance is too low to perform request (e.g. they only
  # have 10 points and they request to spend 100).
  INSUFFICIENT_COMMUNITY_POINTS_BALANCE
  # User has already used their base votes, so in order to continue voting, they must use tokens (bits or channel points).
  TOKENS_REQUIRED
  # User is not allowed to vote in poll (e.g. they're banned in the channel).
  USER_FORBIDDEN
  # User is not allowed to vote in their own poll with bits.
  SELF_BITS_VOTE_NOT_ALLOWED
  # User cannot vote because they have hit a per-user or per-poll rate limit. The user can try again later.
  RATE_LIMITED
  # An unknown error occurred.
  UNKNOWN
}

# Inputs for voting on a poll.
input VoteInPollInput {
  # The id of the choice the vote is casted on in the poll.
  choiceID: ID!
  # The id of the poll that is being voted in.
  pollID: ID!
  # The tokens used for this vote.
  tokens: PollVoteTokensInput
  # The user id of the voter.
  userID: ID!
  # The unique id for this vote action.
  voteID: ID!
}

# Output from the vote on poll mutation.
type VoteInPollPayload {
  # If present, there was an error with the request.
  error: VoteInPollError
  # The voter object returned by the vote operation.
  voter: PollVoter
}

# Twitch Wallet Balances in multiple FIAT currencies. Can be used to purchase
# product on the Twitch Platform.
type WalletBalances {
  # List of all Balances that a Twitch User has on their account.
  allBalances: [Balance!]
  # Currencies that an Twitch User is currently eligible to use.
  eligibleCurrencies: [Currency!]
}

# User's can have different wallet types based on legal and accounting
# requirements.
enum WalletType {
  # Only supports loading from FIAT currencies from gift card providers.
  GIFT_CARD
}

type Watching implements Activity {
  # This activity's type, i.e. "WATCHING".
  type: ActivityType
  # The user whose stream is being watched.
  user: User
}

# The possible restrictions for a user trying to host Watch Parties.
enum WatchPartiesRestriction {
  # A user cannot host Watch Parties in their current region.
  REGION_NOT_SUPPORTED
  # Unknown restriction.
  UNKNOWN
}

# Contains all information for Prime Video Watch Parties.
type WatchParty {
  # Enum representing the restrictions on this Watch Party.
  contentRestriction: WatchPartyContentRestriction!
  # Option Watch Party decoration.
  decoration: WatchPartyDecoration
  # The catalog item id played for this watch party.
  gti: ID! @deprecated(reason: "Use decoration.item.id")
  # Unique ID of the watch party.
  id: ID!
  # Progress of the current state, null for offline watch parties.
  progress: WatchPartyProgress
  # Current state of the watch party.
  state: WatchPartyState!
  # Current title of the watch party.
  title: String!
  # CCVs for the watch party.
  viewersCount: Int!
}

# Restrictions on a piece of content.
enum WatchPartyContentRestriction {
  # Default type.
  UNKNOWN
  # Content is viewable by majority regions.
  BROAD_AVAILABILITY
  # Content is viewable in a select number of regions.
  LIMITED_AVAILABILITY
}

# Decoration information for a Watch Party.
type WatchPartyDecoration {
  # Fully decorated item for a watch party.
  item: WatchPartyItem!
  # Authenticated: filled in only if the user is authorized to watch the content.
  player: WatchPartyPlayer
}

# Information to communicate to the user about an error state.
type WatchPartyError {
  # Error code.
  code: WatchPartyErrorCode!
}

# Enum for user errors.
enum WatchPartyErrorCode {
  # Used for invalid requests.
  BAD_REQUEST
  # Used when the access token is expired.
  FORBIDDEN
  # Used when the user's request is throttled.
  REQUEST_THROTTLED
  # Used when the user is geo restricted.
  GEO_RESTRICTED
  # Used when the error is unknown.
  UNKNOWN
}

# Contains all fields needed to render a watch party item.
type WatchPartyItem {
  # String representing the age rating.
  contentRating: String
  # Enum representing the restrictions on this item. When available, defer to
  # the Watch Party content restriction.
  contentRestriction: WatchPartyContentRestriction!
  # Additional details based on the item type.
  details: WatchPartyItemDetails
  # List of genres.
  genres: [String!]!
  # Whether or not this item has children content.
  hasChildren: Boolean!
  # Unique GTI.
  id: ID!
  # If the content is mature.
  isMature: Boolean!
  # If this is a child, ID of the parent.
  parentID: ID
  # Link to continue watching on PV.
  primeVideoLink: String
  # Prime video rating.
  primeVideoRating: PrimeVideoRating
  # Null if user is logged out, contains eligibility information.
  self: WatchPartyItemSelfEdge
  # List of actors and actresses.
  starring: [String!]!
  # Localized summary.
  summary: String
  # Localized box art.
  thumbnailURL: String!
  # Localized title.
  title: String!
  # Video content type, i.e. episode or series.
  type: WatchPartyItemType!
  # Publication year.
  yearPublished: Int
  # Whether the content has parental control restrictions enabled.
  isParentalControlRestricted: Boolean
}

# Watch party items, returned in a query.
type WatchPartyItemConnection {
  # One item per edge.
  edges: [WatchPartyItemEdge!]!
  # Used for user authentication errors.
  error: WatchPartyError
  # Amazon link.
  homepageBrowseLink: String!
  # Pagination info.
  pageInfo: PageInfo!
}

# Additional information about content.
union WatchPartyItemDetails =
    EpisodeDetails
  | MovieDetails
  | SeasonDetails
  | SeriesDetails
# Represents a single item for a watch party.
type WatchPartyItemEdge {
  # Cursor to continue querying from here.
  cursor: Cursor!
  # Item information.
  node: WatchPartyItem!
}

# Contains information about viewer eligibility, likely to change.
type WatchPartyItemEligibility {
  # Whether the viewer can watch this content.
  canView: Boolean!
  # Localized string explaining why if canView is false.
  reason: String
}

# Options for querying for catalog items. These fields are mutually exclusive
# and parentID will take precedent if both are specified.
input WatchPartyItemSearchOptions {
  # Parameter to query for a parent's children items.
  parentID: ID
  # Search for content based on the input string.
  searchQuery: String
}

# Used for upselling Prime, populated from authentication or geotoken.
type WatchPartyItemSelfEdge {
  # Info about whether or not the user can view this piece of content.
  eligibility: WatchPartyItemEligibility!
  # True if the content is PV gated and we will upsell.
  willShowPrimeUpsell: Boolean!
}

# Content types for Prime Video.
enum WatchPartyItemType {
  # Default type.
  UNKNOWN
  # A leaf node episode in a series/season.
  EPISODE
  # A leaf node movie.
  MOVIE
  # Usually a collection of episodes.
  SEASON
  # Usually a collection of seasons.
  SERIES
}

# Contains information needed to initialize a PV player and play content.
type WatchPartyPlayer {
  # Device Proxy URL to initialize the PV player.
  deviceProxyBaseURL: String!
  # Parameters to initialize the PV player.
  sdkInit: String!
  # Token to initialize the PV player.
  token: String!
}

# Tracks the current state.
type WatchPartyProgress {
  # Total duration of the current state.
  durationSeconds: Int!
  # Current position in seconds of the state.
  positionSeconds: Int!
  # Wall clock time for the start of the current state.
  start: Time!
}

# Wrapper to allow passing back errors.
type WatchPartyResult {
  # Used for user authentication errors.
  error: WatchPartyError
  # Can be null if the channel is offline or for authentication errors.
  session: WatchParty
}

# Enum for state.
enum WatchPartyState {
  # Default value.
  UNKNOWN
  # Pre-play countdown.
  HYPE_IN
  # In progress, video playback.
  IN_PROGRESS
  # Offline.
  OFFLINE
}

# A message sent in a whisper thread.
type WhisperMessage {
  # Content of the message.
  content: MessageBody!
  # Time the message was deleted.
  deletedAt: Time
  # Time the message was edited.
  editedAt: Time
  # User that sent the message.
  from: User!
  # UUID of the message.
  id: ID!
  # Unique nonce.
  nonce: String
  # Time the message was sent.
  sentAt: Time!
  # The thread the message is a part of.
  thread: WhisperThread!
}

# Paginated list of messages in a thread.
type WhisperMessageConnection {
  # The elements of the list.
  edges: [WhisperMessageEdge!]!
  # Information about this page.
  pageInfo: PageInfo!
}

# Element in a list of messages.
type WhisperMessageEdge {
  # Opaque cursor describing this edge's position in the paginated list.
  cursor: Cursor!
  # The whisper message.
  node: WhisperMessage!
}

# The ability for a Twitch user to send or receive Whispers to/from another Twitch user.
type WhisperPermissions {
  # If send is NOT_PERMITTED, true if the reason is that the other Twitch user is considered a stranger.
  isStrangerBlocked: Boolean!
  # Capability of the user to receive Whispers from the other Twitch user.
  receive: WhisperPermissionType
  # Capability of the user to send Whispers to the other Twitch user.
  send: WhisperPermissionType
}

# An enumeration of the permissions for one user to Whisper another.
enum WhisperPermissionType {
  # The sender is allowed to Whisper the recipient.
  PERMITTED
  # The sender is not allowed to Whisper the recipient.
  NOT_PERMITTED
  # Any sender is able to Whisper the recipient.
  NOT_RESTRICTED
  # The sender is temporarily allowed to Whisper the recipient.
  TEMPORARY
}

# Settings related to the Whispers (private user-to-user messaging) feature.
type WhisperSettings {
  # If true, disallows strangers from initiating a whisper thread to this user.
  isBlockingWhispersFromStrangers: Boolean!
  # If true, this user is disallowed from sending or receiving whisper messages.
  isWhisperBanned: Boolean!
}

# Spam classification data for a message.
type WhisperSpamInfo {
  # Time user last marked the thread as not spam.
  lastMarkedNotSpamAt: Time
  # Spam classification score.
  likelihood: WhisperSpamLikelihood
}

enum WhisperSpamLikelihood {
  LOW
  MEDIUM
  HIGH
}

# A conversation between two users.
type WhisperThread {
  # ID of the whisper thread.
  id: ID!
  # Whether the thread has been archived.
  isArchived: Boolean!
  # Whether the user has muted the thread.
  isMuted: Boolean!
  # The last message sent in this thread. Null if no messages in this thread.
  lastMessage: WhisperMessage
  # List of messages in the thread.
  messages(first: Int = 10, after: Cursor): WhisperMessageConnection
  # List of users in the thread.
  participants: [User]!
  # Spam data about the thread.
  spamInfo: WhisperSpamInfo
  # Number of whispers that have not been read by the user in the thread.
  unreadMessagesCount: Int!
  # Last message read by the user in the thread.
  userLastMessageRead: WhisperMessage
    @deprecated(reason: "Not used. Use lastMessage to get the last message. ")
  # Timestamp of when the other participant may message the user in the thread.
  whitelistedUntil: Time
}

# Paginated list of whisper threads.
type WhisperThreadConnection {
  # The elements of the list.
  edges: [WhisperThreadEdge!]!
  # Information about this page.
  pageInfo: PageInfo!
  # Total number of whisper threads.
  totalCount: Int!
  # Total number of whisper threads containing unread messages for the current user.
  totalUnreadCount: Int
}

# Element in a list of whisper threads.
type WhisperThreadEdge {
  # Opaque cursor describing this edge's position in the paginated list.
  cursor: Cursor!
  # The whisper thread.
  node: WhisperThread!
}

# Withholding Tax Detail is the withholding tax rates for the creator.
type WithholdingTaxDetail {
  # Government royalty tax rate applied to user's earnings.
  royaltyTaxRate: Float!
  # Government service tax rate applied to user's earnings.
  serviceTaxRate: Float!
}

# Contains configuration used to setup checkout via Xsolla, a payment provider.
type Xsolla {
  # Iframe URL to allow purchase checkout. This can be an empty string if the URL cannot be generated.
  iframeURL: String!
    @deprecated(reason: "moving iframe URL generation client-side")
  # Indicates if the token is for Xsolla's sandbox environment.
  isSandbox: Boolean!
  # Access token to allow purchase checkout. This can be an empty string if the token cannot be generated.
  token: String!
}

type XsollaConfigs {
  # Iframe URL to allow payment method management or purchase checkout
  # There are various cases in which this can be null. One example during
  # subscription purchase checkout flow is if there is an issue with the
  # Xsolla product mapping to the product in Twitch's system.
  iframeURL: String!
    @deprecated(reason: "Moving iframe URL generation to Twilight")
  # Access token to allow purchase checkout. This can be an empty string if the token cannot be generated.
  token: String!
  # Indicates if the token is for Xsolla's sandbox environment.
  isSandbox: Boolean!
}

type ZuoraConfigs {
  # Twitch merchant account ID on Zuora.
  externalAccountID: ID!
  # ID of the hosted page we will render.
  hostedPageID: ID!
  # URL of the hosted page we will render.
  hostedPageURL: String!
  # Used to encrypt sensitive information.
  publicKey: String!
  # Need to pass generated signature to access Zuora payment pages.
  signature: String!
  # In some cases, when you contact Zuora Support with an issue, the person helping you may ask you to provide the tenant ID.
  tenantID: ID!
  # Zuora API uses token as part of authentication.
  token: String!
}

